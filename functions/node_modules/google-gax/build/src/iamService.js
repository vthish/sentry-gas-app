"use strict";

















Object.defineProperty(exports, "__esModule", { value: true });
exports.IamClient = void 0;
const createApiCall_1 = require("./createApiCall");
const routingHeader = require("./routingHeader");
const gapicConfig = require("./iam_policy_service_client_config.json");
const fallback = require("./fallback");
let version = require('../../package.json').version;
const jsonProtos = require("../protos/iam_service.json");

class IamClient {
    constructor(gaxGrpc, 

    options) {
        this._terminated = false;
        this.descriptors = { page: {}, stream: {}, longrunning: {} };
        this.innerApiCalls = {};
        this.gaxGrpc = gaxGrpc;

        const opts = Object.assign({
            servicePath: options.servicePath,
            port: options.port,
            clientConfig: options.clientConfig,
            apiEndpoint: options.apiEndpoint,
            fallback: options.fallback,
        }, options);
        version = opts.fallback ? fallback.version : version;
        opts.scopes = this.constructor.scopes;

        this._opts = opts;

        this.auth = gaxGrpc.auth;

        const clientHeader = [`gax/${version}`, `gapic/${version}`];
        if (typeof process !== 'undefined' && 'versions' in process) {
            clientHeader.push(`gl-node/${process.versions.node}`);
        }
        else {
            clientHeader.push(`gl-web/${version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }

        this._protos = this.gaxGrpc.loadProtoJSON(jsonProtos);

        this._defaults = gaxGrpc.constructSettings('google.iam.v1.IAMPolicy', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });
        this.innerApiCalls = {};
    }
    
    initialize() {

        if (this.iamPolicyStub) {
            return this.iamPolicyStub;
        }


        this.iamPolicyStub = this.gaxGrpc.createStub(this._opts.fallback
            ? this._protos.lookupService('google.iam.v1.IAMPolicy')
            : this._protos.google.iam.v1.IAMPolicy, this._opts);


        const iamPolicyStubMethods = [
            'getIamPolicy',
            'setIamPolicy',
            'testIamPermissions',
        ];
        for (const methodName of iamPolicyStubMethods) {
            const innerCallPromise = this.iamPolicyStub.then(stub => (...args) => {
                if (this._terminated) {
                    return Promise.reject('The client has already been closed.');
                }
                const func = stub[methodName];
                return func.apply(stub, args);
            }, (err) => () => {
                throw err;
            });
            this.innerApiCalls[methodName] = (0, createApiCall_1.createApiCall)(innerCallPromise, this._defaults[methodName], this.descriptors.page[methodName]);
        }
        return this.iamPolicyStub;
    }
    
    static get servicePath() {
        return 'cloudkms.googleapis.com';
    }
    
    static get apiEndpoint() {
        return 'cloudkms.googleapis.com';
    }
    
    static get port() {
        return 443;
    }
    
    static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/cloudkms',
        ];
    }
    getProjectId(callback) {
        if (this.auth && 'getProjectId' in this.auth) {
            return this.auth.getProjectId(callback);
        }
        if (callback) {
            callback(new Error('Cannot determine project ID.'));
        }
        else {
            return Promise.reject('Cannot determine project ID.');
        }
    }
    getIamPolicy(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] =
            routingHeader.fromParams({
                resource: request.resource,
            });
        this.initialize();
        return this.innerApiCalls.getIamPolicy(request, options, callback);
    }
    setIamPolicy(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] =
            routingHeader.fromParams({
                resource: request.resource,
            });
        this.initialize();
        return this.innerApiCalls.setIamPolicy(request, options, callback);
    }
    testIamPermissions(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] =
            routingHeader.fromParams({
                resource: request.resource,
            });
        this.initialize();
        return this.innerApiCalls.testIamPermissions(request, options, callback);
    }
    
    close() {
        this.initialize();
        if (!this._terminated) {
            return this.iamPolicyStub.then(stub => {
                this._terminated = true;
                stub.close();
            });
        }
        return Promise.resolve();
    }
}
exports.IamClient = IamClient;

