"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CallSettings = exports.RetryOptions = void 0;
exports.convertRetryOptions = convertRetryOptions;
exports.createRetryOptions = createRetryOptions;
exports.createBackoffSettings = createBackoffSettings;
exports.createDefaultBackoffSettings = createDefaultBackoffSettings;
exports.createMaxRetriesBackoffSettings = createMaxRetriesBackoffSettings;
exports.createBundleOptions = createBundleOptions;
exports.constructSettings = constructSettings;
exports.createByteLengthFunction = createByteLengthFunction;
const warnings_1 = require("./warnings");
const util_1 = require("./util");
const status_1 = require("./status");


class RetryOptions {
    constructor(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {
        this.retryCodes = retryCodes;
        this.backoffSettings = backoffSettings;
        this.shouldRetryFn = shouldRetryFn;
        this.getResumptionRequestFn = getResumptionRequestFn;
    }
}
exports.RetryOptions = RetryOptions;
class CallSettings {
    
    constructor(settings) {
        var _a;
        settings = settings || {};
        this.timeout = settings.timeout || 30 * 1000;
        this.retry = settings.retry;
        this.autoPaginate =
            'autoPaginate' in settings ? settings.autoPaginate : true;
        this.maxResults = settings.maxResults;
        this.otherArgs = settings.otherArgs || {};
        this.bundleOptions = settings.bundleOptions;
        this.isBundling = 'isBundling' in settings ? settings.isBundling : true;
        this.longrunning =
            'longrunning' in settings ? settings.longrunning : undefined;
        this.apiName = (_a = settings.apiName) !== null && _a !== void 0 ? _a : undefined;
        this.retryRequestOptions = settings.retryRequestOptions;
    }
    
    merge(options) {
        if (!options) {
            return new CallSettings(this);
        }
        let timeout = this.timeout;
        let retry = this.retry;
        let autoPaginate = this.autoPaginate;
        let maxResults = this.maxResults;
        let otherArgs = this.otherArgs;
        let isBundling = this.isBundling;
        let longrunning = this.longrunning;
        let apiName = this.apiName;
        let retryRequestOptions = this.retryRequestOptions;


        if ('timeout' in options) {
            timeout = options.timeout;
        }



        if (retry === null || retry === void 0 ? void 0 : retry.retryCodes) {
            retry.backoffSettings.initialRpcTimeoutMillis = timeout;
            retry.backoffSettings.maxRpcTimeoutMillis = timeout;
            retry.backoffSettings.totalTimeoutMillis = timeout;
        }
        if ('retry' in options) {
            retry = mergeRetryOptions(retry || {}, options.retry);
        }
        if ('autoPaginate' in options && !options.autoPaginate) {
            autoPaginate = false;
        }
        if ('maxResults' in options) {
            maxResults = options.maxResults;
        }
        if ('otherArgs' in options) {
            otherArgs = {};
            for (const key in this.otherArgs) {
                otherArgs[key] = this.otherArgs[key];
            }
            for (const optionsKey in options.otherArgs) {
                otherArgs[optionsKey] = options.otherArgs[optionsKey];
            }
        }
        if ('isBundling' in options) {
            isBundling = options.isBundling;
        }
        if ('maxRetries' in options && options.maxRetries !== undefined) {
            retry.backoffSettings.maxRetries = options.maxRetries;
            delete retry.backoffSettings.totalTimeoutMillis;
        }
        if ('longrunning' in options) {
            longrunning = options.longrunning;
        }
        if ('apiName' in options) {
            apiName = options.apiName;
        }
        if ('retryRequestOptions' in options) {
            retryRequestOptions = options.retryRequestOptions;
        }
        return new CallSettings({
            timeout,
            retry,
            bundleOptions: this.bundleOptions,
            longrunning,
            autoPaginate,
            maxResults,
            otherArgs,
            isBundling,
            apiName,
            retryRequestOptions,
        });
    }
}
exports.CallSettings = CallSettings;

function convertRetryOptions(options, gaxStreamingRetries) {
    var _a, _b, _c, _d;

    if (!options) {
        return options;
    }


    if (!gaxStreamingRetries) {
        return options;
    }
    if (options.retry && options.retryRequestOptions) {
        throw new Error('Only one of retry or retryRequestOptions may be set');
    } // handles parameter conversion from retryRequestOptions to retryOptions
    if (options.retryRequestOptions) {
        if (options.retryRequestOptions.objectMode !== undefined) {
            (0, warnings_1.warn)('retry_request_options', 'objectMode override is not supported. It is set to true internally by default in gax.', 'UnsupportedParameterWarning');
        }
        if (options.retryRequestOptions.noResponseRetries !== undefined) {
            (0, warnings_1.warn)('retry_request_options', 'noResponseRetries override is not supported. Please specify retry codes or a function to determine retry eligibility.', 'UnsupportedParameterWarning');
        }
        if (options.retryRequestOptions.currentRetryAttempt !== undefined) {
            (0, warnings_1.warn)('retry_request_options', 'currentRetryAttempt override is not supported. Retry attempts are tracked internally.', 'UnsupportedParameterWarning');
        }
        let retryCodes = [status_1.Status.UNAVAILABLE];
        let shouldRetryFn;
        if (options.retryRequestOptions.shouldRetryFn) {
            retryCodes = [];
            shouldRetryFn = options.retryRequestOptions.shouldRetryFn;
        }

        options.maxRetries =
            (_b = (_a = options === null || options === void 0 ? void 0 : options.retryRequestOptions) === null || _a === void 0 ? void 0 : _a.retries) !== null && _b !== void 0 ? _b : options.maxRetries;

        const backoffSettings = createDefaultBackoffSettings();
        let maxRetryDelayMillis;
        let totalTimeoutMillis;

        if (options.retryRequestOptions.maxRetryDelay !== undefined) {
            maxRetryDelayMillis = options.retryRequestOptions.maxRetryDelay * 1000;
        }

        const retryDelayMultiplier = (_d = (_c = options === null || options === void 0 ? void 0 : options.retryRequestOptions) === null || _c === void 0 ? void 0 : _c.retryDelayMultiplier) !== null && _d !== void 0 ? _d : backoffSettings.retryDelayMultiplier;

        if (options.retryRequestOptions.totalTimeout !== undefined) {
            totalTimeoutMillis = options.retryRequestOptions.totalTimeout * 1000;
        }
        else {
            if (options.maxRetries === undefined) {
                totalTimeoutMillis = 30000;
                (0, warnings_1.warn)('retry_request_options_no_max_retries_timeout', 'Neither maxRetries nor totalTimeout were passed. Defaulting to totalTimeout of 30000ms.', 'MissingParameterWarning');
            }
        }

        backoffSettings.maxRetryDelayMillis =
            maxRetryDelayMillis !== null && maxRetryDelayMillis !== void 0 ? maxRetryDelayMillis : backoffSettings.maxRetryDelayMillis;
        backoffSettings.retryDelayMultiplier =
            retryDelayMultiplier !== null && retryDelayMultiplier !== void 0 ? retryDelayMultiplier : backoffSettings.retryDelayMultiplier;
        backoffSettings.totalTimeoutMillis =
            totalTimeoutMillis !== null && totalTimeoutMillis !== void 0 ? totalTimeoutMillis : backoffSettings.totalTimeoutMillis;
        const convertedRetryOptions = createRetryOptions(retryCodes, backoffSettings, shouldRetryFn);
        options.retry = convertedRetryOptions;
        delete options.retryRequestOptions; // completely remove them to avoid any further confusion
        (0, warnings_1.warn)('retry_request_options', 'retryRequestOptions will be deprecated in a future release. Please use retryOptions to pass retry options at call time', 'DeprecationWarning');
    }
    return options;
}

function createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn) {
    return {
        retryCodes,
        backoffSettings,
        shouldRetryFn,
        getResumptionRequestFn,
    };
}

function createBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, totalTimeoutMillis) {
    return {
        initialRetryDelayMillis,
        retryDelayMultiplier,
        maxRetryDelayMillis,
        initialRpcTimeoutMillis,
        rpcTimeoutMultiplier,
        maxRpcTimeoutMillis,
        totalTimeoutMillis,
    };
}
function createDefaultBackoffSettings() {
    return createBackoffSettings(100, 1.3, 60000, null, null, null, null);
}

function createMaxRetriesBackoffSettings(initialRetryDelayMillis, retryDelayMultiplier, maxRetryDelayMillis, initialRpcTimeoutMillis, rpcTimeoutMultiplier, maxRpcTimeoutMillis, maxRetries) {
    return {
        initialRetryDelayMillis,
        retryDelayMultiplier,
        maxRetryDelayMillis,
        initialRpcTimeoutMillis,
        rpcTimeoutMultiplier,
        maxRpcTimeoutMillis,
        maxRetries,
    };
}

function createBundleOptions(options) {
    const params = [
        'element_count_threshold',
        'element_count_limit',
        'request_byte_threshold',
        'request_byte_limit',
        'delay_threshold_millis',
    ];
    params.forEach(param => {
        if (param in options && typeof options[param] !== 'number') {
            throw new Error(`${param} should be a number`);
        }
    });
    const elementCountThreshold = options.element_count_threshold || 0;
    const elementCountLimit = options.element_count_limit || 0;
    const requestByteThreshold = options.request_byte_threshold || 0;
    const requestByteLimit = options.request_byte_limit || 0;
    const delayThreshold = options.delay_threshold_millis || 0;
    if (elementCountThreshold === 0 &&
        requestByteThreshold === 0 &&
        delayThreshold === 0) {
        throw new Error('one threshold should be > 0');
    }
    return {
        elementCountThreshold,
        elementCountLimit,
        requestByteThreshold,
        requestByteLimit,
        delayThreshold,
    };
}

function constructRetry(methodConfig, retryCodes, retryParams, retryNames) {
    if (!methodConfig) {
        return null;
    }
    let codes = null; // this is one instance where it will NOT be an array OR a function because we do not allow shouldRetryFn in the client
    if (retryCodes && 'retry_codes_name' in methodConfig) {
        const retryCodesName = methodConfig['retry_codes_name'];
        codes = (retryCodes[retryCodesName] || []).map(name => {
            return Number(retryNames[name]);
        });
    }
    let backoffSettings = null;
    if (retryParams && 'retry_params_name' in methodConfig) {
        const params = retryParams[methodConfig.retry_params_name];
        backoffSettings = createBackoffSettings(params.initial_retry_delay_millis, params.retry_delay_multiplier, params.max_retry_delay_millis, params.initial_rpc_timeout_millis, params.rpc_timeout_multiplier, params.max_rpc_timeout_millis, params.total_timeout_millis);
    }
    return createRetryOptions(codes, backoffSettings);
}

function mergeRetryOptions(retry, overrides) {
    if (!overrides) {
        return null;
    }
    if (!overrides.retryCodes &&
        !overrides.backoffSettings &&
        !overrides.shouldRetryFn &&
        !overrides.getResumptionRequestFn) {
        return retry;
    }
    const retryCodes = overrides.retryCodes
        ? overrides.retryCodes
        : retry.retryCodes;
    const backoffSettings = overrides.backoffSettings
        ? overrides.backoffSettings
        : retry.backoffSettings;
    const shouldRetryFn = overrides.shouldRetryFn
        ? overrides.shouldRetryFn
        : retry.shouldRetryFn;
    const getResumptionRequestFn = overrides.getResumptionRequestFn
        ? overrides.getResumptionRequestFn
        : retry.getResumptionRequestFn;
    return createRetryOptions(retryCodes, backoffSettings, shouldRetryFn, getResumptionRequestFn);
}

function constructSettings(serviceName, clientConfig, configOverrides, retryNames, otherArgs) {
    otherArgs = otherArgs || {};

    const defaults = {};
    const serviceConfig = (clientConfig.interfaces || {})[serviceName];
    if (!serviceConfig) {
        return null;
    }






    const overrides = (configOverrides.interfaces || {})[serviceName] || {};
    const methods = serviceConfig.methods;
    const overridingMethods = overrides.methods || {};
    for (const methodName in methods) {
        const methodConfig = methods[methodName];
        const jsName = (0, util_1.toLowerCamelCase)(methodName);
        let retry = constructRetry(methodConfig, serviceConfig.retry_codes, serviceConfig.retry_params, retryNames);
        let bundlingConfig = methodConfig.bundling;
        let timeout = methodConfig.timeout_millis;
        if (methodName in overridingMethods) {
            const overridingMethod = overridingMethods[methodName];
            if (overridingMethod) {
                if ('bundling' in overridingMethod) {
                    bundlingConfig = overridingMethod.bundling;
                }
                if ('timeout_millis' in overridingMethod) {
                    timeout = overridingMethod.timeout_millis;
                }
            }
            retry = mergeRetryOptions(retry, constructRetry(overridingMethod, overrides.retry_codes, overrides.retry_params, retryNames));
        }
        const apiName = serviceName;
        defaults[jsName] = new CallSettings({
            timeout,
            retry,
            bundleOptions: bundlingConfig
                ? createBundleOptions(bundlingConfig)
                : null,
            otherArgs,
            apiName,
        });
    }
    return defaults;
}
function createByteLengthFunction(message) {
    return function getByteLength(obj) {
        try {
            return message.encode(obj).finish().length;
        }
        catch (err) {
            const stringified = JSON.stringify(obj);
            (0, warnings_1.warn)('error_encoding_protobufjs_object', `Cannot encode protobuf.js object: ${stringified}: ${err}`);


            return stringified.length;
        }
    };
}

