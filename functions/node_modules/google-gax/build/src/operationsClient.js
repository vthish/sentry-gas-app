"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationsClientBuilder = exports.OperationsClient = exports.ALL_SCOPES = exports.SERVICE_ADDRESS = void 0;
const createApiCall_1 = require("./createApiCall");
const descriptor_1 = require("./descriptor");
const gax = require("./gax");
const configData = require("./operations_client_config.json");
const operationProtoJson = require("../protos/operations.json");
const transcoding_1 = require("./transcoding");
exports.SERVICE_ADDRESS = 'longrunning.googleapis.com';
const version = require('../../package.json').version;
const DEFAULT_SERVICE_PORT = 443;
const CODE_GEN_NAME_VERSION = 'gapic/0.7.1';

exports.ALL_SCOPES = [];

class OperationsClient {
    constructor(gaxGrpc, 

    operationsProtos, options) {
        const opts = Object.assign({
            servicePath: exports.SERVICE_ADDRESS,
            port: DEFAULT_SERVICE_PORT,
            clientConfig: {},
        }, options);
        const googleApiClient = ['gl-node/' + process.versions.node];
        if (opts.libName && opts.libVersion) {
            googleApiClient.push(opts.libName + '/' + opts.libVersion);
        }
        googleApiClient.push(CODE_GEN_NAME_VERSION, 'gax/' + version);
        if (opts.fallback) {
            googleApiClient.push('gl-web/' + version);
        }
        else {
            googleApiClient.push('grpc/' + gaxGrpc.grpcVersion);
        }
        const defaults = gaxGrpc.constructSettings('google.longrunning.Operations', configData, opts.clientConfig || {}, { 'x-goog-api-client': googleApiClient.join(' ') });
        this.auth = gaxGrpc.auth;



        this.innerApiCalls = {};
        this.descriptor = {
            listOperations: new descriptor_1.PageDescriptor('pageToken', 'nextPageToken', 'operations'),
        };


        this.operationsStub = gaxGrpc.createStub(opts.fallback
            ? operationsProtos.lookupService('google.longrunning.Operations')
            : operationsProtos.google.longrunning.Operations, opts);
        const operationsStubMethods = [
            'getOperation',
            'listOperations',
            'cancelOperation',
            'deleteOperation',
        ];
        for (const methodName of operationsStubMethods) {
            const innerCallPromise = this.operationsStub.then(stub => (...args) => {
                const func = stub[methodName];
                return func.apply(stub, args);
            }, err => () => {
                throw err;
            });
            this.innerApiCalls[methodName] = (0, createApiCall_1.createApiCall)(innerCallPromise, defaults[methodName], this.descriptor[methodName]);
        }
    }
    
    close() {
        this.operationsStub.then(stub => stub.close());
    }
    getProjectId(callback) {
        if (this.auth && 'getProjectId' in this.auth) {
            return this.auth.getProjectId(callback);
        }
        if (callback) {
            callback(new Error('Cannot determine project ID.'));
        }
        else {
            return Promise.reject('Cannot determine project ID.');
        }
    }

    getOperationInternal(request, options, callback) {
        request = request || {};
        options = options || {};
        return this.innerApiCalls.getOperation(request, options, callback);
    }
    
    getOperation(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        return this.innerApiCalls.getOperation(request, options, callback);
    }
    
    listOperations(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        return this.innerApiCalls.listOperations(request, options, callback);
    }
    
    listOperationsStream(request, options) {
        const callSettings = new gax.CallSettings(options);
        return this.descriptor.listOperations.createStream(this.innerApiCalls.listOperations, request, callSettings);
    }
    
    listOperationsAsync(request, options) {
        request = request || {};
        options = options || {};
        const callSettings = new gax.CallSettings(options);
        return this.descriptor.listOperations.asyncIterate(this.innerApiCalls.listOperations, request, callSettings);
    }
    
    cancelOperation(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        return this.innerApiCalls.cancelOperation(request, options, callback);
    }
    
    deleteOperation(request, optionsOrCallback, callback) {
        let options;
        if (optionsOrCallback instanceof Function && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        request = request || {};
        options = options || {};
        return this.innerApiCalls.deleteOperation(request, options, callback);
    }
}
exports.OperationsClient = OperationsClient;
class OperationsClientBuilder {
    
    constructor(gaxGrpc, protoJson) {
        if (protoJson && gaxGrpc.httpRules) {

            (0, transcoding_1.overrideHttpRules)(gaxGrpc.httpRules, protoJson);
        }
        const operationsProtos = protoJson !== null && protoJson !== void 0 ? protoJson : gaxGrpc.loadProtoJSON(operationProtoJson);
        
        this.operationsClient = opts => {
            if (gaxGrpc.fallback) {
                opts.fallback = gaxGrpc.fallback;
            }
            return new OperationsClient(gaxGrpc, operationsProtos, opts);
        };
        Object.assign(this.operationsClient, OperationsClient);
    }
}
exports.OperationsClientBuilder = OperationsClientBuilder;

