"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamArrayParser = void 0;
const abort_controller_1 = require("abort-controller");
const stream_1 = require("stream");
const fallbackRest_1 = require("./fallbackRest");
const featureDetection_1 = require("./featureDetection");
class StreamArrayParser extends stream_1.Transform {
    
    constructor(rpc, options) {
        super(Object.assign({}, options, { readableObjectMode: true }));
        this._done = false;
        this._prevBlock = Buffer.from('');
        this._isInString = false;
        this._isSkipped = false;
        this._level = 0;
        this.rpc = rpc;
        this.cancelController = (0, featureDetection_1.hasAbortController)()
            ? new AbortController()
            : new abort_controller_1.AbortController();
        this.cancelSignal = this.cancelController.signal;
        this.cancelRequested = false;
    }
    _transform(chunk, _, callback) {
        let objectStart = 0;
        let curIndex = 0;
        if (this._level === 0 && curIndex === 0) {
            if (String.fromCharCode(chunk[0]) !== '[') {
                this.emit('error', new Error(`Internal Error: API service stream data must start with a '[' and close with the corresponding ']', but it start with ${String.fromCharCode(chunk[0])}`));
            }
            curIndex++;
            this._level++;
        }
        while (curIndex < chunk.length) {
            const curValue = String.fromCharCode(chunk[curIndex]);
            if (!this._isSkipped) {
                switch (curValue) {
                    case '{':


                        if (!this._isInString) {
                            this._level++;
                        }
                        if (!this._isInString && this._level === 2) {
                            objectStart = curIndex;
                        }
                        break;
                    case '"':

                        this._isInString = !this._isInString;
                        break;
                    case '}':



                        if (!this._isInString) {
                            this._level--;
                        }
                        if (!this._isInString && this._level === 1) {

                            const objBuff = Buffer.concat([
                                this._prevBlock,
                                chunk.slice(objectStart, curIndex + 1),
                            ]);
                            try {

                                const msgObj = (0, fallbackRest_1.decodeResponse)(this.rpc, true, objBuff);
                                this.push(msgObj);
                            }
                            catch (err) {
                                this.emit('error', err);
                            }
                            objectStart = curIndex + 1;
                            this._prevBlock = Buffer.from('');
                        }
                        break;
                    case ']':
                        if (!this._isInString && this._level === 1) {
                            this._done = true;
                            this.push(null);
                        }
                        break;
                    case '\\':

                        this._isSkipped = true;
                        break;
                    default:
                        break;
                }
            }
            else {
                this._isSkipped = false;
            }
            curIndex++;
        }
        if (this._level > 1) {
            this._prevBlock = Buffer.concat([
                this._prevBlock,
                chunk.slice(objectStart, curIndex),
            ]);
        }
        callback();
    }
    _flush(callback) {
        callback();
    }
    cancel() {
        this._done = true;
        this.cancelRequested = true;
        this.cancelController.abort();
        this.end();
    }
}
exports.StreamArrayParser = StreamArrayParser;

