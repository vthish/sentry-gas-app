"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamProxy = exports.StreamType = void 0;
const gax_1 = require("../gax");
const googleError_1 = require("../googleError");
const status_1 = require("../status");
const stream_1 = require("stream");

const duplexify = require('duplexify');

const retryRequest = require('retry-request');

var StreamType;
(function (StreamType) {
    
    StreamType[StreamType["SERVER_STREAMING"] = 1] = "SERVER_STREAMING";
    
    StreamType[StreamType["CLIENT_STREAMING"] = 2] = "CLIENT_STREAMING";
    
    StreamType[StreamType["BIDI_STREAMING"] = 3] = "BIDI_STREAMING";
})(StreamType || (exports.StreamType = StreamType = {}));



const requestOps = null;
class StreamProxy extends duplexify {
    
    constructor(type, callback, rest, gaxServerStreamingRetries) {
        super(undefined, undefined, {
            objectMode: true,
            readable: type !== StreamType.CLIENT_STREAMING,
            writable: type !== StreamType.SERVER_STREAMING,
        });
        this.type = type;
        this._callback = callback;
        this._isCancelCalled = false;
        this._responseHasSent = false;
        this.rest = rest;
        this.gaxServerStreamingRetries = gaxServerStreamingRetries;
    }
    shouldRetryRequest(error, retry) {
        const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);
        let shouldRetry = this.defaultShouldRetry(e, retry);
        if (retry.shouldRetryFn) {
            shouldRetry = retry.shouldRetryFn(e);
        }
        return shouldRetry;
    }
    cancel() {
        if (this.stream) {
            this.stream.cancel();
        }
        else {
            this._isCancelCalled = true;
        }
    }
    
    throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis, originalError, originalTimeout, retries) {
        const now = new Date();
        const nowTime = now.getTime();
        if (originalTimeout &&
            (totalTimeoutMillis === 0 ||
                totalTimeoutMillis < 0 ||
                (deadline && nowTime >= deadline))) {
            const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${originalTimeout} milliseconds ${originalError ? `retrying error ${originalError} ` : ''} before any response was received.`);
            error.code = status_1.Status.DEADLINE_EXCEEDED;
            throw error;
        }
        if (maxRetries === 0) {
            const error = originalError;
            error.note = 'Max retries is set to zero.';
            throw error;
        }
        if (retries && retries >= maxRetries) {
            const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' +
                (originalError ? `retrying error ${originalError} ` : '') +
                'before any response was received');
            error.code = status_1.Status.DEADLINE_EXCEEDED;
            throw error;
        }
    }
    
    eventForwardHelper(stream) {
        const eventsToForward = ['metadata', 'response', 'status'];
        eventsToForward.forEach(event => {
            stream.on(event, this.emit.bind(this, event));
        });
    }
    
    statusMetadataHelper(stream) {



        stream.on('status', () => {
            if (!this._responseHasSent) {
                stream.emit('response', {
                    code: 200,
                    details: '',
                    message: 'OK',
                });
            }
        });





        stream.on('metadata', metadata => {



            stream.emit('response', {
                code: 200,
                details: '',
                message: 'OK',
                metadata,
            });
            this._responseHasSent = true;
        });
    }
    
    forwardEvents(stream) {
        this.eventForwardHelper(stream);
        this.statusMetadataHelper(stream);
        stream.on('error', error => {
            googleError_1.GoogleError.parseGRPCStatusDetails(error);
        });
    }
    
    defaultShouldRetry(error, retry) {
        if ((retry.retryCodes.length > 0 &&
            retry.retryCodes.indexOf(error.code) < 0) ||
            retry.retryCodes.length === 0) {
            return false;
        }
        return true;
    }
    
    setStream(apiCall, argument, retryRequestOptions = {}, retry) {
        this.apiCall = apiCall;
        this.argument = argument;
        if (this.type === StreamType.SERVER_STREAMING) {
            if (this.rest) {
                const stream = apiCall(argument, this._callback);
                this.stream = stream;
                this.setReadable(stream);
            }
            else if (this.gaxServerStreamingRetries) {
                const request = () => {
                    if (this._isCancelCalled) {
                        if (this.stream) {
                            this.stream.cancel();
                        }
                        return;
                    }
                    const stream = apiCall(argument, this._callback);
                    return stream;
                };
                const retryStream = this.newStreamingRetryRequest({ request, retry });
                this.stream = retryStream;
                this.eventForwardHelper(retryStream);
                this.setReadable(retryStream);
            }
            else {
                const retryStream = retryRequest(null, {
                    objectMode: true,
                    request: () => {
                        if (this._isCancelCalled) {
                            if (this.stream) {
                                this.stream.cancel();
                            }
                            return;
                        }
                        const stream = apiCall(argument, this._callback);
                        this.stream = stream;
                        this.forwardEvents(stream);
                        return stream;
                    },
                    retries: retryRequestOptions.retries,
                    currentRetryAttempt: retryRequestOptions.currentRetryAttempt,
                    noResponseRetries: retryRequestOptions.noResponseRetries,
                    shouldRetryFn: retryRequestOptions.shouldRetryFn,
                });
                this.setReadable(retryStream);
            }
            return;
        }
        const stream = apiCall(argument, this._callback);
        this.stream = stream;
        this.forwardEvents(stream);
        if (this.type === StreamType.CLIENT_STREAMING) {
            this.setWritable(stream);
        }
        if (this.type === StreamType.BIDI_STREAMING) {
            this.setReadable(stream);
            this.setWritable(stream);
        }
        if (this._isCancelCalled && this.stream) {
            this.stream.cancel();
        }
    }
    
    newStreamingRetryRequest(opts) {
        var _a, _b, _c, _d;


        const retry = (_a = opts.retry) !== null && _a !== void 0 ? _a : {
            retryCodes: [],
            backoffSettings: (0, gax_1.createDefaultBackoffSettings)(),
        };
        let retries = 0;
        const retryStream = new stream_1.PassThrough({
            objectMode: true,
        });
        const totalTimeout = (_b = retry.backoffSettings.totalTimeoutMillis) !== null && _b !== void 0 ? _b : undefined;
        const maxRetries = (_c = retry.backoffSettings.maxRetries) !== null && _c !== void 0 ? _c : undefined;
        let timeout = (_d = retry.backoffSettings.initialRpcTimeoutMillis) !== null && _d !== void 0 ? _d : undefined;
        let now = new Date();
        let deadline = 0;
        if (totalTimeout) {
            deadline = now.getTime() + totalTimeout;
        }
        const transientErrorHelper = (error, requestStream) => {
            const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);
            e.note =
                'Exception occurred in retry method that was ' +
                    'not classified as transient';


            requestStream.destroy();
            retryStream.destroy(e);
            return retryStream;
        };
        const newMakeRequest = (newopts) => {
            let dataEnd = false;
            let statusReceived = false;
            let enteredError = false;

            const requestStream = newopts.request(requestOps);
            retryStream.cancel = requestStream.cancel; // make sure the retryStream is also cancellable by the user
            const eventsToForward = ['metadata', 'response', 'status'];
            eventsToForward.forEach(event => {
                requestStream.on(event, retryStream.emit.bind(retryStream, event));
            });
            this.statusMetadataHelper(requestStream);

            requestStream.on('data', (data) => {
                retries = 0;
                this.emit.bind(this, 'data')(data);
            });
            
            requestStream.on('status', () => {
                statusReceived = true;
                if (dataEnd) {
                    retryStream.end();
                }
                return retryStream;
            });
            requestStream.on('end', () => {
                if (!enteredError) {
                    dataEnd = true;


                    if (statusReceived) {
                        retryStream.end();
                    }
                }
                return retryStream;




            });
            requestStream.on('error', (error) => {
                enteredError = true;

                if (typeof maxRetries !== undefined ||
                    typeof totalTimeout !== undefined) {
                    if (this.shouldRetryRequest(error, retry)) {
                        if (maxRetries && totalTimeout) {
                            const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +
                                'in backoffSettings.');
                            newError.code = status_1.Status.INVALID_ARGUMENT;


                            requestStream.destroy();
                            retryStream.destroy(newError);
                            return retryStream;
                        }
                        else {

                            try {
                                this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, timeout, error, totalTimeout, retries);
                            }
                            catch (error) {
                                const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);


                                requestStream.destroy();
                                retryStream.destroy(e);
                                return retryStream;
                            }
                            const delayMult = retry.backoffSettings.retryDelayMultiplier;
                            const maxDelay = retry.backoffSettings.maxRetryDelayMillis;
                            const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;
                            const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;
                            let delay = retry.backoffSettings.initialRetryDelayMillis;

                            const toSleep = Math.random() * delay;
                            const calculateTimeoutAndResumptionFunction = () => {
                                setTimeout(() => {

                                    if (timeout) {
                                        now = new Date();
                                        delay = Math.min(delay * delayMult, maxDelay);
                                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;
                                        const rpcTimeout = maxTimeout ? maxTimeout : 0;
                                        const newDeadline = deadline ? deadline - now.getTime() : 0;
                                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);
                                    }
                                    retries++;
                                    let retryArgument = this.argument;



                                    if (retry.getResumptionRequestFn !== undefined) {
                                        retryArgument = retry.getResumptionRequestFn(retryArgument);
                                    }
                                    const newRequest = () => {
                                        if (this._isCancelCalled) {
                                            if (this.stream) {
                                                this.stream.cancel();
                                            }
                                            return;
                                        }
                                        const newStream = this.apiCall(retryArgument, this._callback);
                                        return newStream;
                                    };
                                    opts.request = newRequest;


                                    return newMakeRequest(opts);
                                }, toSleep);
                            };
                            return calculateTimeoutAndResumptionFunction();
                        }
                    }
                    else {

                        return transientErrorHelper(error, requestStream);
                    }
                }
                else {

                    return transientErrorHelper(error, requestStream);
                }
            });


            return retryStream;
        };

        return newMakeRequest(opts);
    }
}
exports.StreamProxy = StreamProxy;

