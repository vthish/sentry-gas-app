"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleErrorDecoder = exports.GoogleError = void 0;
const status_1 = require("./status");
const protobuf = require("protobufjs");
const serializer = require("proto3-json-serializer");
const fallback_1 = require("./fallback");
class GoogleError extends Error {


    static parseGRPCStatusDetails(err) {
        const decoder = new GoogleErrorDecoder();
        try {
            if (err.metadata && err.metadata.get('grpc-status-details-bin')) {
                const statusDetailsObj = decoder.decodeGRPCStatusDetails(err.metadata.get('grpc-status-details-bin'));
                if (statusDetailsObj &&
                    statusDetailsObj.details &&
                    statusDetailsObj.details.length > 0) {
                    err.statusDetails = statusDetailsObj.details;
                }
                if (statusDetailsObj && statusDetailsObj.errorInfo) {
                    err.reason = statusDetailsObj.errorInfo.reason;
                    err.domain = statusDetailsObj.errorInfo.domain;
                    err.errorInfoMetadata = statusDetailsObj.errorInfo.metadata;
                }
            }
        }
        catch (decodeErr) {

        }
        return err;
    }


    static parseHttpError(json) {
        if (Array.isArray(json)) {

            json = json.find((obj) => {
                return 'error' in obj;
            });
        }




        if (!json['error']) {
            json['error'] = {};
            Object.keys(json)
                .filter(key => key !== 'error')
                .forEach(key => {
                json['error'][key] = json[key];
                delete json[key];
            });
        }
        const decoder = new GoogleErrorDecoder();
        const proto3Error = decoder.decodeHTTPError(json['error']);
        const error = Object.assign(new GoogleError(json['error']['message']), proto3Error);

        if (json['error']['code']) {
            error.code = (0, status_1.rpcCodeFromHttpStatusCode)(json['error']['code']);
        }
        else {


            delete error.code;
        }


        if (error.details) {
            try {
                const statusDetailsObj = decoder.decodeHttpStatusDetails(error.details);
                if (statusDetailsObj &&
                    statusDetailsObj.details &&
                    statusDetailsObj.details.length > 0) {
                    error.statusDetails = statusDetailsObj.details;
                }
                if (statusDetailsObj && statusDetailsObj.errorInfo) {
                    error.reason = statusDetailsObj.errorInfo.reason;
                    error.domain = statusDetailsObj.errorInfo.domain;



                    error.errorInfoMetadata = statusDetailsObj.errorInfo.metadata;
                }
            }
            catch (decodeErr) {

            }
        }
        return error;
    }
}
exports.GoogleError = GoogleError;
class GoogleErrorDecoder {
    constructor() {

        const errorProtoJson = require('../../build/protos/status.json');
        this.root = protobuf.Root.fromJSON(errorProtoJson);
        this.anyType = this.root.lookupType('google.protobuf.Any');
        this.statusType = this.root.lookupType('google.rpc.Status');
    }
    decodeProtobufAny(anyValue) {
        const match = anyValue.type_url.match(/^type.googleapis.com\/(.*)/);
        if (!match) {
            throw new Error(`Unknown type encoded in google.protobuf.any: ${anyValue.type_url}`);
        }
        const typeName = match[1];
        const type = this.root.lookupType(typeName);
        if (!type) {
            throw new Error(`Cannot lookup type ${typeName}`);
        }
        return type.decode(anyValue.value);
    }

    decodeRpcStatus(buffer) {
        const uint8array = new Uint8Array(buffer);
        const status = this.statusType.decode(uint8array);


        const details = [];
        let errorInfo;
        for (const detail of status.details) {
            try {
                const decodedDetail = this.decodeProtobufAny(detail);
                details.push(decodedDetail);
                if (detail.type_url === 'type.googleapis.com/google.rpc.ErrorInfo') {
                    errorInfo = decodedDetail;
                }
            }
            catch (err) {

            }
        }
        const result = {
            code: status.code,
            message: status.message,
            statusDetails: details,
            reason: errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.reason,
            domain: errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.domain,
            errorInfoMetadata: errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.metadata,
        };
        return result;
    }


    callErrorFromStatus(status) {
        status.message = `${status.code} ${status_1.Status[status.code]}: ${status.message}`;
        return Object.assign(new GoogleError(status.message), status);
    }


    decodeErrorFromBuffer(buffer) {
        return this.callErrorFromStatus(this.decodeRpcStatus(buffer));
    }

    decodeGRPCStatusDetails(bufferArr) {
        const details = [];
        let errorInfo;
        bufferArr.forEach(buffer => {
            const uint8array = new Uint8Array(buffer);
            const rpcStatus = this.statusType.decode(uint8array);
            for (const detail of rpcStatus.details) {
                try {
                    const decodedDetail = this.decodeProtobufAny(detail);
                    details.push(decodedDetail);
                    if (detail.type_url === 'type.googleapis.com/google.rpc.ErrorInfo') {
                        errorInfo = decodedDetail;
                    }
                }
                catch (err) {

                }
            }
        });
        const result = {
            details,
            errorInfo,
        };
        return result;
    }

    decodeHTTPError(json) {
        const errorMessage = serializer.fromProto3JSON(this.statusType, json);
        if (!errorMessage) {
            throw new Error(`Received error message ${json}, but failed to serialize as proto3 message`);
        }
        return this.statusType.toObject(errorMessage, fallback_1.defaultToObjectOptions);
    }

    decodeHttpStatusDetails(rawDetails) {

        const details = [];
        let errorInfo;
        for (const detail of rawDetails) {
            try {
                const decodedDetail = this.decodeProtobufAny(detail);
                details.push(decodedDetail);
                if (detail.type_url === 'type.googleapis.com/google.rpc.ErrorInfo') {
                    errorInfo = decodedDetail;
                }
            }
            catch (err) {

            }
        }
        return { details, errorInfo };
    }
}
exports.GoogleErrorDecoder = GoogleErrorDecoder;

