"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PageDescriptor = void 0;
const stream_1 = require("stream");
const normalApiCaller_1 = require("../normalCalls/normalApiCaller");
const warnings_1 = require(".././warnings");
const pagedApiCaller_1 = require("./pagedApiCaller");
const maxAttemptsEmptyResponse = 10;

class PageDescriptor {
    constructor(requestPageTokenField, responsePageTokenField, resourceField) {
        this.requestPageTokenField = requestPageTokenField;
        this.responsePageTokenField = responsePageTokenField;
        this.resourceField = resourceField;
    }
    
    createStream(apiCall, request, options) {
        if (options === null || options === void 0 ? void 0 : options.autoPaginate) {
            (0, warnings_1.warn)('autoPaginate true', 'Autopaginate will always be set to false in stream paging methods. See more info at https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination for more information on how to configure paging calls', 'AutopaginateTrueWarning');
        }
        const stream = new stream_1.PassThrough({ objectMode: true });
        options = Object.assign({}, options, { autoPaginate: false });
        const maxResults = 'maxResults' in options ? options.maxResults : -1;
        let pushCount = 0;
        let started = false;
        function callback(err, resources, next, apiResp) {
            if (err) {
                stream.emit('error', err);
                return;
            }

            stream.emit('response', apiResp);
            for (let i = 0; i < resources.length; ++i) {

                if (stream
                    ._readableState.ended) {
                    return;
                }
                if (resources[i] === null) {
                    continue;
                }
                stream.push(resources[i]);
                pushCount++;
                if (pushCount === maxResults) {
                    stream.end();
                }
            }

            if (stream._readableState
                .ended) {
                return;
            }
            if (!next) {
                stream.end();
                return;
            }


            if ('pageToken' in options) {
                delete options.pageToken;
            }
            if (stream.isPaused()) {
                request = next;
                started = false;
            }
            else {
                setImmediate(apiCall, next, options, callback);
            }
        }
        stream.on('resume', () => {
            if (!started) {
                started = true;
                apiCall(request, options, callback);
            }
        });
        return stream;
    }
    
    asyncIterate(apiCall, request, options) {
        if (options === null || options === void 0 ? void 0 : options.autoPaginate) {
            (0, warnings_1.warn)('autoPaginate true', 'Autopaginate will always be set to false in Async paging methods. See more info at https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#auto-pagination for more information on how to configure paging calls', 'AutopaginateTrueWarning');
        }
        options = Object.assign({}, options, { autoPaginate: false });
        const iterable = this.createIterator(apiCall, request, options);
        return iterable;
    }
    createIterator(apiCall, request, options) {
        const asyncIterable = {
            [Symbol.asyncIterator]() {
                let nextPageRequest = request;
                const cache = [];
                return {
                    async next() {
                        if (cache.length > 0) {
                            return Promise.resolve({
                                done: false,
                                value: cache.shift(),
                            });
                        }
                        let attempts = 0;
                        while (cache.length === 0 && nextPageRequest) {
                            let result;
                            [result, nextPageRequest] = (await apiCall(nextPageRequest, options));

                            if (result && !Array.isArray(result)) {
                                for (const [key, value] of Object.entries(result)) {
                                    cache.push([key, value]);
                                }
                            }
                            else {
                                cache.push(...result);
                            }
                            if (cache.length === 0) {
                                ++attempts;
                                if (attempts > maxAttemptsEmptyResponse) {
                                    break;
                                }
                            }
                        }
                        if (cache.length === 0) {
                            return Promise.resolve({ done: true, value: undefined });
                        }
                        return Promise.resolve({ done: false, value: cache.shift() });
                    },
                };
            },
        };
        return asyncIterable;
    }
    getApiCaller(settings) {
        if (!settings.autoPaginate) {
            return new normalApiCaller_1.NormalApiCaller();
        }
        return new pagedApiCaller_1.PagedApiCaller(this);
    }
}
exports.PageDescriptor = PageDescriptor;

