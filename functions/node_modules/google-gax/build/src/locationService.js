"use strict";













Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationsClient = void 0;

const gax = require("./gax");
const warnings_1 = require("./warnings");
const createApiCall_1 = require("./createApiCall");
const routingHeader = require("./routingHeader");
const pageDescriptor_1 = require("./paginationCalls/pageDescriptor");
const jsonProtos = require("../protos/locations.json");

const gapicConfig = require("./locations_client_config.json");
const version = require('../../package.json').version;

class LocationsClient {
    
    constructor(gaxGrpc, 

    opts) {
        var _a, _b;
        this._terminated = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {},
        };

        this.gaxGrpc = gaxGrpc;
        const staticMembers = this.constructor;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || staticMembers.servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_a = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _a !== void 0 ? _a : {};
        const fallback = (_b = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _b !== void 0 ? _b : (typeof window !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function');
        opts = Object.assign({ servicePath, port, clientConfig, fallback }, opts);

        if (servicePath !== staticMembers.servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }

        this._opts = opts;

        this.auth = gaxGrpc.auth;

        if (servicePath === staticMembers.servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }

        const clientHeader = [`gax/${version}`, `gapic/${version}`];
        if (typeof process !== 'undefined' && 'versions' in process) {
            clientHeader.push(`gl-node/${process.versions.node}`);
        }
        else {
            clientHeader.push(`gl-web/${version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${gaxGrpc.grpcVersion}`);
        }
        else if (opts.fallback === 'rest') {
            clientHeader.push(`rest/${gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }

        this._protos = gaxGrpc.loadProtoJSON(jsonProtos);



        this.descriptors.page = {
            listLocations: new pageDescriptor_1.PageDescriptor('pageToken', 'nextPageToken', 'locations'),
        };

        this._defaults = gaxGrpc.constructSettings('google.cloud.location.Locations', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });



        this.innerApiCalls = {};

        this.warn = warnings_1.warn;
    }
    
    initialize() {

        if (this.locationsStub) {
            return this.locationsStub;
        }


        this.locationsStub = this.gaxGrpc.createStub(this._opts.fallback
            ? this._protos.lookupService('google.cloud.location.Locations')
            : // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this._protos.google.cloud.location.Locations, this._opts, this._providedCustomServicePath);


        const locationsStubMethods = ['listLocations', 'getLocation'];
        for (const methodName of locationsStubMethods) {
            const callPromise = this.locationsStub.then(stub => (...args) => {
                if (this._terminated) {
                    return Promise.reject('The client has already been closed.');
                }
                const func = stub[methodName];
                return func.apply(stub, args);
            }, (err) => () => {
                throw err;
            });
            const descriptor = this.descriptors.page[methodName] || undefined;
            const apiCall = (0, createApiCall_1.createApiCall)(callPromise, this._defaults[methodName], descriptor);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.locationsStub;
    }
    
    static get servicePath() {
        return 'cloud.googleapis.com';
    }
    
    static get apiEndpoint() {
        return 'cloud.googleapis.com';
    }
    
    static get port() {
        return 443;
    }
    
    static get scopes() {
        return ['https://www.googleapis.com/auth/cloud-platform'];
    }
    getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    
    getLocation(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] =
            routingHeader.fromParams({
                name: request.name || '',
            });
        this.initialize();
        return this.innerApiCalls.getLocation(request, options, callback);
    }
    
    listLocations(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        }
        else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] =
            routingHeader.fromParams({
                name: request.name || '',
            });
        this.initialize();
        return this.innerApiCalls.listLocations(request, options, callback);
    }
    
    listLocationsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] =
            routingHeader.fromParams({
                name: request.name || '',
            });
        options = options || {};
        const callSettings = new gax.CallSettings(options);
        this.initialize();
        return this.descriptors.page.listLocations.asyncIterate(this.innerApiCalls['listLocations'], request, callSettings);
    }
    
    close() {
        this.initialize();
        if (!this._terminated) {
            return this.locationsStub.then(stub => {
                this._terminated = true;
                stub.close();
            });
        }
        return Promise.resolve();
    }
}
exports.LocationsClient = LocationsClient;

