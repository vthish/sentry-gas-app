












import { Service } from './nodejs-common/index.js';
import { paginator } from '@google-cloud/paginator';
import { promisifyAll } from '@google-cloud/promisify';
import { Readable } from 'stream';
import { Bucket } from './bucket.js';
import { Channel } from './channel.js';
import { File } from './file.js';
import { normalize } from './util.js';


import { getPackageJSON } from './package-json-helper.cjs';
import { HmacKey } from './hmacKey.js';
import { CRC32C_DEFAULT_VALIDATOR_GENERATOR, } from './crc32c.js';
import { DEFAULT_UNIVERSE } from 'google-auth-library';
export var IdempotencyStrategy;
(function (IdempotencyStrategy) {
    IdempotencyStrategy[IdempotencyStrategy["RetryAlways"] = 0] = "RetryAlways";
    IdempotencyStrategy[IdempotencyStrategy["RetryConditional"] = 1] = "RetryConditional";
    IdempotencyStrategy[IdempotencyStrategy["RetryNever"] = 2] = "RetryNever";
})(IdempotencyStrategy || (IdempotencyStrategy = {}));
export var ExceptionMessages;
(function (ExceptionMessages) {
    ExceptionMessages["EXPIRATION_DATE_INVALID"] = "The expiration date provided was invalid.";
    ExceptionMessages["EXPIRATION_DATE_PAST"] = "An expiration date cannot be in the past.";
})(ExceptionMessages || (ExceptionMessages = {}));
export var StorageExceptionMessages;
(function (StorageExceptionMessages) {
    StorageExceptionMessages["BUCKET_NAME_REQUIRED"] = "A bucket name is needed to use Cloud Storage.";
    StorageExceptionMessages["BUCKET_NAME_REQUIRED_CREATE"] = "A name is required to create a bucket.";
    StorageExceptionMessages["HMAC_SERVICE_ACCOUNT"] = "The first argument must be a service account email to create an HMAC key.";
    StorageExceptionMessages["HMAC_ACCESS_ID"] = "An access ID is needed to create an HmacKey object.";
})(StorageExceptionMessages || (StorageExceptionMessages = {}));
export const PROTOCOL_REGEX = /^(\w*):\/\//;

export const AUTO_RETRY_DEFAULT = true;

export const MAX_RETRY_DEFAULT = 3;

export const RETRY_DELAY_MULTIPLIER_DEFAULT = 2;

export const TOTAL_TIMEOUT_DEFAULT = 600;

export const MAX_RETRY_DELAY_DEFAULT = 64;

const IDEMPOTENCY_STRATEGY_DEFAULT = IdempotencyStrategy.RetryConditional;

export const RETRYABLE_ERR_FN_DEFAULT = function (err) {
    var _a;
    const isConnectionProblem = (reason) => {
        return (reason.includes('eai_again') || // DNS lookup error
            reason === 'econnreset' ||
            reason === 'unexpected connection closure' ||
            reason === 'epipe' ||
            reason === 'socket connection timeout');
    };
    if (err) {
        if ([408, 429, 500, 502, 503, 504].indexOf(err.code) !== -1) {
            return true;
        }
        if (typeof err.code === 'string') {
            if (['408', '429', '500', '502', '503', '504'].indexOf(err.code) !== -1) {
                return true;
            }
            const reason = err.code.toLowerCase();
            if (isConnectionProblem(reason)) {
                return true;
            }
        }
        if (err.errors) {
            for (const e of err.errors) {
                const reason = (_a = e === null || e === void 0 ? void 0 : e.reason) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase();
                if (reason && isConnectionProblem(reason)) {
                    return true;
                }
            }
        }
    }
    return false;
};





export class Storage extends Service {
    getBucketsStream() {

        return new Readable();
    }
    getHmacKeysStream() {

        return new Readable();
    }
    
    
    
    
    
    
    
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const universe = options.universeDomain || DEFAULT_UNIVERSE;
        let apiEndpoint = `https://storage.${universe}`;
        let customEndpoint = false;

        const EMULATOR_HOST = process.env.STORAGE_EMULATOR_HOST;
        if (typeof EMULATOR_HOST === 'string') {
            apiEndpoint = Storage.sanitizeEndpoint(EMULATOR_HOST);
            customEndpoint = true;
        }
        if (options.apiEndpoint && options.apiEndpoint !== apiEndpoint) {
            apiEndpoint = Storage.sanitizeEndpoint(options.apiEndpoint);
            customEndpoint = true;
        }
        options = Object.assign({}, options, { apiEndpoint });

        const baseUrl = EMULATOR_HOST || `${options.apiEndpoint}/storage/v1`;
        const config = {
            apiEndpoint: options.apiEndpoint,
            retryOptions: {
                autoRetry: ((_a = options.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined
                    ? (_b = options.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry
                    : AUTO_RETRY_DEFAULT,
                maxRetries: ((_c = options.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetries)
                    ? (_d = options.retryOptions) === null || _d === void 0 ? void 0 : _d.maxRetries
                    : MAX_RETRY_DEFAULT,
                retryDelayMultiplier: ((_e = options.retryOptions) === null || _e === void 0 ? void 0 : _e.retryDelayMultiplier)
                    ? (_f = options.retryOptions) === null || _f === void 0 ? void 0 : _f.retryDelayMultiplier
                    : RETRY_DELAY_MULTIPLIER_DEFAULT,
                totalTimeout: ((_g = options.retryOptions) === null || _g === void 0 ? void 0 : _g.totalTimeout)
                    ? (_h = options.retryOptions) === null || _h === void 0 ? void 0 : _h.totalTimeout
                    : TOTAL_TIMEOUT_DEFAULT,
                maxRetryDelay: ((_j = options.retryOptions) === null || _j === void 0 ? void 0 : _j.maxRetryDelay)
                    ? (_k = options.retryOptions) === null || _k === void 0 ? void 0 : _k.maxRetryDelay
                    : MAX_RETRY_DELAY_DEFAULT,
                retryableErrorFn: ((_l = options.retryOptions) === null || _l === void 0 ? void 0 : _l.retryableErrorFn)
                    ? (_m = options.retryOptions) === null || _m === void 0 ? void 0 : _m.retryableErrorFn
                    : RETRYABLE_ERR_FN_DEFAULT,
                idempotencyStrategy: ((_o = options.retryOptions) === null || _o === void 0 ? void 0 : _o.idempotencyStrategy) !== undefined
                    ? (_p = options.retryOptions) === null || _p === void 0 ? void 0 : _p.idempotencyStrategy
                    : IDEMPOTENCY_STRATEGY_DEFAULT,
            },
            baseUrl,
            customEndpoint,
            useAuthWithCustomEndpoint: options === null || options === void 0 ? void 0 : options.useAuthWithCustomEndpoint,
            projectIdRequired: false,
            scopes: [
                'https://www.googleapis.com/auth/iam',
                'https://www.googleapis.com/auth/cloud-platform',
                'https://www.googleapis.com/auth/devstorage.full_control',
            ],
            packageJson: getPackageJSON(),
        };
        super(config, options);
        
        this.acl = Storage.acl;
        this.crc32cGenerator =
            options.crc32cGenerator || CRC32C_DEFAULT_VALIDATOR_GENERATOR;
        this.retryOptions = config.retryOptions;
        this.getBucketsStream = paginator.streamify('getBuckets');
        this.getHmacKeysStream = paginator.streamify('getHmacKeys');
    }
    static sanitizeEndpoint(url) {
        if (!PROTOCOL_REGEX.test(url)) {
            url = `https://${url}`;
        }
        return url.replace(/\/+$/, ''); // Remove trailing slashes
    }
    
    bucket(name, options) {
        if (!name) {
            throw new Error(StorageExceptionMessages.BUCKET_NAME_REQUIRED);
        }
        return new Bucket(this, name, options);
    }
    
    channel(id, resourceId) {
        return new Channel(this, id, resourceId);
    }
    
    
    
    
    createBucket(name, metadataOrCallback, callback) {
        if (!name) {
            throw new Error(StorageExceptionMessages.BUCKET_NAME_REQUIRED_CREATE);
        }
        let metadata;
        if (!callback) {
            callback = metadataOrCallback;
            metadata = {};
        }
        else {
            metadata = metadataOrCallback;
        }
        const body = {
            ...metadata,
            name,
        };
        const storageClasses = {
            archive: 'ARCHIVE',
            coldline: 'COLDLINE',
            dra: 'DURABLE_REDUCED_AVAILABILITY',
            multiRegional: 'MULTI_REGIONAL',
            nearline: 'NEARLINE',
            regional: 'REGIONAL',
            standard: 'STANDARD',
        };
        const storageClassKeys = Object.keys(storageClasses);
        for (const storageClass of storageClassKeys) {
            if (body[storageClass]) {
                if (metadata.storageClass && metadata.storageClass !== storageClass) {
                    throw new Error(`Both \`${storageClass}\` and \`storageClass\` were provided.`);
                }
                body.storageClass = storageClasses[storageClass];
                delete body[storageClass];
            }
        }
        if (body.requesterPays) {
            body.billing = {
                requesterPays: body.requesterPays,
            };
            delete body.requesterPays;
        }
        const query = {
            project: this.projectId,
        };
        if (body.userProject) {
            query.userProject = body.userProject;
            delete body.userProject;
        }
        if (body.enableObjectRetention) {
            query.enableObjectRetention = body.enableObjectRetention;
            delete body.enableObjectRetention;
        }
        if (body.predefinedAcl) {
            query.predefinedAcl = body.predefinedAcl;
            delete body.predefinedAcl;
        }
        if (body.predefinedDefaultObjectAcl) {
            query.predefinedDefaultObjectAcl = body.predefinedDefaultObjectAcl;
            delete body.predefinedDefaultObjectAcl;
        }
        if (body.projection) {
            query.projection = body.projection;
            delete body.projection;
        }
        this.request({
            method: 'POST',
            uri: '/b',
            qs: query,
            json: body,
        }, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
            }
            const bucket = this.bucket(name);
            bucket.metadata = resp;
            callback(null, bucket, resp);
        });
    }
    
    
    
    
    
    createHmacKey(serviceAccountEmail, optionsOrCb, cb) {
        if (typeof serviceAccountEmail !== 'string') {
            throw new Error(StorageExceptionMessages.HMAC_SERVICE_ACCOUNT);
        }
        const { options, callback } = normalize(optionsOrCb, cb);
        const query = Object.assign({}, options, { serviceAccountEmail });
        const projectId = query.projectId || this.projectId;
        delete query.projectId;
        this.request({
            method: 'POST',
            uri: `/projects/${projectId}/hmacKeys`,
            qs: query,
            maxRetries: 0, //explicitly set this value since this is a non-idempotent function
        }, (err, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const metadata = resp.metadata;
            const hmacKey = this.hmacKey(metadata.accessId, {
                projectId: metadata.projectId,
            });
            hmacKey.metadata = resp.metadata;
            callback(null, hmacKey, resp.secret, resp);
        });
    }
    
    
    
    
    getBuckets(optionsOrCallback, cb) {
        const { options, callback } = normalize(optionsOrCallback, cb);
        options.project = options.project || this.projectId;
        this.request({
            uri: '/b',
            qs: options,
        }, (err, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const itemsArray = resp.items ? resp.items : [];
            const buckets = itemsArray.map((bucket) => {
                const bucketInstance = this.bucket(bucket.id);
                bucketInstance.metadata = bucket;
                return bucketInstance;
            });
            const nextQuery = resp.nextPageToken
                ? Object.assign({}, options, { pageToken: resp.nextPageToken })
                : null;
            callback(null, buckets, nextQuery, resp);
        });
    }
    getHmacKeys(optionsOrCb, cb) {
        const { options, callback } = normalize(optionsOrCb, cb);
        const query = Object.assign({}, options);
        const projectId = query.projectId || this.projectId;
        delete query.projectId;
        this.request({
            uri: `/projects/${projectId}/hmacKeys`,
            qs: query,
        }, (err, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const itemsArray = resp.items ? resp.items : [];
            const hmacKeys = itemsArray.map((hmacKey) => {
                const hmacKeyInstance = this.hmacKey(hmacKey.accessId, {
                    projectId: hmacKey.projectId,
                });
                hmacKeyInstance.metadata = hmacKey;
                return hmacKeyInstance;
            });
            const nextQuery = resp.nextPageToken
                ? Object.assign({}, options, { pageToken: resp.nextPageToken })
                : null;
            callback(null, hmacKeys, nextQuery, resp);
        });
    }
    
    
    
    getServiceAccount(optionsOrCallback, cb) {
        const { options, callback } = normalize(optionsOrCallback, cb);
        this.request({
            uri: `/projects/${this.projectId}/serviceAccount`,
            qs: options,
        }, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
            }
            const camelCaseResponse = {};
            for (const prop in resp) {

                if (resp.hasOwnProperty(prop)) {
                    const camelCaseProp = prop.replace(/_(\w)/g, (_, match) => match.toUpperCase());
                    camelCaseResponse[camelCaseProp] = resp[prop];
                }
            }
            callback(null, camelCaseResponse, resp);
        });
    }
    
    hmacKey(accessId, options) {
        if (!accessId) {
            throw new Error(StorageExceptionMessages.HMAC_ACCESS_ID);
        }
        return new HmacKey(this, accessId, options);
    }
}

Storage.Bucket = Bucket;

Storage.Channel = Channel;

Storage.File = File;

Storage.HmacKey = HmacKey;
Storage.acl = {
    OWNER_ROLE: 'OWNER',
    READER_ROLE: 'READER',
    WRITER_ROLE: 'WRITER',
};

paginator.extend(Storage, ['getBuckets', 'getHmacKeys']);

promisifyAll(Storage, {
    exclude: ['bucket', 'channel', 'hmacKey'],
});

