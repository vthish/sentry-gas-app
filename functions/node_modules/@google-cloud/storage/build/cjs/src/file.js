"use strict";













var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _File_instances, _File_validateIntegrity;
Object.defineProperty(exports, "__esModule", { value: true });
exports.File = exports.FileExceptionMessages = exports.RequestError = exports.STORAGE_POST_POLICY_BASE_URL = exports.ActionToHTTPMethod = void 0;
const index_js_1 = require("./nodejs-common/index.js");
const promisify_1 = require("@google-cloud/promisify");
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs"));
const mime_1 = __importDefault(require("mime"));
const resumableUpload = __importStar(require("./resumable-upload.js"));
const stream_1 = require("stream");
const zlib = __importStar(require("zlib"));
const storage_js_1 = require("./storage.js");
const bucket_js_1 = require("./bucket.js");
const acl_js_1 = require("./acl.js");
const signer_js_1 = require("./signer.js");
const util_js_1 = require("./nodejs-common/util.js");
const duplexify_1 = __importDefault(require("duplexify"));
const util_js_2 = require("./util.js");
const crc32c_js_1 = require("./crc32c.js");
const hash_stream_validator_js_1 = require("./hash-stream-validator.js");
const async_retry_1 = __importDefault(require("async-retry"));
var ActionToHTTPMethod;
(function (ActionToHTTPMethod) {
    ActionToHTTPMethod["read"] = "GET";
    ActionToHTTPMethod["write"] = "PUT";
    ActionToHTTPMethod["delete"] = "DELETE";
    ActionToHTTPMethod["resumable"] = "POST";
})(ActionToHTTPMethod || (exports.ActionToHTTPMethod = ActionToHTTPMethod = {}));

exports.STORAGE_POST_POLICY_BASE_URL = 'https://storage.googleapis.com';

const GS_URL_REGEXP = /^gs:\/\/([a-z0-9_.-]+)\/(.+)$/;

const COMPRESSIBLE_MIME_REGEX = new RegExp([
    /^text\/|application\/ecmascript|application\/javascript|application\/json/,
    /|application\/postscript|application\/rtf|application\/toml|application\/vnd.dart/,
    /|application\/vnd.ms-fontobject|application\/wasm|application\/x-httpd-php|application\/x-ns-proxy-autoconfig/,
    /|application\/x-sh(?!ockwave-flash)|application\/x-tar|application\/x-virtualbox-hdd|application\/x-virtualbox-ova|application\/x-virtualbox-ovf/,
    /|^application\/x-virtualbox-vbox$|application\/x-virtualbox-vdi|application\/x-virtualbox-vhd|application\/x-virtualbox-vmdk/,
    /|application\/xml|application\/xml-dtd|font\/otf|font\/ttf|image\/bmp|image\/vnd.adobe.photoshop|image\/vnd.microsoft.icon/,
    /|image\/vnd.ms-dds|image\/x-icon|image\/x-ms-bmp|message\/rfc822|model\/gltf-binary|\+json|\+text|\+xml|\+yaml/,
]
    .map(r => r.source)
    .join(''), 'i');
class RequestError extends Error {
}
exports.RequestError = RequestError;
const SEVEN_DAYS = 7 * 24 * 60 * 60;
const GS_UTIL_URL_REGEX = /(gs):\/\/([a-z0-9_.-]+)\/(.+)/g;
const HTTPS_PUBLIC_URL_REGEX = /(https):\/\/(storage\.googleapis\.com)\/([a-z0-9_.-]+)\/(.+)/g;
var FileExceptionMessages;
(function (FileExceptionMessages) {
    FileExceptionMessages["EXPIRATION_TIME_NA"] = "An expiration time is not available.";
    FileExceptionMessages["DESTINATION_NO_NAME"] = "Destination file should have a name.";
    FileExceptionMessages["INVALID_VALIDATION_FILE_RANGE"] = "Cannot use validation with file ranges (start/end).";
    FileExceptionMessages["MD5_NOT_AVAILABLE"] = "MD5 verification was specified, but is not available for the requested object. MD5 is not available for composite objects.";
    FileExceptionMessages["EQUALS_CONDITION_TWO_ELEMENTS"] = "Equals condition must be an array of 2 elements.";
    FileExceptionMessages["STARTS_WITH_TWO_ELEMENTS"] = "StartsWith condition must be an array of 2 elements.";
    FileExceptionMessages["CONTENT_LENGTH_RANGE_MIN_MAX"] = "ContentLengthRange must have numeric min & max fields.";
    FileExceptionMessages["DOWNLOAD_MISMATCH"] = "The downloaded data did not match the data from the server. To be sure the content is the same, you should download the file again.";
    FileExceptionMessages["UPLOAD_MISMATCH_DELETE_FAIL"] = "The uploaded data did not match the data from the server.\n    As a precaution, we attempted to delete the file, but it was not successful.\n    To be sure the content is the same, you should try removing the file manually,\n    then uploading the file again.\n    \n\nThe delete attempt failed with this message:\n\n  ";
    FileExceptionMessages["UPLOAD_MISMATCH"] = "The uploaded data did not match the data from the server.\n    As a precaution, the file has been deleted.\n    To be sure the content is the same, you should try uploading the file again.";
    FileExceptionMessages["MD5_RESUMED_UPLOAD"] = "MD5 cannot be used with a continued resumable upload as MD5 cannot be extended from an existing value";
    FileExceptionMessages["MISSING_RESUME_CRC32C_FINAL_UPLOAD"] = "The CRC32C is missing for the final portion of a resumed upload, which is required for validation. Please provide `resumeCRC32C` if validation is required, or disable `validation`.";
})(FileExceptionMessages || (exports.FileExceptionMessages = FileExceptionMessages = {}));

class File extends index_js_1.ServiceObject {
    
    
    
    
    
    
    
    
    
    
    constructor(bucket, name, options = {}) {
        var _a, _b;
        const requestQueryObject = {};
        let generation;
        if (options.generation !== null) {
            if (typeof options.generation === 'string') {
                generation = Number(options.generation);
            }
            else {
                generation = options.generation;
            }
            if (!isNaN(generation)) {
                requestQueryObject.generation = generation;
            }
        }
        Object.assign(requestQueryObject, options.preconditionOpts);
        const userProject = options.userProject || bucket.userProject;
        if (typeof userProject === 'string') {
            requestQueryObject.userProject = userProject;
        }
        const methods = {
            
            
            
            delete: {
                reqOpts: {
                    qs: requestQueryObject,
                },
            },
            
            
            
            exists: {
                reqOpts: {
                    qs: requestQueryObject,
                },
            },
            
            
            
            get: {
                reqOpts: {
                    qs: requestQueryObject,
                },
            },
            
            
            
            getMetadata: {
                reqOpts: {
                    qs: requestQueryObject,
                },
            },
            
            
            
            
            setMetadata: {
                reqOpts: {
                    qs: requestQueryObject,
                },
            },
        };
        super({
            parent: bucket,
            baseUrl: '/o',
            id: encodeURIComponent(name),
            methods,
        });
        _File_instances.add(this);
        this.bucket = bucket;

        this.storage = bucket.parent;

        if (options.generation !== null) {
            let generation;
            if (typeof options.generation === 'string') {
                generation = Number(options.generation);
            }
            else {
                generation = options.generation;
            }
            if (!isNaN(generation)) {
                this.generation = generation;
            }
        }
        this.kmsKeyName = options.kmsKeyName;
        this.userProject = userProject;
        this.name = name;
        if (options.encryptionKey) {
            this.setEncryptionKey(options.encryptionKey);
        }
        this.acl = new acl_js_1.Acl({
            request: this.request.bind(this),
            pathPrefix: '/acl',
        });
        this.crc32cGenerator =
            options.crc32cGenerator || this.bucket.crc32cGenerator;
        this.instanceRetryValue = (_b = (_a = this.storage) === null || _a === void 0 ? void 0 : _a.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry;
        this.instancePreconditionOpts = options === null || options === void 0 ? void 0 : options.preconditionOpts;
    }
    
    get cloudStorageURI() {
        const uri = this.bucket.cloudStorageURI;
        uri.pathname = this.name;
        return uri;
    }
    
    shouldRetryBasedOnPreconditionAndIdempotencyStrat(options) {
        var _a;
        return !(((options === null || options === void 0 ? void 0 : options.ifGenerationMatch) === undefined &&
            ((_a = this.instancePreconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) === undefined &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryConditional) ||
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryNever);
    }
    
    
    
    
    copy(destination, optionsOrCallback, callback) {
        var _a, _b;
        const noDestinationError = new Error(FileExceptionMessages.DESTINATION_NO_NAME);
        if (!destination) {
            throw noDestinationError;
        }
        let options = {};
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
        }
        else if (optionsOrCallback) {
            options = { ...optionsOrCallback };
        }
        callback = callback || index_js_1.util.noop;
        let destBucket;
        let destName;
        let newFile;
        if (typeof destination === 'string') {
            const parsedDestination = GS_URL_REGEXP.exec(destination);
            if (parsedDestination !== null && parsedDestination.length === 3) {
                destBucket = this.storage.bucket(parsedDestination[1]);
                destName = parsedDestination[2];
            }
            else {
                destBucket = this.bucket;
                destName = destination;
            }
        }
        else if (destination instanceof bucket_js_1.Bucket) {
            destBucket = destination;
            destName = this.name;
        }
        else if (destination instanceof File) {
            destBucket = destination.bucket;
            destName = destination.name;
            newFile = destination;
        }
        else {
            throw noDestinationError;
        }
        const query = {};
        if (this.generation !== undefined) {
            query.sourceGeneration = this.generation;
        }
        if (options.token !== undefined) {
            query.rewriteToken = options.token;
        }
        if (options.userProject !== undefined) {
            query.userProject = options.userProject;
            delete options.userProject;
        }
        if (options.predefinedAcl !== undefined) {
            query.destinationPredefinedAcl = options.predefinedAcl;
            delete options.predefinedAcl;
        }
        newFile = newFile || destBucket.file(destName);
        const headers = {};
        if (this.encryptionKey !== undefined) {
            headers['x-goog-copy-source-encryption-algorithm'] = 'AES256';
            headers['x-goog-copy-source-encryption-key'] = this.encryptionKeyBase64;
            headers['x-goog-copy-source-encryption-key-sha256'] =
                this.encryptionKeyHash;
        }
        if (newFile.encryptionKey !== undefined) {
            this.setEncryptionKey(newFile.encryptionKey);
        }
        else if (options.destinationKmsKeyName !== undefined) {
            query.destinationKmsKeyName = options.destinationKmsKeyName;
            delete options.destinationKmsKeyName;
        }
        else if (newFile.kmsKeyName !== undefined) {
            query.destinationKmsKeyName = newFile.kmsKeyName;
        }
        if (query.destinationKmsKeyName) {
            this.kmsKeyName = query.destinationKmsKeyName;
            const keyIndex = this.interceptors.indexOf(this.encryptionKeyInterceptor);
            if (keyIndex > -1) {
                this.interceptors.splice(keyIndex, 1);
            }
        }
        if (!this.shouldRetryBasedOnPreconditionAndIdempotencyStrat(options === null || options === void 0 ? void 0 : options.preconditionOpts)) {
            this.storage.retryOptions.autoRetry = false;
        }
        if (((_a = options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) !== undefined) {
            query.ifGenerationMatch = (_b = options.preconditionOpts) === null || _b === void 0 ? void 0 : _b.ifGenerationMatch;
            delete options.preconditionOpts;
        }
        this.request({
            method: 'POST',
            uri: `/rewriteTo/b/${destBucket.name}/o/${encodeURIComponent(newFile.name)}`,
            qs: query,
            json: options,
            headers,
        }, (err, resp) => {
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
            if (err) {
                callback(err, null, resp);
                return;
            }
            if (resp.rewriteToken) {
                const options = {
                    token: resp.rewriteToken,
                };
                if (query.userProject) {
                    options.userProject = query.userProject;
                }
                if (query.destinationKmsKeyName) {
                    options.destinationKmsKeyName = query.destinationKmsKeyName;
                }
                this.copy(newFile, options, callback);
                return;
            }
            callback(null, newFile, resp);
        });
    }
    
    
    createReadStream(options = {}) {
        options = Object.assign({ decompress: true }, options);
        const rangeRequest = typeof options.start === 'number' || typeof options.end === 'number';
        const tailRequest = options.end < 0;
        let validateStream = undefined;
        let request = undefined;
        const throughStream = new util_js_2.PassThroughShim();
        let crc32c = true;
        let md5 = false;
        if (typeof options.validation === 'string') {
            const value = options.validation.toLowerCase().trim();
            crc32c = value === 'crc32c';
            md5 = value === 'md5';
        }
        else if (options.validation === false) {
            crc32c = false;
        }
        const shouldRunValidation = !rangeRequest && (crc32c || md5);
        if (rangeRequest) {
            if (typeof options.validation === 'string' ||
                options.validation === true) {
                throw new Error(FileExceptionMessages.INVALID_VALIDATION_FILE_RANGE);
            }

            crc32c = false;
            md5 = false;
        }
        const onComplete = (err) => {
            if (err) {


                if (request === null || request === void 0 ? void 0 : request.agent) {
                    request.agent.destroy();
                }
                throughStream.destroy(err);
            }
        };









        const onResponse = (err, _body, rawResponseStream) => {
            if (err) {

                this.getBufferFromReadable(rawResponseStream).then(body => {
                    err.message = body.toString('utf8');
                    throughStream.destroy(err);
                });
                return;
            }
            request = rawResponseStream.request;
            const headers = rawResponseStream.toJSON().headers;
            const isCompressed = headers['content-encoding'] === 'gzip';
            const hashes = {};



            const safeToValidate = (headers['x-goog-stored-content-encoding'] === 'gzip' &&
                isCompressed) ||
                headers['x-goog-stored-content-encoding'] === 'identity';
            const transformStreams = [];
            if (shouldRunValidation) {


                if (typeof headers['x-goog-hash'] === 'string') {
                    headers['x-goog-hash']
                        .split(',')
                        .forEach((hashKeyValPair) => {
                        const delimiterIndex = hashKeyValPair.indexOf('=');
                        const hashType = hashKeyValPair.substring(0, delimiterIndex);
                        const hashValue = hashKeyValPair.substring(delimiterIndex + 1);
                        hashes[hashType] = hashValue;
                    });
                }
                validateStream = new hash_stream_validator_js_1.HashStreamValidator({
                    crc32c,
                    md5,
                    crc32cGenerator: this.crc32cGenerator,
                    crc32cExpected: hashes.crc32c,
                    md5Expected: hashes.md5,
                });
            }
            if (md5 && !hashes.md5) {
                const hashError = new RequestError(FileExceptionMessages.MD5_NOT_AVAILABLE);
                hashError.code = 'MD5_NOT_AVAILABLE';
                throughStream.destroy(hashError);
                return;
            }
            if (safeToValidate && shouldRunValidation && validateStream) {
                transformStreams.push(validateStream);
            }
            if (isCompressed && options.decompress) {
                transformStreams.push(zlib.createGunzip());
            }
            (0, stream_1.pipeline)(rawResponseStream, ...transformStreams, throughStream, onComplete);
        };


        const makeRequest = () => {
            const query = { alt: 'media' };
            if (this.generation) {
                query.generation = this.generation;
            }
            if (options.userProject) {
                query.userProject = options.userProject;
            }
            const headers = {
                'Accept-Encoding': 'gzip',
                'Cache-Control': 'no-store',
            };
            if (rangeRequest) {
                const start = typeof options.start === 'number' ? options.start : '0';
                const end = typeof options.end === 'number' ? options.end : '';
                headers.Range = `bytes=${tailRequest ? end : `${start}-${end}`}`;
            }
            const reqOpts = {
                uri: '',
                headers,
                qs: query,
            };
            if (options[util_js_1.GCCL_GCS_CMD_KEY]) {
                reqOpts[util_js_1.GCCL_GCS_CMD_KEY] = options[util_js_1.GCCL_GCS_CMD_KEY];
            }
            this.requestStream(reqOpts)
                .on('error', err => {
                throughStream.destroy(err);
            })
                .on('response', res => {
                throughStream.emit('response', res);
                index_js_1.util.handleResp(null, res, null, onResponse);
            })
                .resume();
        };
        throughStream.on('reading', makeRequest);
        return throughStream;
    }
    
    
    
    
    createResumableUpload(optionsOrCallback, callback) {
        var _a, _b;
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const retryOptions = this.storage.retryOptions;
        if ((((_a = options === null || options === void 0 ? void 0 : options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) === undefined &&
            ((_b = this.instancePreconditionOpts) === null || _b === void 0 ? void 0 : _b.ifGenerationMatch) === undefined &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryConditional) ||
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryNever) {
            retryOptions.autoRetry = false;
        }
        resumableUpload.createURI({
            authClient: this.storage.authClient,
            apiEndpoint: this.storage.apiEndpoint,
            bucket: this.bucket.name,
            customRequestOptions: this.getRequestInterceptors().reduce((reqOpts, interceptorFn) => interceptorFn(reqOpts), {}),
            file: this.name,
            generation: this.generation,
            key: this.encryptionKey,
            kmsKeyName: this.kmsKeyName,
            metadata: options.metadata,
            offset: options.offset,
            origin: options.origin,
            predefinedAcl: options.predefinedAcl,
            private: options.private,
            public: options.public,
            userProject: options.userProject || this.userProject,
            retryOptions: retryOptions,
            params: (options === null || options === void 0 ? void 0 : options.preconditionOpts) || this.instancePreconditionOpts,
            universeDomain: this.bucket.storage.universeDomain,
            useAuthWithCustomEndpoint: this.storage.useAuthWithCustomEndpoint,
            [util_js_1.GCCL_GCS_CMD_KEY]: options[util_js_1.GCCL_GCS_CMD_KEY],
        }, callback);
        this.storage.retryOptions.autoRetry = this.instanceRetryValue;
    }
    
    

    createWriteStream(options = {}) {
        var _a;
        (_a = options.metadata) !== null && _a !== void 0 ? _a : (options.metadata = {});
        if (options.contentType) {
            options.metadata.contentType = options.contentType;
        }
        if (!options.metadata.contentType ||
            options.metadata.contentType === 'auto') {
            const detectedContentType = mime_1.default.getType(this.name);
            if (detectedContentType) {
                options.metadata.contentType = detectedContentType;
            }
        }
        let gzip = options.gzip;
        if (gzip === 'auto') {
            gzip = COMPRESSIBLE_MIME_REGEX.test(options.metadata.contentType || '');
        }
        if (gzip) {
            options.metadata.contentEncoding = 'gzip';
        }
        let crc32c = true;
        let md5 = false;
        if (typeof options.validation === 'string') {
            options.validation = options.validation.toLowerCase();
            crc32c = options.validation === 'crc32c';
            md5 = options.validation === 'md5';
        }
        else if (options.validation === false) {
            crc32c = false;
            md5 = false;
        }
        if (options.offset) {
            if (md5) {
                throw new RangeError(FileExceptionMessages.MD5_RESUMED_UPLOAD);
            }
            if (crc32c && !options.isPartialUpload && !options.resumeCRC32C) {
                throw new RangeError(FileExceptionMessages.MISSING_RESUME_CRC32C_FINAL_UPLOAD);
            }
        }
        
        let pipelineCallback = error => {
            writeStream.destroy(error || undefined);
        };

        const writeStream = new stream_1.Writable({
            final(cb) {


                pipelineCallback = cb;
                emitStream.end();
            },
            write(chunk, encoding, cb) {
                emitStream.write(chunk, encoding, cb);
            },
        });



        writeStream.once('error', e => {
            emitStream.destroy(e);
        });

        writeStream.once('close', () => {
            emitStream.destroy();
        });
        const transformStreams = [];
        if (gzip) {
            transformStreams.push(zlib.createGzip());
        }
        const emitStream = new util_js_2.PassThroughShim();

        const noop = () => { };
        emitStream.on('error', noop);
        let hashCalculatingStream = null;
        if (crc32c || md5) {
            const crc32cInstance = options.resumeCRC32C
                ? crc32c_js_1.CRC32C.from(options.resumeCRC32C)
                : undefined;
            hashCalculatingStream = new hash_stream_validator_js_1.HashStreamValidator({
                crc32c,
                crc32cInstance,
                md5,
                crc32cGenerator: this.crc32cGenerator,
                updateHashesOnly: true,
            });
            transformStreams.push(hashCalculatingStream);
        }
        const fileWriteStream = (0, duplexify_1.default)();
        let fileWriteStreamMetadataReceived = false;

        emitStream.on('reading', () => writeStream.emit('reading'));
        emitStream.on('writing', () => writeStream.emit('writing'));
        fileWriteStream.on('uri', evt => writeStream.emit('uri', evt));
        fileWriteStream.on('progress', evt => writeStream.emit('progress', evt));
        fileWriteStream.on('response', resp => writeStream.emit('response', resp));
        fileWriteStream.once('metadata', () => {
            fileWriteStreamMetadataReceived = true;
        });
        writeStream.once('writing', () => {
            if (options.resumable === false) {
                this.startSimpleUpload_(fileWriteStream, options);
            }
            else {
                this.startResumableUpload_(fileWriteStream, options);
            }

            emitStream.removeListener('error', noop);
            (0, stream_1.pipeline)(emitStream, ...transformStreams, fileWriteStream, async (e) => {
                if (e) {
                    return pipelineCallback(e);
                }



                if (!fileWriteStreamMetadataReceived) {
                    try {
                        await new Promise((resolve, reject) => {
                            fileWriteStream.once('metadata', resolve);
                            fileWriteStream.once('error', reject);
                        });
                    }
                    catch (e) {
                        return pipelineCallback(e);
                    }
                }

                if (hashCalculatingStream === null || hashCalculatingStream === void 0 ? void 0 : hashCalculatingStream.crc32c) {
                    writeStream.emit('crc32c', hashCalculatingStream.crc32c);
                }
                try {


                    const metadataNotReady = options.isPartialUpload && !this.metadata;
                    if (hashCalculatingStream && !metadataNotReady) {
                        await __classPrivateFieldGet(this, _File_instances, "m", _File_validateIntegrity).call(this, hashCalculatingStream, {
                            crc32c,
                            md5,
                        });
                    }
                    pipelineCallback();
                }
                catch (e) {
                    pipelineCallback(e);
                }
            });
        });
        return writeStream;
    }
    delete(optionsOrCallback, cb) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        cb = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;
        this.disableAutoRetryConditionallyIdempotent_(this.methods.delete, bucket_js_1.AvailableServiceObjectMethods.delete, options);
        super
            .delete(options)
            .then(resp => cb(null, ...resp))
            .catch(cb)
            .finally(() => {
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
        });
    }
    
    
    
    download(optionsOrCallback, cb) {
        let options;
        if (typeof optionsOrCallback === 'function') {
            cb = optionsOrCallback;
            options = {};
        }
        else {
            options = Object.assign({}, optionsOrCallback);
        }
        let called = false;
        const callback = ((...args) => {
            if (!called)
                cb(...args);
            called = true;
        });
        const destination = options.destination;
        delete options.destination;
        if (options.encryptionKey) {
            this.setEncryptionKey(options.encryptionKey);
            delete options.encryptionKey;
        }
        const fileStream = this.createReadStream(options);
        let receivedData = false;
        if (destination) {
            fileStream
                .on('error', callback)
                .once('data', data => {
                receivedData = true;

                const writable = fs.createWriteStream(destination);
                writable.write(data);
                fileStream
                    .pipe(writable)
                    .on('error', (err) => {
                    callback(err, Buffer.from(''));
                })
                    .on('finish', () => {
                    callback(null, data);
                });
            })
                .on('end', () => {

                if (!receivedData) {
                    const data = Buffer.alloc(0);
                    try {
                        fs.writeFileSync(destination, data);
                        callback(null, data);
                    }
                    catch (e) {
                        callback(e, data);
                    }
                }
            });
        }
        else {
            this.getBufferFromReadable(fileStream)
                .then(contents => callback === null || callback === void 0 ? void 0 : callback(null, contents))
                .catch(callback);
        }
    }
    
    setEncryptionKey(encryptionKey) {
        this.encryptionKey = encryptionKey;
        this.encryptionKeyBase64 = Buffer.from(encryptionKey).toString('base64');
        this.encryptionKeyHash = crypto
            .createHash('sha256')

            .update(this.encryptionKeyBase64, 'base64')
            .digest('base64');
        this.encryptionKeyInterceptor = {
            request: reqOpts => {
                reqOpts.headers = reqOpts.headers || {};
                reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';
                reqOpts.headers['x-goog-encryption-key'] = this.encryptionKeyBase64;
                reqOpts.headers['x-goog-encryption-key-sha256'] =
                    this.encryptionKeyHash;
                return reqOpts;
            },
        };
        this.interceptors.push(this.encryptionKeyInterceptor);
        return this;
    }
    
    static from(publicUrlOrGsUrl, storageInstance, options) {
        const gsMatches = [...publicUrlOrGsUrl.matchAll(GS_UTIL_URL_REGEX)];
        const httpsMatches = [...publicUrlOrGsUrl.matchAll(HTTPS_PUBLIC_URL_REGEX)];
        if (gsMatches.length > 0) {
            const bucket = new bucket_js_1.Bucket(storageInstance, gsMatches[0][2]);
            return new File(bucket, gsMatches[0][3], options);
        }
        else if (httpsMatches.length > 0) {
            const bucket = new bucket_js_1.Bucket(storageInstance, httpsMatches[0][3]);
            return new File(bucket, httpsMatches[0][4], options);
        }
        else {
            throw new Error('URL string must be of format gs://bucket/file or https://storage.googleapis.com/bucket/file');
        }
    }
    get(optionsOrCallback, cb) {

        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        cb =
            typeof optionsOrCallback === 'function'
                ? optionsOrCallback
                : cb;
        super
            .get(options)
            .then(resp => cb(null, ...resp))
            .catch(cb);
    }
    
    
    
    getExpirationDate(callback) {
        this.getMetadata((err, metadata, apiResponse) => {
            if (err) {
                callback(err, null, apiResponse);
                return;
            }
            if (!metadata.retentionExpirationTime) {
                const error = new Error(FileExceptionMessages.EXPIRATION_TIME_NA);
                callback(error, null, apiResponse);
                return;
            }
            callback(null, new Date(metadata.retentionExpirationTime), apiResponse);
        });
    }
    
    
    
    generateSignedPostPolicyV2(optionsOrCallback, cb) {
        const args = (0, util_js_2.normalize)(optionsOrCallback, cb);
        let options = args.options;
        const callback = args.callback;
        const expires = new Date(options.expires);
        if (isNaN(expires.getTime())) {
            throw new Error(storage_js_1.ExceptionMessages.EXPIRATION_DATE_INVALID);
        }
        if (expires.valueOf() < Date.now()) {
            throw new Error(storage_js_1.ExceptionMessages.EXPIRATION_DATE_PAST);
        }
        options = Object.assign({}, options);
        const conditions = [
            ['eq', '$key', this.name],
            {
                bucket: this.bucket.name,
            },
        ];
        if (Array.isArray(options.equals)) {
            if (!Array.isArray(options.equals[0])) {
                options.equals = [options.equals];
            }
            options.equals.forEach(condition => {
                if (!Array.isArray(condition) || condition.length !== 2) {
                    throw new Error(FileExceptionMessages.EQUALS_CONDITION_TWO_ELEMENTS);
                }
                conditions.push(['eq', condition[0], condition[1]]);
            });
        }
        if (Array.isArray(options.startsWith)) {
            if (!Array.isArray(options.startsWith[0])) {
                options.startsWith = [options.startsWith];
            }
            options.startsWith.forEach(condition => {
                if (!Array.isArray(condition) || condition.length !== 2) {
                    throw new Error(FileExceptionMessages.STARTS_WITH_TWO_ELEMENTS);
                }
                conditions.push(['starts-with', condition[0], condition[1]]);
            });
        }
        if (options.acl) {
            conditions.push({
                acl: options.acl,
            });
        }
        if (options.successRedirect) {
            conditions.push({
                success_action_redirect: options.successRedirect,
            });
        }
        if (options.successStatus) {
            conditions.push({
                success_action_status: options.successStatus,
            });
        }
        if (options.contentLengthRange) {
            const min = options.contentLengthRange.min;
            const max = options.contentLengthRange.max;
            if (typeof min !== 'number' || typeof max !== 'number') {
                throw new Error(FileExceptionMessages.CONTENT_LENGTH_RANGE_MIN_MAX);
            }
            conditions.push(['content-length-range', min, max]);
        }
        const policy = {
            expiration: expires.toISOString(),
            conditions,
        };
        const policyString = JSON.stringify(policy);
        const policyBase64 = Buffer.from(policyString).toString('base64');
        this.storage.authClient.sign(policyBase64, options.signingEndpoint).then(signature => {
            callback(null, {
                string: policyString,
                base64: policyBase64,
                signature,
            });
        }, err => {
            callback(new signer_js_1.SigningError(err.message));
        });
    }
    
    
    
    
    generateSignedPostPolicyV4(optionsOrCallback, cb) {
        const args = (0, util_js_2.normalize)(optionsOrCallback, cb);
        let options = args.options;
        const callback = args.callback;
        const expires = new Date(options.expires);
        if (isNaN(expires.getTime())) {
            throw new Error(storage_js_1.ExceptionMessages.EXPIRATION_DATE_INVALID);
        }
        if (expires.valueOf() < Date.now()) {
            throw new Error(storage_js_1.ExceptionMessages.EXPIRATION_DATE_PAST);
        }
        if (expires.valueOf() - Date.now() > SEVEN_DAYS * 1000) {
            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);
        }
        options = Object.assign({}, options);
        let fields = Object.assign({}, options.fields);
        const now = new Date();
        const nowISO = (0, util_js_2.formatAsUTCISO)(now, true);
        const todayISO = (0, util_js_2.formatAsUTCISO)(now);
        const sign = async () => {
            const { client_email } = await this.storage.authClient.getCredentials();
            const credential = `${client_email}/${todayISO}/auto/storage/goog4_request`;
            fields = {
                ...fields,
                bucket: this.bucket.name,
                key: this.name,
                'x-goog-date': nowISO,
                'x-goog-credential': credential,
                'x-goog-algorithm': 'GOOG4-RSA-SHA256',
            };
            const conditions = options.conditions || [];
            Object.entries(fields).forEach(([key, value]) => {
                if (!key.startsWith('x-ignore-')) {
                    conditions.push({ [key]: value });
                }
            });
            delete fields.bucket;
            const expiration = (0, util_js_2.formatAsUTCISO)(expires, true, '-', ':');
            const policy = {
                conditions,
                expiration,
            };
            const policyString = (0, util_js_2.unicodeJSONStringify)(policy);
            const policyBase64 = Buffer.from(policyString).toString('base64');
            try {
                const signature = await this.storage.authClient.sign(policyBase64, options.signingEndpoint);
                const signatureHex = Buffer.from(signature, 'base64').toString('hex');
                const universe = this.parent.storage.universeDomain;
                fields['policy'] = policyBase64;
                fields['x-goog-signature'] = signatureHex;
                let url;
                if (this.storage.customEndpoint) {
                    url = this.storage.apiEndpoint;
                }
                else if (options.virtualHostedStyle) {
                    url = `https://${this.bucket.name}.storage.${universe}/`;
                }
                else if (options.bucketBoundHostname) {
                    url = `${options.bucketBoundHostname}/`;
                }
                else {
                    url = `https://storage.${universe}/${this.bucket.name}/`;
                }
                return {
                    url,
                    fields,
                };
            }
            catch (err) {
                throw new signer_js_1.SigningError(err.message);
            }
        };
        sign().then(res => callback(null, res), callback);
    }
    
    
    
    getSignedUrl(cfg, callback) {
        const method = ActionToHTTPMethod[cfg.action];
        const extensionHeaders = (0, util_js_2.objectKeyToLowercase)(cfg.extensionHeaders || {});
        if (cfg.action === 'resumable') {
            extensionHeaders['x-goog-resumable'] = 'start';
        }
        const queryParams = Object.assign({}, cfg.queryParams);
        if (typeof cfg.responseType === 'string') {
            queryParams['response-content-type'] = cfg.responseType;
        }
        if (typeof cfg.promptSaveAs === 'string') {
            queryParams['response-content-disposition'] =
                'attachment; filename="' + cfg.promptSaveAs + '"';
        }
        if (typeof cfg.responseDisposition === 'string') {
            queryParams['response-content-disposition'] = cfg.responseDisposition;
        }
        if (this.generation) {
            queryParams['generation'] = this.generation.toString();
        }
        const signConfig = {
            method,
            expires: cfg.expires,
            accessibleAt: cfg.accessibleAt,
            extensionHeaders,
            queryParams,
            contentMd5: cfg.contentMd5,
            contentType: cfg.contentType,
            host: cfg.host,
        };
        if (cfg.cname) {
            signConfig.cname = cfg.cname;
        }
        if (cfg.version) {
            signConfig.version = cfg.version;
        }
        if (cfg.virtualHostedStyle) {
            signConfig.virtualHostedStyle = cfg.virtualHostedStyle;
        }
        if (!this.signer) {
            this.signer = new signer_js_1.URLSigner(this.storage.authClient, this.bucket, this, this.storage);
        }
        this.signer
            .getSignedUrl(signConfig)
            .then(signedUrl => callback(null, signedUrl), callback);
    }
    
    
    
    isPublic(callback) {
        var _a;


        const storageInterceptors = ((_a = this.storage) === null || _a === void 0 ? void 0 : _a.interceptors) || [];
        const fileInterceptors = this.interceptors || [];
        const allInterceptors = storageInterceptors.concat(fileInterceptors);
        const headers = allInterceptors.reduce((acc, curInterceptor) => {
            const currentHeaders = curInterceptor.request({
                uri: `${this.storage.apiEndpoint}/${this.bucket.name}/${encodeURIComponent(this.name)}`,
            });
            Object.assign(acc, currentHeaders.headers);
            return acc;
        }, {});
        index_js_1.util.makeRequest({
            method: 'GET',
            uri: `${this.storage.apiEndpoint}/${this.bucket.name}/${encodeURIComponent(this.name)}`,
            headers,
        }, {
            retryOptions: this.storage.retryOptions,
        }, (err) => {
            if (err) {
                const apiError = err;
                if (apiError.code === 403) {
                    callback(null, false);
                }
                else {
                    callback(err);
                }
            }
            else {
                callback(null, true);
            }
        });
    }
    
    
    
    
    makePrivate(optionsOrCallback, callback) {
        var _a, _b;
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const query = {
            predefinedAcl: options.strict ? 'private' : 'projectPrivate',

        };
        if (((_a = options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifMetagenerationMatch) !== undefined) {
            query.ifMetagenerationMatch =
                (_b = options.preconditionOpts) === null || _b === void 0 ? void 0 : _b.ifMetagenerationMatch;
            delete options.preconditionOpts;
        }
        if (options.userProject) {
            query.userProject = options.userProject;
        }



        const metadata = { ...options.metadata, acl: null };
        this.setMetadata(metadata, query, callback);
    }
    
    
    
    makePublic(callback) {
        callback = callback || index_js_1.util.noop;
        this.acl.add({
            entity: 'allUsers',
            role: 'READER',
        }, (err, acl, resp) => {
            callback(err, resp);
        });
    }
    
    publicUrl() {
        return `${this.storage.apiEndpoint}/${this.bucket.name}/${encodeURIComponent(this.name)}`;
    }
    
    
    
    
    moveFileAtomic(destination, optionsOrCallback, callback) {
        var _a, _b;
        const noDestinationError = new Error(FileExceptionMessages.DESTINATION_NO_NAME);
        if (!destination) {
            throw noDestinationError;
        }
        let options = {};
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
        }
        else if (optionsOrCallback) {
            options = { ...optionsOrCallback };
        }
        callback = callback || index_js_1.util.noop;
        let destName;
        let newFile;
        if (typeof destination === 'string') {
            const parsedDestination = GS_URL_REGEXP.exec(destination);
            if (parsedDestination !== null && parsedDestination.length === 3) {
                destName = parsedDestination[2];
            }
            else {
                destName = destination;
            }
        }
        else if (destination instanceof File) {
            destName = destination.name;
            newFile = destination;
        }
        else {
            throw noDestinationError;
        }
        newFile = newFile || this.bucket.file(destName);
        if (!this.shouldRetryBasedOnPreconditionAndIdempotencyStrat(options === null || options === void 0 ? void 0 : options.preconditionOpts)) {
            this.storage.retryOptions.autoRetry = false;
        }
        const query = {};
        if (options.userProject !== undefined) {
            query.userProject = options.userProject;
            delete options.userProject;
        }
        if (((_a = options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) !== undefined) {
            query.ifGenerationMatch = (_b = options.preconditionOpts) === null || _b === void 0 ? void 0 : _b.ifGenerationMatch;
            delete options.preconditionOpts;
        }
        this.request({
            method: 'POST',
            uri: `/moveTo/o/${encodeURIComponent(newFile.name)}`,
            qs: query,
            json: options,
        }, (err, resp) => {
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
            if (err) {
                callback(err, null, resp);
                return;
            }
            callback(null, newFile, resp);
        });
    }
    
    
    
    
    move(destination, optionsOrCallback, callback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        callback = callback || index_js_1.util.noop;
        this.copy(destination, options, (err, destinationFile, copyApiResponse) => {
            if (err) {
                err.message = 'file#copy failed with an error - ' + err.message;
                callback(err, null, copyApiResponse);
                return;
            }
            if (this.name !== destinationFile.name ||
                this.bucket.name !== destinationFile.bucket.name) {
                this.delete(options, (err, apiResponse) => {
                    if (err) {
                        err.message = 'file#delete failed with an error - ' + err.message;
                        callback(err, destinationFile, apiResponse);
                        return;
                    }
                    callback(null, destinationFile, copyApiResponse);
                });
            }
            else {
                callback(null, destinationFile, copyApiResponse);
            }
        });
    }
    
    
    
    
    rename(destinationFile, optionsOrCallback, callback) {
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        callback = callback || index_js_1.util.noop;
        this.move(destinationFile, options, callback);
    }
    
    
    async restore(options) {
        const [file] = await this.request({
            method: 'POST',
            uri: '/restore',
            qs: options,
        });
        return file;
    }
    
    request(reqOpts, callback) {
        return this.parent.request.call(this, reqOpts, callback);
    }
    
    
    
    
    rotateEncryptionKey(optionsOrCallback, callback) {
        var _a;
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        let options = {};
        if (typeof optionsOrCallback === 'string' ||
            optionsOrCallback instanceof Buffer) {
            options = {
                encryptionKey: optionsOrCallback,
            };
        }
        else if (typeof optionsOrCallback === 'object') {
            options = optionsOrCallback;
        }
        const newFile = this.bucket.file(this.id, options);
        const copyOptions = ((_a = options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) !== undefined
            ? { preconditionOpts: options.preconditionOpts }
            : {};
        this.copy(newFile, copyOptions, callback);
    }
    
    
    
    save(data, optionsOrCallback, callback) {

        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        let maxRetries = this.storage.retryOptions.maxRetries;
        if (!this.shouldRetryBasedOnPreconditionAndIdempotencyStrat(options === null || options === void 0 ? void 0 : options.preconditionOpts)) {
            maxRetries = 0;
        }
        const returnValue = (0, async_retry_1.default)(async (bail) => {
            return new Promise((resolve, reject) => {
                if (maxRetries === 0) {
                    this.storage.retryOptions.autoRetry = false;
                }
                const writable = this.createWriteStream(options);
                if (options.onUploadProgress) {
                    writable.on('progress', options.onUploadProgress);
                }
                const handleError = (err) => {
                    if (this.storage.retryOptions.autoRetry &&
                        this.storage.retryOptions.retryableErrorFn(err)) {
                        return reject(err);
                    }
                    return bail(err);
                };
                if (typeof data === 'string' ||
                    Buffer.isBuffer(data) ||
                    data instanceof Uint8Array) {
                    writable
                        .on('error', handleError)
                        .on('finish', () => resolve())
                        .end(data);
                }
                else {
                    (0, stream_1.pipeline)(data, writable, err => {
                        if (err) {
                            if (typeof data !== 'function') {


                                return bail(err);
                            }
                            handleError(err);
                        }
                        else {
                            resolve();
                        }
                    });
                }
            });
        }, {
            retries: maxRetries,
            factor: this.storage.retryOptions.retryDelayMultiplier,
            maxTimeout: this.storage.retryOptions.maxRetryDelay * 1000, //convert to milliseconds
            maxRetryTime: this.storage.retryOptions.totalTimeout * 1000, //convert to milliseconds
        });
        if (!callback) {
            return returnValue;
        }
        else {
            return returnValue
                .then(() => {
                if (callback) {
                    return callback();
                }
            })
                .catch(callback);
        }
    }
    setMetadata(metadata, optionsOrCallback, cb) {

        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        cb =
            typeof optionsOrCallback === 'function'
                ? optionsOrCallback
                : cb;
        this.disableAutoRetryConditionallyIdempotent_(this.methods.setMetadata, bucket_js_1.AvailableServiceObjectMethods.setMetadata, options);
        super
            .setMetadata(metadata, options)
            .then(resp => cb(null, ...resp))
            .catch(cb)
            .finally(() => {
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
        });
    }
    
    
    
    
    setStorageClass(storageClass, optionsOrCallback, callback) {
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};
        const req = {
            ...options,

            storageClass: storageClass
                .replace(/-/g, '_')
                .replace(/([a-z])([A-Z])/g, (_, low, up) => {
                return low + '_' + up;
            })
                .toUpperCase(),
        };
        this.copy(this, req, (err, file, apiResponse) => {
            if (err) {
                callback(err, apiResponse);
                return;
            }
            this.metadata = file.metadata;
            callback(null, apiResponse);
        });
    }
    
    setUserProject(userProject) {
        this.bucket.setUserProject.call(this, userProject);
    }
    
    startResumableUpload_(dup, options = {}) {
        var _a;
        (_a = options.metadata) !== null && _a !== void 0 ? _a : (options.metadata = {});
        const retryOptions = this.storage.retryOptions;
        if (!this.shouldRetryBasedOnPreconditionAndIdempotencyStrat(options.preconditionOpts)) {
            retryOptions.autoRetry = false;
        }
        const cfg = {
            authClient: this.storage.authClient,
            apiEndpoint: this.storage.apiEndpoint,
            bucket: this.bucket.name,
            customRequestOptions: this.getRequestInterceptors().reduce((reqOpts, interceptorFn) => interceptorFn(reqOpts), {}),
            file: this.name,
            generation: this.generation,
            isPartialUpload: options.isPartialUpload,
            key: this.encryptionKey,
            kmsKeyName: this.kmsKeyName,
            metadata: options.metadata,
            offset: options.offset,
            predefinedAcl: options.predefinedAcl,
            private: options.private,
            public: options.public,
            uri: options.uri,
            userProject: options.userProject || this.userProject,
            retryOptions: { ...retryOptions },
            params: (options === null || options === void 0 ? void 0 : options.preconditionOpts) || this.instancePreconditionOpts,
            chunkSize: options === null || options === void 0 ? void 0 : options.chunkSize,
            highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,
            universeDomain: this.bucket.storage.universeDomain,
            [util_js_1.GCCL_GCS_CMD_KEY]: options[util_js_1.GCCL_GCS_CMD_KEY],
        };
        let uploadStream;
        try {
            uploadStream = resumableUpload.upload(cfg);
        }
        catch (error) {
            dup.destroy(error);
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
            return;
        }
        uploadStream
            .on('response', resp => {
            dup.emit('response', resp);
        })
            .on('uri', uri => {
            dup.emit('uri', uri);
        })
            .on('metadata', metadata => {
            this.metadata = metadata;
            dup.emit('metadata');
        })
            .on('finish', () => {
            dup.emit('complete');
        })
            .on('progress', evt => dup.emit('progress', evt));
        dup.setWritable(uploadStream);
        this.storage.retryOptions.autoRetry = this.instanceRetryValue;
    }
    
    startSimpleUpload_(dup, options = {}) {
        var _a;
        (_a = options.metadata) !== null && _a !== void 0 ? _a : (options.metadata = {});
        const apiEndpoint = this.storage.apiEndpoint;
        const bucketName = this.bucket.name;
        const uri = `${apiEndpoint}/upload/storage/v1/b/${bucketName}/o`;
        const reqOpts = {
            qs: {
                name: this.name,
            },
            uri: uri,
            [util_js_1.GCCL_GCS_CMD_KEY]: options[util_js_1.GCCL_GCS_CMD_KEY],
        };
        if (this.generation !== undefined) {
            reqOpts.qs.ifGenerationMatch = this.generation;
        }
        if (this.kmsKeyName !== undefined) {
            reqOpts.qs.kmsKeyName = this.kmsKeyName;
        }
        if (typeof options.timeout === 'number') {
            reqOpts.timeout = options.timeout;
        }
        if (options.userProject || this.userProject) {
            reqOpts.qs.userProject = options.userProject || this.userProject;
        }
        if (options.predefinedAcl) {
            reqOpts.qs.predefinedAcl = options.predefinedAcl;
        }
        else if (options.private) {
            reqOpts.qs.predefinedAcl = 'private';
        }
        else if (options.public) {
            reqOpts.qs.predefinedAcl = 'publicRead';
        }
        Object.assign(reqOpts.qs, this.instancePreconditionOpts, options.preconditionOpts);
        index_js_1.util.makeWritableStream(dup, {
            makeAuthenticatedRequest: (reqOpts) => {
                this.request(reqOpts, (err, body, resp) => {
                    if (err) {
                        dup.destroy(err);
                        return;
                    }
                    this.metadata = body;
                    dup.emit('metadata', body);
                    dup.emit('response', resp);
                    dup.emit('complete');
                });
            },
            metadata: options.metadata,
            request: reqOpts,
        });
    }
    disableAutoRetryConditionallyIdempotent_(

    coreOpts, methodType, localPreconditionOptions) {
        var _a, _b, _c, _d;
        if ((typeof coreOpts === 'object' &&
            ((_b = (_a = coreOpts === null || coreOpts === void 0 ? void 0 : coreOpts.reqOpts) === null || _a === void 0 ? void 0 : _a.qs) === null || _b === void 0 ? void 0 : _b.ifGenerationMatch) === undefined &&
            (localPreconditionOptions === null || localPreconditionOptions === void 0 ? void 0 : localPreconditionOptions.ifGenerationMatch) === undefined &&
            methodType === bucket_js_1.AvailableServiceObjectMethods.delete &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryConditional) ||
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryNever) {
            this.storage.retryOptions.autoRetry = false;
        }
        if ((typeof coreOpts === 'object' &&
            ((_d = (_c = coreOpts === null || coreOpts === void 0 ? void 0 : coreOpts.reqOpts) === null || _c === void 0 ? void 0 : _c.qs) === null || _d === void 0 ? void 0 : _d.ifMetagenerationMatch) === undefined &&
            (localPreconditionOptions === null || localPreconditionOptions === void 0 ? void 0 : localPreconditionOptions.ifMetagenerationMatch) === undefined &&
            methodType === bucket_js_1.AvailableServiceObjectMethods.setMetadata &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryConditional) ||
            this.storage.retryOptions.idempotencyStrategy ===
                storage_js_1.IdempotencyStrategy.RetryNever) {
            this.storage.retryOptions.autoRetry = false;
        }
    }
    async getBufferFromReadable(readable) {
        const buf = [];
        for await (const chunk of readable) {
            buf.push(chunk);
        }
        return Buffer.concat(buf);
    }
}
exports.File = File;
_File_instances = new WeakSet(), _File_validateIntegrity = 

async function _File_validateIntegrity(hashCalculatingStream, verify = {}) {
    const metadata = this.metadata;

    let dataMismatch = !!(verify.crc32c || verify.md5);
    if (verify.crc32c && metadata.crc32c) {
        dataMismatch = !hashCalculatingStream.test('crc32c', metadata.crc32c);
    }
    if (verify.md5 && metadata.md5Hash) {
        dataMismatch = !hashCalculatingStream.test('md5', metadata.md5Hash);
    }
    if (dataMismatch) {
        const errors = [];
        let code = '';
        let message = '';
        try {
            await this.delete();
            if (verify.md5 && !metadata.md5Hash) {
                code = 'MD5_NOT_AVAILABLE';
                message = FileExceptionMessages.MD5_NOT_AVAILABLE;
            }
            else {
                code = 'FILE_NO_UPLOAD';
                message = FileExceptionMessages.UPLOAD_MISMATCH;
            }
        }
        catch (e) {
            const error = e;
            code = 'FILE_NO_UPLOAD_DELETE';
            message = `${FileExceptionMessages.UPLOAD_MISMATCH_DELETE_FAIL}${error.message}`;
            errors.push(error);
        }
        const error = new RequestError(message);
        error.code = code;
        error.errors = errors;
        throw error;
    }
    return true;
};

(0, promisify_1.promisifyAll)(File, {
    exclude: [
        'cloudStorageURI',
        'publicUrl',
        'request',
        'save',
        'setEncryptionKey',
        'shouldRetryBasedOnPreconditionAndIdempotencyStrat',
        'getBufferFromReadable',
        'restore',
    ],
});

