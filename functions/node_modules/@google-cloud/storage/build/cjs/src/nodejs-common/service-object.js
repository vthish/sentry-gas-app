"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceObject = void 0;

const promisify_1 = require("@google-cloud/promisify");
const events_1 = require("events");
const util_js_1 = require("./util.js");


class ServiceObject extends events_1.EventEmitter {
    
    constructor(config) {
        super();
        this.metadata = {};
        this.baseUrl = config.baseUrl;
        this.parent = config.parent; // Parent class.
        this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc).
        this.createMethod = config.createMethod;
        this.methods = config.methods || {};
        this.interceptors = [];
        this.projectId = config.projectId;
        if (config.methods) {



            Object.getOwnPropertyNames(ServiceObject.prototype)
                .filter(methodName => {
                return (


                !/^request/.test(methodName) &&
                    !/^getRequestInterceptors/.test(methodName) &&



                    this[methodName] ===

                        ServiceObject.prototype[methodName] &&

                    !config.methods[methodName]);
            })
                .forEach(methodName => {

                this[methodName] = undefined;
            });
        }
    }
    create(optionsOrCallback, callback) {

        const self = this;
        const args = [this.id];
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
        }
        if (typeof optionsOrCallback === 'object') {
            args.push(optionsOrCallback);
        }



        function onCreate(...args) {
            const [err, instance] = args;
            if (!err) {
                self.metadata = instance.metadata;
                if (self.id && instance.metadata) {
                    self.id = instance.metadata.id;
                }
                args[1] = self; // replace the created `instance` with this one.
            }
            callback(...args);
        }
        args.push(onCreate);

        this.createMethod.apply(null, args);
    }
    delete(optionsOrCallback, cb) {
        var _a;
        const [options, callback] = util_js_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const ignoreNotFound = options.ignoreNotFound;
        delete options.ignoreNotFound;
        const methodConfig = (typeof this.methods.delete === 'object' && this.methods.delete) || {};
        const reqOpts = {
            method: 'DELETE',
            uri: '',
            ...methodConfig.reqOpts,
            qs: {
                ...(_a = methodConfig.reqOpts) === null || _a === void 0 ? void 0 : _a.qs,
                ...options,
            },
        };


        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {
            if (err) {
                if (err.code === 404 && ignoreNotFound) {
                    err = null;
                }
            }
            callback(err, res);
        });
    }
    exists(optionsOrCallback, cb) {
        const [options, callback] = util_js_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        this.get(options, err => {
            if (err) {
                if (err.code === 404) {
                    callback(null, false);
                }
                else {
                    callback(err);
                }
                return;
            }
            callback(null, true);
        });
    }
    get(optionsOrCallback, cb) {

        const self = this;
        const [opts, callback] = util_js_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const options = Object.assign({}, opts);
        const autoCreate = options.autoCreate && typeof this.create === 'function';
        delete options.autoCreate;
        function onCreate(err, instance, apiResponse) {
            if (err) {
                if (err.code === 409) {
                    self.get(options, callback);
                    return;
                }
                callback(err, null, apiResponse);
                return;
            }
            callback(null, instance, apiResponse);
        }
        this.getMetadata(options, (err, metadata) => {
            if (err) {
                if (err.code === 404 && autoCreate) {
                    const args = [];
                    if (Object.keys(options).length > 0) {
                        args.push(options);
                    }
                    args.push(onCreate);
                    self.create(...args);
                    return;
                }
                callback(err, null, metadata);
                return;
            }
            callback(null, self, metadata);
        });
    }
    getMetadata(optionsOrCallback, cb) {
        var _a;
        const [options, callback] = util_js_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const methodConfig = (typeof this.methods.getMetadata === 'object' &&
            this.methods.getMetadata) ||
            {};
        const reqOpts = {
            uri: '',
            ...methodConfig.reqOpts,
            qs: {
                ...(_a = methodConfig.reqOpts) === null || _a === void 0 ? void 0 : _a.qs,
                ...options,
            },
        };


        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {
            this.metadata = body;
            callback(err, this.metadata, res);
        });
    }
    
    getRequestInterceptors() {

        const localInterceptors = this.interceptors
            .filter(interceptor => typeof interceptor.request === 'function')
            .map(interceptor => interceptor.request);
        return this.parent.getRequestInterceptors().concat(localInterceptors);
    }
    setMetadata(metadata, optionsOrCallback, cb) {
        var _a, _b;
        const [options, callback] = util_js_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const methodConfig = (typeof this.methods.setMetadata === 'object' &&
            this.methods.setMetadata) ||
            {};
        const reqOpts = {
            method: 'PATCH',
            uri: '',
            ...methodConfig.reqOpts,
            json: {
                ...(_a = methodConfig.reqOpts) === null || _a === void 0 ? void 0 : _a.json,
                ...metadata,
            },
            qs: {
                ...(_b = methodConfig.reqOpts) === null || _b === void 0 ? void 0 : _b.qs,
                ...options,
            },
        };


        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {
            this.metadata = body;
            callback(err, this.metadata, res);
        });
    }
    request_(reqOpts, callback) {
        reqOpts = { ...reqOpts };
        if (this.projectId) {
            reqOpts.projectId = this.projectId;
        }
        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;
        const uriComponents = [this.baseUrl, this.id || '', reqOpts.uri];
        if (isAbsoluteUrl) {
            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));
        }
        reqOpts.uri = uriComponents
            .filter(x => x.trim()) // Limit to non-empty strings.
            .map(uriComponent => {
            const trimSlashesRegex = /^\
    requestStream(reqOpts) {
        const opts = { ...reqOpts, shouldReturnStream: true };
        return this.request_(opts);
    }
}
exports.ServiceObject = ServiceObject;
(0, promisify_1.promisifyAll)(ServiceObject, { exclude: ['getRequestInterceptors'] });

