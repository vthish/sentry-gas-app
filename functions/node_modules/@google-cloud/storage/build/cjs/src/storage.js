"use strict";













Object.defineProperty(exports, "__esModule", { value: true });
exports.Storage = exports.RETRYABLE_ERR_FN_DEFAULT = exports.MAX_RETRY_DELAY_DEFAULT = exports.TOTAL_TIMEOUT_DEFAULT = exports.RETRY_DELAY_MULTIPLIER_DEFAULT = exports.MAX_RETRY_DEFAULT = exports.AUTO_RETRY_DEFAULT = exports.PROTOCOL_REGEX = exports.StorageExceptionMessages = exports.ExceptionMessages = exports.IdempotencyStrategy = void 0;
const index_js_1 = require("./nodejs-common/index.js");
const paginator_1 = require("@google-cloud/paginator");
const promisify_1 = require("@google-cloud/promisify");
const stream_1 = require("stream");
const bucket_js_1 = require("./bucket.js");
const channel_js_1 = require("./channel.js");
const file_js_1 = require("./file.js");
const util_js_1 = require("./util.js");


const package_json_helper_cjs_1 = require("./package-json-helper.cjs");
const hmacKey_js_1 = require("./hmacKey.js");
const crc32c_js_1 = require("./crc32c.js");
const google_auth_library_1 = require("google-auth-library");
var IdempotencyStrategy;
(function (IdempotencyStrategy) {
    IdempotencyStrategy[IdempotencyStrategy["RetryAlways"] = 0] = "RetryAlways";
    IdempotencyStrategy[IdempotencyStrategy["RetryConditional"] = 1] = "RetryConditional";
    IdempotencyStrategy[IdempotencyStrategy["RetryNever"] = 2] = "RetryNever";
})(IdempotencyStrategy || (exports.IdempotencyStrategy = IdempotencyStrategy = {}));
var ExceptionMessages;
(function (ExceptionMessages) {
    ExceptionMessages["EXPIRATION_DATE_INVALID"] = "The expiration date provided was invalid.";
    ExceptionMessages["EXPIRATION_DATE_PAST"] = "An expiration date cannot be in the past.";
})(ExceptionMessages || (exports.ExceptionMessages = ExceptionMessages = {}));
var StorageExceptionMessages;
(function (StorageExceptionMessages) {
    StorageExceptionMessages["BUCKET_NAME_REQUIRED"] = "A bucket name is needed to use Cloud Storage.";
    StorageExceptionMessages["BUCKET_NAME_REQUIRED_CREATE"] = "A name is required to create a bucket.";
    StorageExceptionMessages["HMAC_SERVICE_ACCOUNT"] = "The first argument must be a service account email to create an HMAC key.";
    StorageExceptionMessages["HMAC_ACCESS_ID"] = "An access ID is needed to create an HmacKey object.";
})(StorageExceptionMessages || (exports.StorageExceptionMessages = StorageExceptionMessages = {}));
exports.PROTOCOL_REGEX = /^(\w*):\/\//;

exports.AUTO_RETRY_DEFAULT = true;

exports.MAX_RETRY_DEFAULT = 3;

exports.RETRY_DELAY_MULTIPLIER_DEFAULT = 2;

exports.TOTAL_TIMEOUT_DEFAULT = 600;

exports.MAX_RETRY_DELAY_DEFAULT = 64;

const IDEMPOTENCY_STRATEGY_DEFAULT = IdempotencyStrategy.RetryConditional;

const RETRYABLE_ERR_FN_DEFAULT = function (err) {
    var _a;
    const isConnectionProblem = (reason) => {
        return (reason.includes('eai_again') || // DNS lookup error
            reason === 'econnreset' ||
            reason === 'unexpected connection closure' ||
            reason === 'epipe' ||
            reason === 'socket connection timeout');
    };
    if (err) {
        if ([408, 429, 500, 502, 503, 504].indexOf(err.code) !== -1) {
            return true;
        }
        if (typeof err.code === 'string') {
            if (['408', '429', '500', '502', '503', '504'].indexOf(err.code) !== -1) {
                return true;
            }
            const reason = err.code.toLowerCase();
            if (isConnectionProblem(reason)) {
                return true;
            }
        }
        if (err.errors) {
            for (const e of err.errors) {
                const reason = (_a = e === null || e === void 0 ? void 0 : e.reason) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase();
                if (reason && isConnectionProblem(reason)) {
                    return true;
                }
            }
        }
    }
    return false;
};
exports.RETRYABLE_ERR_FN_DEFAULT = RETRYABLE_ERR_FN_DEFAULT;





class Storage extends index_js_1.Service {
    getBucketsStream() {

        return new stream_1.Readable();
    }
    getHmacKeysStream() {

        return new stream_1.Readable();
    }
    
    
    
    
    
    
    
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const universe = options.universeDomain || google_auth_library_1.DEFAULT_UNIVERSE;
        let apiEndpoint = `https://storage.${universe}`;
        let customEndpoint = false;

        const EMULATOR_HOST = process.env.STORAGE_EMULATOR_HOST;
        if (typeof EMULATOR_HOST === 'string') {
            apiEndpoint = Storage.sanitizeEndpoint(EMULATOR_HOST);
            customEndpoint = true;
        }
        if (options.apiEndpoint && options.apiEndpoint !== apiEndpoint) {
            apiEndpoint = Storage.sanitizeEndpoint(options.apiEndpoint);
            customEndpoint = true;
        }
        options = Object.assign({}, options, { apiEndpoint });

        const baseUrl = EMULATOR_HOST || `${options.apiEndpoint}/storage/v1`;
        const config = {
            apiEndpoint: options.apiEndpoint,
            retryOptions: {
                autoRetry: ((_a = options.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined
                    ? (_b = options.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry
                    : exports.AUTO_RETRY_DEFAULT,
                maxRetries: ((_c = options.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetries)
                    ? (_d = options.retryOptions) === null || _d === void 0 ? void 0 : _d.maxRetries
                    : exports.MAX_RETRY_DEFAULT,
                retryDelayMultiplier: ((_e = options.retryOptions) === null || _e === void 0 ? void 0 : _e.retryDelayMultiplier)
                    ? (_f = options.retryOptions) === null || _f === void 0 ? void 0 : _f.retryDelayMultiplier
                    : exports.RETRY_DELAY_MULTIPLIER_DEFAULT,
                totalTimeout: ((_g = options.retryOptions) === null || _g === void 0 ? void 0 : _g.totalTimeout)
                    ? (_h = options.retryOptions) === null || _h === void 0 ? void 0 : _h.totalTimeout
                    : exports.TOTAL_TIMEOUT_DEFAULT,
                maxRetryDelay: ((_j = options.retryOptions) === null || _j === void 0 ? void 0 : _j.maxRetryDelay)
                    ? (_k = options.retryOptions) === null || _k === void 0 ? void 0 : _k.maxRetryDelay
                    : exports.MAX_RETRY_DELAY_DEFAULT,
                retryableErrorFn: ((_l = options.retryOptions) === null || _l === void 0 ? void 0 : _l.retryableErrorFn)
                    ? (_m = options.retryOptions) === null || _m === void 0 ? void 0 : _m.retryableErrorFn
                    : exports.RETRYABLE_ERR_FN_DEFAULT,
                idempotencyStrategy: ((_o = options.retryOptions) === null || _o === void 0 ? void 0 : _o.idempotencyStrategy) !== undefined
                    ? (_p = options.retryOptions) === null || _p === void 0 ? void 0 : _p.idempotencyStrategy
                    : IDEMPOTENCY_STRATEGY_DEFAULT,
            },
            baseUrl,
            customEndpoint,
            useAuthWithCustomEndpoint: options === null || options === void 0 ? void 0 : options.useAuthWithCustomEndpoint,
            projectIdRequired: false,
            scopes: [
                'https://www.googleapis.com/auth/iam',
                'https://www.googleapis.com/auth/cloud-platform',
                'https://www.googleapis.com/auth/devstorage.full_control',
            ],
            packageJson: (0, package_json_helper_cjs_1.getPackageJSON)(),
        };
        super(config, options);
        
        this.acl = Storage.acl;
        this.crc32cGenerator =
            options.crc32cGenerator || crc32c_js_1.CRC32C_DEFAULT_VALIDATOR_GENERATOR;
        this.retryOptions = config.retryOptions;
        this.getBucketsStream = paginator_1.paginator.streamify('getBuckets');
        this.getHmacKeysStream = paginator_1.paginator.streamify('getHmacKeys');
    }
    static sanitizeEndpoint(url) {
        if (!exports.PROTOCOL_REGEX.test(url)) {
            url = `https://${url}`;
        }
        return url.replace(/\/+$/, ''); // Remove trailing slashes
    }
    
    bucket(name, options) {
        if (!name) {
            throw new Error(StorageExceptionMessages.BUCKET_NAME_REQUIRED);
        }
        return new bucket_js_1.Bucket(this, name, options);
    }
    
    channel(id, resourceId) {
        return new channel_js_1.Channel(this, id, resourceId);
    }
    
    
    
    
    createBucket(name, metadataOrCallback, callback) {
        if (!name) {
            throw new Error(StorageExceptionMessages.BUCKET_NAME_REQUIRED_CREATE);
        }
        let metadata;
        if (!callback) {
            callback = metadataOrCallback;
            metadata = {};
        }
        else {
            metadata = metadataOrCallback;
        }
        const body = {
            ...metadata,
            name,
        };
        const storageClasses = {
            archive: 'ARCHIVE',
            coldline: 'COLDLINE',
            dra: 'DURABLE_REDUCED_AVAILABILITY',
            multiRegional: 'MULTI_REGIONAL',
            nearline: 'NEARLINE',
            regional: 'REGIONAL',
            standard: 'STANDARD',
        };
        const storageClassKeys = Object.keys(storageClasses);
        for (const storageClass of storageClassKeys) {
            if (body[storageClass]) {
                if (metadata.storageClass && metadata.storageClass !== storageClass) {
                    throw new Error(`Both \`${storageClass}\` and \`storageClass\` were provided.`);
                }
                body.storageClass = storageClasses[storageClass];
                delete body[storageClass];
            }
        }
        if (body.requesterPays) {
            body.billing = {
                requesterPays: body.requesterPays,
            };
            delete body.requesterPays;
        }
        const query = {
            project: this.projectId,
        };
        if (body.userProject) {
            query.userProject = body.userProject;
            delete body.userProject;
        }
        if (body.enableObjectRetention) {
            query.enableObjectRetention = body.enableObjectRetention;
            delete body.enableObjectRetention;
        }
        if (body.predefinedAcl) {
            query.predefinedAcl = body.predefinedAcl;
            delete body.predefinedAcl;
        }
        if (body.predefinedDefaultObjectAcl) {
            query.predefinedDefaultObjectAcl = body.predefinedDefaultObjectAcl;
            delete body.predefinedDefaultObjectAcl;
        }
        if (body.projection) {
            query.projection = body.projection;
            delete body.projection;
        }
        this.request({
            method: 'POST',
            uri: '/b',
            qs: query,
            json: body,
        }, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
            }
            const bucket = this.bucket(name);
            bucket.metadata = resp;
            callback(null, bucket, resp);
        });
    }
    
    
    
    
    
    createHmacKey(serviceAccountEmail, optionsOrCb, cb) {
        if (typeof serviceAccountEmail !== 'string') {
            throw new Error(StorageExceptionMessages.HMAC_SERVICE_ACCOUNT);
        }
        const { options, callback } = (0, util_js_1.normalize)(optionsOrCb, cb);
        const query = Object.assign({}, options, { serviceAccountEmail });
        const projectId = query.projectId || this.projectId;
        delete query.projectId;
        this.request({
            method: 'POST',
            uri: `/projects/${projectId}/hmacKeys`,
            qs: query,
            maxRetries: 0, //explicitly set this value since this is a non-idempotent function
        }, (err, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const metadata = resp.metadata;
            const hmacKey = this.hmacKey(metadata.accessId, {
                projectId: metadata.projectId,
            });
            hmacKey.metadata = resp.metadata;
            callback(null, hmacKey, resp.secret, resp);
        });
    }
    
    
    
    
    getBuckets(optionsOrCallback, cb) {
        const { options, callback } = (0, util_js_1.normalize)(optionsOrCallback, cb);
        options.project = options.project || this.projectId;
        this.request({
            uri: '/b',
            qs: options,
        }, (err, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const itemsArray = resp.items ? resp.items : [];
            const buckets = itemsArray.map((bucket) => {
                const bucketInstance = this.bucket(bucket.id);
                bucketInstance.metadata = bucket;
                return bucketInstance;
            });
            const nextQuery = resp.nextPageToken
                ? Object.assign({}, options, { pageToken: resp.nextPageToken })
                : null;
            callback(null, buckets, nextQuery, resp);
        });
    }
    getHmacKeys(optionsOrCb, cb) {
        const { options, callback } = (0, util_js_1.normalize)(optionsOrCb, cb);
        const query = Object.assign({}, options);
        const projectId = query.projectId || this.projectId;
        delete query.projectId;
        this.request({
            uri: `/projects/${projectId}/hmacKeys`,
            qs: query,
        }, (err, resp) => {
            if (err) {
                callback(err, null, null, resp);
                return;
            }
            const itemsArray = resp.items ? resp.items : [];
            const hmacKeys = itemsArray.map((hmacKey) => {
                const hmacKeyInstance = this.hmacKey(hmacKey.accessId, {
                    projectId: hmacKey.projectId,
                });
                hmacKeyInstance.metadata = hmacKey;
                return hmacKeyInstance;
            });
            const nextQuery = resp.nextPageToken
                ? Object.assign({}, options, { pageToken: resp.nextPageToken })
                : null;
            callback(null, hmacKeys, nextQuery, resp);
        });
    }
    
    
    
    getServiceAccount(optionsOrCallback, cb) {
        const { options, callback } = (0, util_js_1.normalize)(optionsOrCallback, cb);
        this.request({
            uri: `/projects/${this.projectId}/serviceAccount`,
            qs: options,
        }, (err, resp) => {
            if (err) {
                callback(err, null, resp);
                return;
            }
            const camelCaseResponse = {};
            for (const prop in resp) {

                if (resp.hasOwnProperty(prop)) {
                    const camelCaseProp = prop.replace(/_(\w)/g, (_, match) => match.toUpperCase());
                    camelCaseResponse[camelCaseProp] = resp[prop];
                }
            }
            callback(null, camelCaseResponse, resp);
        });
    }
    
    hmacKey(accessId, options) {
        if (!accessId) {
            throw new Error(StorageExceptionMessages.HMAC_ACCESS_ID);
        }
        return new hmacKey_js_1.HmacKey(this, accessId, options);
    }
}
exports.Storage = Storage;

Storage.Bucket = bucket_js_1.Bucket;

Storage.Channel = channel_js_1.Channel;

Storage.File = file_js_1.File;

Storage.HmacKey = hmacKey_js_1.HmacKey;
Storage.acl = {
    OWNER_ROLE: 'OWNER',
    READER_ROLE: 'READER',
    WRITER_ROLE: 'WRITER',
};

paginator_1.paginator.extend(Storage, ['getBuckets', 'getHmacKeys']);

(0, promisify_1.promisifyAll)(Storage, {
    exclude: ['bucket', 'channel', 'hmacKey'],
});

