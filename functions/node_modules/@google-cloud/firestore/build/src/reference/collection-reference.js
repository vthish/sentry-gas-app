"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionReference = void 0;
const path_1 = require("../path");
const util_1 = require("../util");
const write_batch_1 = require("../write-batch");
const types_1 = require("../types");
const query_1 = require("./query");
const document_reference_1 = require("./document-reference");
const query_options_1 = require("./query-options");
const trace_util_1 = require("../telemetry/trace-util");

class CollectionReference extends query_1.Query {
    
    constructor(firestore, path, converter) {
        super(firestore, query_options_1.QueryOptions.forCollectionQuery(path, converter));
    }
    
    get _resourcePath() {
        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);
    }
    
    get id() {
        return this._queryOptions.collectionId;
    }
    
    get parent() {
        if (this._queryOptions.parentPath.isDocument) {
            return new document_reference_1.DocumentReference(this.firestore, this._queryOptions.parentPath);
        }
        return null;
    }
    
    get path() {
        return this._resourcePath.relativeName;
    }
    
    listDocuments() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_LIST_DOCUMENTS, () => {
            const tag = (0, util_1.requestTag)();
            return this.firestore.initializeIfNeeded(tag).then(() => {
                const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId, this.firestore.databaseId);
                const request = {
                    parent: parentPath.formattedName,
                    collectionId: this.id,
                    showMissing: true,
                    mask: { fieldPaths: [] },
                };
                return this.firestore
                    .request('listDocuments', request, tag)
                    .then(documents => {


                    return documents.map(doc => {
                        const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);
                        return this.doc(path.id);
                    });
                });
            });
        });
    }
    
    doc(documentPath) {
        if (arguments.length === 0) {
            documentPath = (0, util_1.autoId)();
        }
        else {
            (0, path_1.validateResourcePath)('documentPath', documentPath);
        }
        const path = this._resourcePath.append(documentPath);
        if (!path.isDocument) {
            throw new Error(`Value for argument "documentPath" must point to a document, but was "${documentPath}". Your path does not contain an even number of components.`);
        }
        return new document_reference_1.DocumentReference(this.firestore, path, this._queryOptions.converter);
    }
    
    add(data) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_COL_REF_ADD, () => {
            const firestoreData = this._queryOptions.converter.toFirestore(data);
            (0, write_batch_1.validateDocumentData)('data', firestoreData, 
             false, this._allowUndefined);
            const documentRef = this.doc();
            return documentRef.create(data).then(() => documentRef);
        });
    }
    
    isEqual(other) {
        return (this === other ||
            (other instanceof CollectionReference && super.isEqual(other)));
    }
    
    withConverter(converter) {
        return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
    }
}
exports.CollectionReference = CollectionReference;

