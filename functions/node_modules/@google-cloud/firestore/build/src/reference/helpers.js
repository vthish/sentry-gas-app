"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.validateQueryOrder = validateQueryOrder;
exports.validateQueryOperator = validateQueryOperator;
exports.validateDocumentReference = validateDocumentReference;
exports.validateQueryValue = validateQueryValue;
exports.coalesce = coalesce;
const validate_1 = require("../validate");
const serializer_1 = require("../serializer");
const document_reference_1 = require("./document-reference");
const constants_1 = require("./constants");

function validateQueryOrder(arg, op) {

    op = typeof op === 'string' ? op.toLowerCase() : op;
    (0, validate_1.validateEnumValue)(arg, op, Object.keys(constants_1.directionOperators), { optional: true });
    return op;
}

function validateQueryOperator(arg, op, fieldValue) {

    if (op === '=') {
        op = '==';
    }
    (0, validate_1.validateEnumValue)(arg, op, Object.keys(constants_1.comparisonOperators));
    if (typeof fieldValue === 'number' &&
        isNaN(fieldValue) &&
        op !== '==' &&
        op !== '!=') {
        throw new Error("Invalid query. You can only perform '==' and '!=' comparisons on NaN.");
    }
    if (fieldValue === null && op !== '==' && op !== '!=') {
        throw new Error("Invalid query. You can only perform '==' and '!=' comparisons on Null.");
    }
    return op;
}

function validateDocumentReference(arg, value) {
    if (!(value instanceof document_reference_1.DocumentReference)) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentReference'));
    }
    return value;
}

function validateQueryValue(arg, value, allowUndefined) {
    (0, serializer_1.validateUserInput)(arg, value, 'query constraint', {
        allowDeletes: 'none',
        allowTransforms: false,
        allowUndefined,
    });
}

function coalesce(...values) {
    return values.find(value => value !== undefined);
}

