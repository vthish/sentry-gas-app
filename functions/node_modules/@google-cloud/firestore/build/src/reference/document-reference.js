"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentReference = void 0;
const index_1 = require("../index");
const path_1 = require("../path");
const types_1 = require("../types");
const collection_reference_1 = require("./collection-reference");
const util_1 = require("../util");
const validate_1 = require("../validate");
const document_1 = require("../document");
const trace_util_1 = require("../telemetry/trace-util");

class DocumentReference {
    
    constructor(_firestore, 
    
    _path, 
    
    _converter = (0, types_1.defaultConverter)()) {
        this._firestore = _firestore;
        this._path = _path;
        this._converter = _converter;
    }
    
    get formattedName() {
        const projectId = this.firestore.projectId;
        const databaseId = this.firestore.databaseId;
        return this._path.toQualifiedResourcePath(projectId, databaseId)
            .formattedName;
    }
    
    get firestore() {
        return this._firestore;
    }
    
    get path() {
        return this._path.relativeName;
    }
    
    get id() {
        return this._path.id;
    }
    
    get _resourcePath() {
        return this._path;
    }
    
    get parent() {
        return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);
    }
    
    get() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, () => {
            return this._firestore.getAll(this).then(([result]) => result);
        });
    }
    
    collection(collectionPath) {
        (0, path_1.validateResourcePath)('collectionPath', collectionPath);
        const path = this._path.append(collectionPath);
        if (!path.isCollection) {
            throw new Error(`Value for argument "collectionPath" must point to a collection, but was "${collectionPath}". Your path does not contain an odd number of components.`);
        }
        return new collection_reference_1.CollectionReference(this._firestore, path);
    }
    
    listCollections() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, () => {
            const tag = (0, util_1.requestTag)();
            return this.firestore.initializeIfNeeded(tag).then(() => {
                const request = {
                    parent: this.formattedName,
                };
                return this._firestore
                    .request('listCollectionIds', request, tag)
                    .then(collectionIds => {
                    const collections = [];


                    collectionIds.sort();
                    for (const collectionId of collectionIds) {
                        collections.push(this.collection(collectionId));
                    }
                    return collections;
                });
            });
        });
    }
    
    create(data) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, () => {
            const writeBatch = new index_1.WriteBatch(this._firestore);
            return writeBatch
                .create(this, data)
                .commit()
                .then(([writeResult]) => writeResult);
        });
    }
    
    delete(precondition) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, () => {
            const writeBatch = new index_1.WriteBatch(this._firestore);
            return writeBatch
                .delete(this, precondition)
                .commit()
                .then(([writeResult]) => writeResult);
        });
    }
    
    set(data, options) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, () => {
            let writeBatch = new index_1.WriteBatch(this._firestore);
            if (options) {
                writeBatch = writeBatch.set(this, data, options);
            }
            else {
                writeBatch = writeBatch.set(this, data);
            }
            return writeBatch.commit().then(([writeResult]) => writeResult);
        });
    }
    
    update(dataOrField, ...preconditionOrValues) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, () => {

            (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);
            const writeBatch = new index_1.WriteBatch(this._firestore);
            return writeBatch
                .update(this, dataOrField, ...preconditionOrValues)
                .commit()
                .then(([writeResult]) => writeResult);
        });
    }
    
    onSnapshot(onNext, onError) {
        (0, validate_1.validateFunction)('onNext', onNext);
        (0, validate_1.validateFunction)('onError', onError, { optional: true });
        const watch = new (require('../watch').DocumentWatch)(this.firestore, this);
        return watch.onSnapshot((readTime, size, docs) => {
            for (const document of docs()) {
                if (document.ref.path === this.path) {
                    onNext(document);
                    return;
                }
            }

            const ref = new DocumentReference(this._firestore, this._path, this._converter);
            const document = new document_1.DocumentSnapshotBuilder(ref);
            document.readTime = readTime;
            onNext(document.build());
        }, onError || console.error);
    }
    
    isEqual(other) {
        return (this === other ||
            (other instanceof DocumentReference &&
                this._firestore === other._firestore &&
                this._path.isEqual(other._path) &&
                this._converter === other._converter));
    }
    
    toProto() {
        return { referenceValue: this.formattedName };
    }
    
    withConverter(converter) {
        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
    }
}
exports.DocumentReference = DocumentReference;

