"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = void 0;
const stream_1 = require("stream");
const query_util_1 = require("./query-util");
const index_1 = require("../index");
const field_order_1 = require("./field-order");
const field_filter_internal_1 = require("./field-filter-internal");
const composite_filter_internal_1 = require("./composite-filter-internal");
const constants_1 = require("./constants");
const document_reference_1 = require("./document-reference");
const query_snapshot_1 = require("./query-snapshot");
const serializer_1 = require("../serializer");
const query_profile_1 = require("../query-profile");
const filter_1 = require("../filter");
const path_1 = require("../path");
const helpers_1 = require("./helpers");
const validate_1 = require("../validate");
const types_1 = require("./types");
const aggregate_query_1 = require("./aggregate-query");
const vector_query_1 = require("./vector-query");
const order_1 = require("../order");
const types_2 = require("../types");
const trace_util_1 = require("../telemetry/trace-util");

class Query {
    
    constructor(
    
    _firestore, 
    
    _queryOptions) {
        this._firestore = _firestore;
        this._queryOptions = _queryOptions;
        this._serializer = new serializer_1.Serializer(_firestore);
        this._allowUndefined =
            !!this._firestore._settings.ignoreUndefinedProperties;
        this._queryUtil = new query_util_1.QueryUtil(_firestore, _queryOptions, this._serializer);
    }
    
    static _extractFieldValues(documentSnapshot, fieldOrders) {
        const fieldValues = [];
        for (const fieldOrder of fieldOrders) {
            if (index_1.FieldPath.documentId().isEqual(fieldOrder.field)) {
                fieldValues.push(documentSnapshot.ref);
            }
            else {
                const fieldValue = documentSnapshot.get(fieldOrder.field);
                if (fieldValue === undefined) {
                    throw new Error(`Field "${fieldOrder.field}" is missing in the provided DocumentSnapshot. ` +
                        'Please provide a document that contains values for all specified ' +
                        'orderBy() and where() constraints.');
                }
                else {
                    fieldValues.push(fieldValue);
                }
            }
        }
        return fieldValues;
    }
    
    get firestore() {
        return this._firestore;
    }
    where(fieldPathOrFilter, opStr, value) {
        let filter;
        if (fieldPathOrFilter instanceof index_1.Filter) {
            filter = fieldPathOrFilter;
        }
        else {
            filter = index_1.Filter.where(fieldPathOrFilter, opStr, value);
        }
        if (this._queryOptions.startAt || this._queryOptions.endAt) {
            throw new Error('Cannot specify a where() filter after calling startAt(), ' +
                'startAfter(), endBefore() or endAt().');
        }
        const parsedFilter = this._parseFilter(filter);
        if (parsedFilter.getFilters().length === 0) {

            return this;
        }
        const options = this._queryOptions.with({
            filters: this._queryOptions.filters.concat(parsedFilter),
        });
        return new Query(this._firestore, options);
    }
    
    _parseFilter(filter) {
        if (filter instanceof filter_1.UnaryFilter) {
            return this._parseFieldFilter(filter);
        }
        return this._parseCompositeFilter(filter);
    }
    
    _parseFieldFilter(fieldFilterData) {
        let value = fieldFilterData._getValue();
        let operator = fieldFilterData._getOperator();
        const fieldPath = fieldFilterData._getField();
        (0, path_1.validateFieldPath)('fieldPath', fieldPath);
        operator = (0, helpers_1.validateQueryOperator)('opStr', operator, value);
        (0, helpers_1.validateQueryValue)('value', value, this._allowUndefined);
        const path = index_1.FieldPath.fromArgument(fieldPath);
        if (index_1.FieldPath.documentId().isEqual(path)) {
            if (operator === 'array-contains' || operator === 'array-contains-any') {
                throw new Error(`Invalid Query. You can't perform '${operator}' ` +
                    'queries on FieldPath.documentId().');
            }
            else if (operator === 'in' || operator === 'not-in') {
                if (!Array.isArray(value) || value.length === 0) {
                    throw new Error(`Invalid Query. A non-empty array is required for '${operator}' filters.`);
                }
                value = value.map(el => this.validateReference(el));
            }
            else {
                value = this.validateReference(value);
            }
        }
        return new field_filter_internal_1.FieldFilterInternal(this._serializer, path, constants_1.comparisonOperators[operator], value);
    }
    
    _parseCompositeFilter(compositeFilterData) {
        const parsedFilters = compositeFilterData
            ._getFilters()
            .map(filter => this._parseFilter(filter))
            .filter(parsedFilter => parsedFilter.getFilters().length > 0);


        if (parsedFilters.length === 1) {
            return parsedFilters[0];
        }
        return new composite_filter_internal_1.CompositeFilterInternal(parsedFilters, compositeFilterData._getOperator() === 'AND' ? 'AND' : 'OR');
    }
    
    select(...fieldPaths) {
        const fields = [];
        if (fieldPaths.length === 0) {
            fields.push({ fieldPath: index_1.FieldPath.documentId().formattedName });
        }
        else {
            for (let i = 0; i < fieldPaths.length; ++i) {
                (0, path_1.validateFieldPath)(i, fieldPaths[i]);
                fields.push({
                    fieldPath: index_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,
                });
            }
        }


        const options = this._queryOptions.with({
            projection: { fields },
        });
        return new Query(this._firestore, options);
    }
    
    orderBy(fieldPath, directionStr) {
        (0, path_1.validateFieldPath)('fieldPath', fieldPath);
        directionStr = (0, helpers_1.validateQueryOrder)('directionStr', directionStr);
        if (this._queryOptions.startAt || this._queryOptions.endAt) {
            throw new Error('Cannot specify an orderBy() constraint after calling ' +
                'startAt(), startAfter(), endBefore() or endAt().');
        }
        const newOrder = new field_order_1.FieldOrder(index_1.FieldPath.fromArgument(fieldPath), constants_1.directionOperators[directionStr || 'asc']);
        const options = this._queryOptions.with({
            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),
        });
        return new Query(this._firestore, options);
    }
    
    limit(limit) {
        (0, validate_1.validateInteger)('limit', limit);
        const options = this._queryOptions.with({
            limit,
            limitType: types_1.LimitType.First,
        });
        return new Query(this._firestore, options);
    }
    
    limitToLast(limit) {
        (0, validate_1.validateInteger)('limitToLast', limit);
        const options = this._queryOptions.with({ limit, limitType: types_1.LimitType.Last });
        return new Query(this._firestore, options);
    }
    
    offset(offset) {
        (0, validate_1.validateInteger)('offset', offset);
        const options = this._queryOptions.with({ offset });
        return new Query(this._firestore, options);
    }
    
    count() {
        return this.aggregate({
            count: index_1.AggregateField.count(),
        });
    }
    
    aggregate(aggregateSpec) {
        return new aggregate_query_1.AggregateQuery(this, aggregateSpec);
    }
    findNearest(vectorFieldOrOptions, queryVector, options) {
        if (typeof vectorFieldOrOptions === 'string' ||
            vectorFieldOrOptions instanceof index_1.FieldPath) {
            const vqOptions = {
                distanceMeasure: options.distanceMeasure,
                limit: options.limit,
                queryVector: queryVector,
                vectorField: vectorFieldOrOptions,
            };
            return this._findNearest(vqOptions);
        }
        else {
            return this._findNearest(vectorFieldOrOptions);
        }
    }
    _findNearest(options) {
        (0, path_1.validateFieldPath)('vectorField', options.vectorField);
        if (options.limit <= 0) {
            throw (0, validate_1.invalidArgumentMessage)('limit', 'positive limit number');
        }
        if ((Array.isArray(options.queryVector)
            ? options.queryVector.length
            : options.queryVector.toArray().length) === 0) {
            throw (0, validate_1.invalidArgumentMessage)('queryVector', 'vector size must be larger than 0');
        }
        return new vector_query_1.VectorQuery(this, options);
    }
    
    isEqual(other) {
        if (this === other) {
            return true;
        }
        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));
    }
    
    getInequalityFilterFields() {
        const inequalityFields = [];
        for (const filter of this._queryOptions.filters) {
            for (const subFilter of filter.getFlattenedFilters()) {
                if (subFilter.isInequalityFilter()) {
                    inequalityFields.push(subFilter.field);
                }
            }
        }
        return inequalityFields.sort((a, b) => a.compareTo(b));
    }
    
    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {

        if (cursorValuesOrDocumentSnapshot.length !== 1 ||
            !(cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot)) {
            return this._queryOptions.fieldOrders;
        }
        const fieldOrders = this._queryOptions.fieldOrders.slice();
        const fieldsNormalized = new Set([
            ...fieldOrders.map(item => item.field.toString()),
        ]);
        
        const lastDirection = fieldOrders.length === 0
            ? constants_1.directionOperators.ASC
            : fieldOrders[fieldOrders.length - 1].direction;
        
        const inequalityFields = this.getInequalityFilterFields();
        for (const field of inequalityFields) {
            if (!fieldsNormalized.has(field.toString()) &&
                !field.isEqual(index_1.FieldPath.documentId())) {
                fieldOrders.push(new field_order_1.FieldOrder(field, lastDirection));
                fieldsNormalized.add(field.toString());
            }
        }

        if (!fieldsNormalized.has(index_1.FieldPath.documentId().toString())) {
            fieldOrders.push(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));
        }
        return fieldOrders;
    }
    
    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {
        let fieldValues;
        if (cursorValuesOrDocumentSnapshot.length === 1 &&
            cursorValuesOrDocumentSnapshot[0] instanceof index_1.DocumentSnapshot) {
            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);
        }
        else {
            fieldValues = cursorValuesOrDocumentSnapshot;
        }
        if (fieldValues.length > fieldOrders.length) {
            throw new Error('Too many cursor values specified. The specified ' +
                'values must match the orderBy() constraints of the query.');
        }
        const options = { values: [], before };
        for (let i = 0; i < fieldValues.length; ++i) {
            let fieldValue = fieldValues[i];
            if (index_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {
                fieldValue = this.validateReference(fieldValue);
            }
            (0, helpers_1.validateQueryValue)(i, fieldValue, this._allowUndefined);
            options.values.push(this._serializer.encodeValue(fieldValue));
        }
        return options;
    }
    
    validateReference(val) {
        const basePath = this._queryOptions.allDescendants
            ? this._queryOptions.parentPath
            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);
        let reference;
        if (typeof val === 'string') {
            const path = basePath.append(val);
            if (this._queryOptions.allDescendants) {
                if (!path.isDocument) {
                    throw new Error('When querying a collection group and ordering by ' +
                        'FieldPath.documentId(), the corresponding value must result in ' +
                        `a valid document path, but '${val}' is not because it ` +
                        'contains an odd number of segments.');
                }
            }
            else if (val.indexOf('/') !== -1) {
                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +
                    `the corresponding value must be a plain document ID, but '${val}' ` +
                    'contains a slash.');
            }
            reference = new document_reference_1.DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);
        }
        else if (val instanceof document_reference_1.DocumentReference) {
            reference = val;
            if (!basePath.isPrefixOf(reference._path)) {
                throw new Error(`"${reference.path}" is not part of the query result set and ` +
                    'cannot be used as a query boundary.');
            }
        }
        else {
            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +
                `string or a DocumentReference, but was "${val}".`);
        }
        if (!this._queryOptions.allDescendants &&
            reference._path.parent().compareTo(basePath) !== 0) {
            throw new Error('Only a direct child can be used as a query boundary. ' +
                `Found: "${reference.path}".`);
        }
        return reference;
    }
    
    startAt(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);
        const options = this._queryOptions.with({ fieldOrders, startAt });
        return new Query(this._firestore, options);
    }
    
    startAfter(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);
        const options = this._queryOptions.with({ fieldOrders, startAt });
        return new Query(this._firestore, options);
    }
    
    endBefore(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);
        const options = this._queryOptions.with({ fieldOrders, endAt });
        return new Query(this._firestore, options);
    }
    
    endAt(...fieldValuesOrDocumentSnapshot) {
        (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);
        const options = this._queryOptions.with({ fieldOrders, endAt });
        return new Query(this._firestore, options);
    }
    
    async get() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_QUERY_GET, async () => {
            const { result } = await this._get();
            return result;
        });
    }
    
    async explain(options) {
        if (options === undefined) {
            options = {};
        }
        const { result, explainMetrics } = await this._getResponse(undefined, options);
        if (!explainMetrics) {
            throw new Error('No explain results');
        }
        return new query_profile_1.ExplainResults(explainMetrics, result || null);
    }
    
    async _get(transactionOrReadTime) {
        const result = await this._getResponse(transactionOrReadTime);
        if (!result.result) {
            throw new Error('No QuerySnapshot result');
        }
        return result;
    }
    _getResponse(transactionOrReadTime, explainOptions) {
        return this._queryUtil._getResponse(this, transactionOrReadTime, true, explainOptions);
    }
    
    stream() {
        return this._queryUtil.stream(this);
    }
    
    explainStream(explainOptions) {
        if (explainOptions === undefined) {
            explainOptions = {};
        }
        if (this._queryOptions.limitType === types_1.LimitType.Last) {
            throw new Error('Query results for queries that include limitToLast() ' +
                'constraints cannot be streamed. Use Query.explain() instead.');
        }
        const responseStream = this._stream(undefined, explainOptions);
        const transform = new stream_1.Transform({
            objectMode: true,
            transform(chunk, encoding, callback) {
                if (chunk.document || chunk.explainMetrics) {
                    callback(undefined, {
                        document: chunk.document,
                        metrics: chunk.explainMetrics,
                    });
                }
            },
        });
        responseStream.pipe(transform);
        responseStream.on('error', e => transform.destroy(e));
        return transform;
    }
    
    toCursor(cursor) {
        if (cursor) {
            return cursor.before
                ? { before: true, values: cursor.values }
                : { values: cursor.values };
        }
        return undefined;
    }
    
    toProto(transactionOrReadTime, explainOptions) {
        const projectId = this.firestore.projectId;
        const databaseId = this.firestore.databaseId;
        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);
        const structuredQuery = this.toStructuredQuery();


        if (this._queryOptions.limitType === types_1.LimitType.Last) {
            if (!this._queryOptions.hasFieldOrders()) {
                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');
            }
            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {

                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';
                return new field_order_1.FieldOrder(order.field, dir).toProto();
            });

            structuredQuery.startAt = this._queryOptions.endAt
                ? this.toCursor({
                    values: this._queryOptions.endAt.values,
                    before: !this._queryOptions.endAt.before,
                })
                : undefined;
            structuredQuery.endAt = this._queryOptions.startAt
                ? this.toCursor({
                    values: this._queryOptions.startAt.values,
                    before: !this._queryOptions.startAt.before,
                })
                : undefined;
        }
        const runQueryRequest = {
            parent: parentPath.formattedName,
            structuredQuery,
        };
        if (transactionOrReadTime instanceof Uint8Array) {
            runQueryRequest.transaction = transactionOrReadTime;
        }
        else if (transactionOrReadTime instanceof index_1.Timestamp) {
            runQueryRequest.readTime = transactionOrReadTime.toProto().timestampValue;
        }
        else if (transactionOrReadTime) {
            runQueryRequest.newTransaction = transactionOrReadTime;
        }
        if (explainOptions) {
            runQueryRequest.explainOptions = explainOptions;
        }
        return runQueryRequest;
    }
    
    _toBundledQuery() {
        const projectId = this.firestore.projectId;
        const databaseId = this.firestore.databaseId;
        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);
        const structuredQuery = this.toStructuredQuery();
        const bundledQuery = {
            parent: parentPath.formattedName,
            structuredQuery,
        };
        if (this._queryOptions.limitType === types_1.LimitType.First) {
            bundledQuery.limitType = 'FIRST';
        }
        else if (this._queryOptions.limitType === types_1.LimitType.Last) {
            bundledQuery.limitType = 'LAST';
        }
        return bundledQuery;
    }
    toStructuredQuery() {
        const structuredQuery = {
            from: [{}],
        };
        if (this._queryOptions.allDescendants) {
            structuredQuery.from[0].allDescendants = true;
        }


        if (!this._queryOptions.kindless) {
            structuredQuery.from[0].collectionId = this._queryOptions.collectionId;
        }
        if (this._queryOptions.filters.length >= 1) {
            structuredQuery.where = new composite_filter_internal_1.CompositeFilterInternal(this._queryOptions.filters, 'AND').toProto();
        }
        if (this._queryOptions.hasFieldOrders()) {
            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());
        }
        structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);
        structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);
        if (this._queryOptions.limit) {
            structuredQuery.limit = { value: this._queryOptions.limit };
        }
        structuredQuery.offset = this._queryOptions.offset;
        structuredQuery.select = this._queryOptions.projection;
        return structuredQuery;
    }
    
    _isPermanentRpcError(err, methodName) {
        return this._queryUtil._isPermanentRpcError(err, methodName);
    }
    
    _hasRetryTimedOut(methodName, startTime) {
        return this._queryUtil._hasRetryTimedOut(methodName, startTime);
    }
    
    _stream(transactionOrReadTime, explainOptions) {
        return this._queryUtil._stream(this, transactionOrReadTime, true, explainOptions);
    }
    
    onSnapshot(onNext, onError) {
        (0, validate_1.validateFunction)('onNext', onNext);
        (0, validate_1.validateFunction)('onError', onError, { optional: true });
        const watch = new (require('../watch').QueryWatch)(this.firestore, this, this._queryOptions.converter);
        return watch.onSnapshot((readTime, size, docs, changes) => {
            onNext(new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes));
        }, onError || console.error);
    }
    
    comparator() {
        return (doc1, doc2) => {

            const lastDirection = this._queryOptions.hasFieldOrders()
                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction
                : 'ASCENDING';
            const orderBys = this._queryOptions.fieldOrders.concat(new field_order_1.FieldOrder(index_1.FieldPath.documentId(), lastDirection));
            for (const orderBy of orderBys) {
                let comp;
                if (index_1.FieldPath.documentId().isEqual(orderBy.field)) {
                    comp = doc1.ref._path.compareTo(doc2.ref._path);
                }
                else {
                    const v1 = doc1.protoField(orderBy.field);
                    const v2 = doc2.protoField(orderBy.field);
                    if (v1 === undefined || v2 === undefined) {
                        throw new Error('Trying to compare documents on fields that ' +
                            "don't exist. Please include the fields you are ordering on " +
                            'in your select() call.');
                    }
                    comp = (0, order_1.compare)(v1, v2);
                }
                if (comp !== 0) {
                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;
                    return direction * comp;
                }
            }
            return 0;
        };
    }
    
    withConverter(converter) {
        return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_2.defaultConverter)()));
    }
    
    _createSnapshot(readTime, size, docs, changes) {
        return new query_snapshot_1.QuerySnapshot(this, readTime, size, docs, changes);
    }
}
exports.Query = Query;

