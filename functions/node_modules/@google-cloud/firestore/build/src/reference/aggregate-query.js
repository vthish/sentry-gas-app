"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateQuery = void 0;
const assert = require("assert");
const deepEqual = require("fast-deep-equal");
const aggregate_1 = require("../aggregate");
const timestamp_1 = require("../timestamp");
const util_1 = require("../util");
const query_profile_1 = require("../query-profile");
const logger_1 = require("../logger");
const aggregate_query_snapshot_1 = require("./aggregate-query-snapshot");
const stream_1 = require("stream");
const trace_util_1 = require("../telemetry/trace-util");

class AggregateQuery {
    
    constructor(

    _query, _aggregates) {
        this._query = _query;
        this._aggregates = _aggregates;
        this.clientAliasToServerAliasMap = {};
        this.serverAliasToClientAliasMap = {};



        let aggregationNum = 0;
        for (const clientAlias in this._aggregates) {
            if (Object.prototype.hasOwnProperty.call(this._aggregates, clientAlias)) {
                const serverAlias = `aggregate_${aggregationNum++}`;
                this.clientAliasToServerAliasMap[clientAlias] = serverAlias;
                this.serverAliasToClientAliasMap[serverAlias] = clientAlias;
            }
        }
    }
    
    get query() {
        return this._query;
    }
    
    async get() {
        return this._query._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_AGGREGATION_QUERY_GET, async () => {
            const { result } = await this._get();
            return result;
        });
    }
    
    async _get(transactionOrReadTime) {
        const response = await this._getResponse(transactionOrReadTime);
        if (!response.result) {
            throw new Error('No AggregateQuery results');
        }
        return response;
    }
    
    _getResponse(transactionOrReadTime, explainOptions) {

        const stack = Error().stack;
        return new Promise((resolve, reject) => {
            const output = {};
            const stream = this._stream(transactionOrReadTime, explainOptions);
            stream.on('error', err => {
                reject((0, util_1.wrapError)(err, stack));
            });
            stream.on('data', (data) => {
                if (data.transaction) {
                    output.transaction = data.transaction;
                }
                if (data.explainMetrics) {
                    output.explainMetrics = data.explainMetrics;
                }
                if (data.result) {
                    output.result = data.result;
                }
            });
            stream.on('end', () => {
                stream.destroy();
                resolve(output);
            });
        });
    }
    
    _stream(transactionOrReadTime, explainOptions) {
        const tag = (0, util_1.requestTag)();
        const firestore = this._query.firestore;
        const stream = new stream_1.Transform({
            objectMode: true,
            transform: (proto, enc, callback) => {
                var _a;
                const output = {};

                if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {
                    output.transaction = proto.transaction;
                }
                if (proto.explainMetrics) {
                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, firestore._serializer);
                }
                if (proto.result) {
                    const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);
                    const data = this.decodeResult(proto.result);
                    output.result = new aggregate_query_snapshot_1.AggregateQuerySnapshot(this, readTime, data);
                }
                callback(undefined, output);
            },
        });
        firestore
            .initializeIfNeeded(tag)
            .then(async () => {



            const request = this.toProto(transactionOrReadTime, explainOptions);
            const backendStream = await firestore.requestStream('runAggregationQuery', 
             false, request, tag);
            stream.on('close', () => {
                backendStream.resume();
                backendStream.end();
            });
            backendStream.on('error', err => {





                backendStream.unpipe(stream);
                (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);
                this._query._firestore._traceUtil
                    .currentSpan()
                    .addEvent(`${trace_util_1.SPAN_NAME_RUN_AGGREGATION_QUERY}: Error.`, {
                    'error.message': err.message,
                });
                stream.destroy(err);
            });
            backendStream.resume();
            backendStream.pipe(stream);
        })
            .catch(e => stream.destroy(e));
        return stream;
    }
    
    decodeResult(proto) {

        const data = {};
        const fields = proto.aggregateFields;
        if (fields) {
            const serializer = this._query.firestore._serializer;
            for (const prop of Object.keys(fields)) {
                const alias = this.serverAliasToClientAliasMap[prop];
                assert(alias !== null && alias !== undefined, `'${prop}' not present in server-client alias mapping.`);
                if (this._aggregates[alias] === undefined) {
                    throw new Error(`Unexpected alias [${prop}] in result aggregate result`);
                }
                data[alias] = serializer.decodeValue(fields[prop]);
            }
        }
        return data;
    }
    
    toProto(transactionOrReadTime, explainOptions) {
        const queryProto = this._query.toProto();
        const runQueryRequest = {
            parent: queryProto.parent,
            structuredAggregationQuery: {
                structuredQuery: queryProto.structuredQuery,
                aggregations: (0, util_1.mapToArray)(this._aggregates, (aggregate, clientAlias) => {
                    const serverAlias = this.clientAliasToServerAliasMap[clientAlias];
                    assert(serverAlias !== null && serverAlias !== undefined, `'${clientAlias}' not present in client-server alias mapping.`);
                    return new aggregate_1.Aggregate(serverAlias, aggregate.aggregateType, aggregate._field).toProto();
                }),
            },
        };
        if (transactionOrReadTime instanceof Uint8Array) {
            runQueryRequest.transaction = transactionOrReadTime;
        }
        else if (transactionOrReadTime instanceof timestamp_1.Timestamp) {
            runQueryRequest.readTime = transactionOrReadTime.toProto().timestampValue;
        }
        else if (transactionOrReadTime) {
            runQueryRequest.newTransaction = transactionOrReadTime;
        }
        if (explainOptions) {
            runQueryRequest.explainOptions = explainOptions;
        }
        return runQueryRequest;
    }
    
    isEqual(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof AggregateQuery)) {
            return false;
        }
        if (!this.query.isEqual(other.query)) {
            return false;
        }
        return deepEqual(this._aggregates, other._aggregates);
    }
    
    async explain(options) {
        const { result, explainMetrics } = await this._getResponse(undefined, options || {});
        if (!explainMetrics) {
            throw new Error('No explain results');
        }
        return new query_profile_1.ExplainResults(explainMetrics, result || null);
    }
}
exports.AggregateQuery = AggregateQuery;

