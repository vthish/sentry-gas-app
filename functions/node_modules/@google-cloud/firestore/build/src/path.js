"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldPath = exports.QualifiedResourcePath = exports.ResourcePath = exports.DEFAULT_DATABASE_ID = void 0;
exports.validateResourcePath = validateResourcePath;
exports.validateFieldPath = validateFieldPath;
const order_1 = require("./order");
const util_1 = require("./util");
const validate_1 = require("./validate");

exports.DEFAULT_DATABASE_ID = '(default)';

const RESOURCE_PATH_RE = 

/^projects\/([^/]*)\/databases\/([^/]*)(?:\/documents\/)?([\s\S]*)$/;

const UNESCAPED_FIELD_NAME_RE = /^[_a-zA-Z][_a-zA-Z0-9]*$/;

const FIELD_PATH_RE = /^[^*~/[\]]+$/;

class Path {
    
    constructor(segments) {
        this.segments = segments;
    }
    
    get size() {
        return this.segments.length;
    }
    
    append(relativePath) {
        if (relativePath instanceof Path) {
            return this.construct(this.segments.concat(relativePath.segments));
        }
        return this.construct(this.segments.concat(this.split(relativePath)));
    }
    
    parent() {
        if (this.segments.length === 0) {
            return null;
        }
        return this.construct(this.segments.slice(0, this.segments.length - 1));
    }
    
    isPrefixOf(other) {
        if (other.segments.length < this.segments.length) {
            return false;
        }
        for (let i = 0; i < this.segments.length; i++) {
            if (this.segments[i] !== other.segments[i]) {
                return false;
            }
        }
        return true;
    }
    
    compareTo(other) {
        const len = Math.min(this.segments.length, other.segments.length);
        for (let i = 0; i < len; i++) {
            const comparison = this.compareSegments(this.segments[i], other.segments[i]);
            if (comparison !== 0) {
                return comparison;
            }
        }
        return (0, order_1.primitiveComparator)(this.segments.length, other.segments.length);
    }
    compareSegments(lhs, rhs) {
        const isLhsNumeric = this.isNumericId(lhs);
        const isRhsNumeric = this.isNumericId(rhs);
        if (isLhsNumeric && !isRhsNumeric) {

            return -1;
        }
        else if (!isLhsNumeric && isRhsNumeric) {

            return 1;
        }
        else if (isLhsNumeric && isRhsNumeric) {

            return this.compareNumbers(this.extractNumericId(lhs), this.extractNumericId(rhs));
        }
        else {

            return (0, order_1.compareUtf8Strings)(lhs, rhs);
        }
    }

    isNumericId(segment) {
        return segment.startsWith('__id') && segment.endsWith('__');
    }

    extractNumericId(segment) {
        return BigInt(segment.substring(4, segment.length - 2));
    }
    compareNumbers(lhs, rhs) {
        if (lhs < rhs) {
            return -1;
        }
        else if (lhs > rhs) {
            return 1;
        }
        else {
            return 0;
        }
    }
    
    toArray() {
        return this.segments.slice();
    }
    
    popLast() {
        this.segments.pop();
        return this.construct(this.segments);
    }
    
    isEqual(other) {
        return this === other || this.compareTo(other) === 0;
    }
}

class ResourcePath extends Path {
    
    constructor(...segments) {
        super(segments);
    }
    
    get isDocument() {
        return this.segments.length > 0 && this.segments.length % 2 === 0;
    }
    
    get isCollection() {
        return this.segments.length % 2 === 1;
    }
    
    get id() {
        if (this.segments.length > 0) {
            return this.segments[this.segments.length - 1];
        }
        return null;
    }
    
    get relativeName() {
        return this.segments.join('/');
    }
    
    construct(segments) {
        return new ResourcePath(...segments);
    }
    
    split(relativePath) {


        return relativePath.split('/').filter(segment => segment.length > 0);
    }
    
    toQualifiedResourcePath(projectId, databaseId) {
        return new QualifiedResourcePath(projectId, databaseId, ...this.segments);
    }
}
exports.ResourcePath = ResourcePath;

ResourcePath.EMPTY = new ResourcePath();

class QualifiedResourcePath extends ResourcePath {
    
    constructor(projectId, databaseId, ...segments) {
        super(...segments);
        this.projectId = projectId;
        this.databaseId = databaseId;
    }
    
    get relativeName() {
        return this.segments.join('/');
    }
    
    static fromSlashSeparatedString(absolutePath) {
        const elements = RESOURCE_PATH_RE.exec(absolutePath);
        if (elements) {
            const project = elements[1];
            const database = elements[2];
            const path = elements[3];
            return new QualifiedResourcePath(project, database).append(path);
        }
        throw new Error(`Resource name '${absolutePath}' is not valid.`);
    }
    
    append(relativePath) {


        return super.append(relativePath);
    }
    
    parent() {
        return super.parent();
    }
    
    get formattedName() {
        const components = [
            'projects',
            this.projectId,
            'databases',
            this.databaseId,
            'documents',
            ...this.segments,
        ];
        return components.join('/');
    }
    
    construct(segments) {
        return new QualifiedResourcePath(this.projectId, this.databaseId, ...segments);
    }
    
    toQualifiedResourcePath() {
        return this;
    }
    
    compareTo(other) {
        if (other instanceof QualifiedResourcePath) {
            if (this.projectId < other.projectId) {
                return -1;
            }
            if (this.projectId > other.projectId) {
                return 1;
            }
            if (this.databaseId < other.databaseId) {
                return -1;
            }
            if (this.databaseId > other.databaseId) {
                return 1;
            }
        }
        return super.compareTo(other);
    }
    
    toProto() {
        return {
            referenceValue: this.formattedName,
        };
    }
}
exports.QualifiedResourcePath = QualifiedResourcePath;

function validateResourcePath(arg, resourcePath) {
    if (typeof resourcePath !== 'string' || resourcePath === '') {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'resource path')} Path must be a non-empty string.`);
    }
    if (resourcePath.indexOf('//') >= 0) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'resource path')} Paths must not contain //.`);
    }
}

class FieldPath extends Path {
    
    constructor(...segments) {
        if (Array.isArray(segments[0])) {
            throw new Error('The FieldPath constructor no longer supports an array as its first argument. ' +
                'Please unpack your array and call FieldPath() with individual arguments.');
        }
        (0, validate_1.validateMinNumberOfArguments)('FieldPath', segments, 1);
        for (let i = 0; i < segments.length; ++i) {
            (0, validate_1.validateString)(i, segments[i]);
            if (segments[i].length === 0) {
                throw new Error(`Element at index ${i} should not be an empty string.`);
            }
        }
        super(segments);
    }
    
    static documentId() {
        return FieldPath._DOCUMENT_ID;
    }
    
    static fromArgument(fieldPath) {


        return fieldPath instanceof FieldPath
            ? fieldPath
            : new FieldPath(...fieldPath.split('.'));
    }
    
    get formattedName() {
        return this.segments
            .map(str => {
            return UNESCAPED_FIELD_NAME_RE.test(str)
                ? str
                : '`' + str.replace(/\\/g, '\\\\').replace(/`/g, '\\`') + '`';
        })
            .join('.');
    }
    
    toString() {
        return this.formattedName;
    }
    
    split(fieldPath) {
        return fieldPath.split('.');
    }
    
    construct(segments) {
        return new FieldPath(...segments);
    }
    
    isEqual(other) {
        return super.isEqual(other);
    }
}
exports.FieldPath = FieldPath;

FieldPath._DOCUMENT_ID = new FieldPath('__name__');

function validateFieldPath(arg, fieldPath) {
    if (fieldPath instanceof FieldPath) {
        return;
    }
    if (fieldPath === undefined) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'field path') + ' The path cannot be omitted.');
    }
    if ((0, util_1.isObject)(fieldPath) && fieldPath.constructor.name === 'FieldPath') {
        throw new Error((0, validate_1.customObjectMessage)(arg, fieldPath));
    }
    if (typeof fieldPath !== 'string') {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths can only be specified as strings or via a FieldPath object.`);
    }
    if (fieldPath.indexOf('..') >= 0) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths must not contain ".." in them.`);
    }
    if (fieldPath.startsWith('.') || fieldPath.endsWith('.')) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths must not start or end with ".".`);
    }
    if (!FIELD_PATH_RE.test(fieldPath)) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'field path')} Paths can't be empty and must not contain
    "*~/[]".`);
    }
}

