"use strict";













Object.defineProperty(exports, "__esModule", { value: true });
exports.BundleBuilder = void 0;
const document_1 = require("./document");
const query_snapshot_1 = require("./reference/query-snapshot");
const timestamp_1 = require("./timestamp");
const validate_1 = require("./validate");
const BUNDLE_VERSION = 1;

class BundleBuilder {
    constructor(bundleId) {
        this.bundleId = bundleId;

        this.documents = new Map();

        this.namedQueries = new Map();

        this.latestReadTime = new timestamp_1.Timestamp(0, 0);
    }
    
    add(documentOrName, querySnapshot) {

        (0, validate_1.validateMinNumberOfArguments)('BundleBuilder.add', arguments, 1);

        (0, validate_1.validateMaxNumberOfArguments)('BundleBuilder.add', arguments, 2);
        if (arguments.length === 1) {
            validateDocumentSnapshot('documentOrName', documentOrName);
            this.addBundledDocument(documentOrName);
        }
        else {
            (0, validate_1.validateString)('documentOrName', documentOrName);
            validateQuerySnapshot('querySnapshot', querySnapshot);
            this.addNamedQuery(documentOrName, querySnapshot);
        }
        return this;
    }
    addBundledDocument(snap, queryName) {
        const originalDocument = this.documents.get(snap.ref.path);
        const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;

        if (!originalDocument ||
            timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {
            const docProto = snap.toDocumentProto();
            this.documents.set(snap.ref.path, {
                document: snap.exists ? docProto : undefined,
                metadata: {
                    name: docProto.name,
                    readTime: snap.readTime.toProto().timestampValue,
                    exists: snap.exists,
                },
            });
        }

        const newDocument = this.documents.get(snap.ref.path);
        newDocument.metadata.queries = originalQueries || [];
        if (queryName) {
            newDocument.metadata.queries.push(queryName);
        }
        if (snap.readTime > this.latestReadTime) {
            this.latestReadTime = snap.readTime;
        }
    }
    addNamedQuery(name, querySnap) {
        if (this.namedQueries.has(name)) {
            throw new Error(`Query name conflict: ${name} has already been added.`);
        }
        this.namedQueries.set(name, {
            name,
            bundledQuery: querySnap.query._toBundledQuery(),
            readTime: querySnap.readTime.toProto().timestampValue,
        });
        for (const snap of querySnap.docs) {
            this.addBundledDocument(snap, name);
        }
        if (querySnap.readTime > this.latestReadTime) {
            this.latestReadTime = querySnap.readTime;
        }
    }
    
    elementToLengthPrefixedBuffer(bundleElement) {




        const message = require('../protos/firestore_v1_proto_api')
            .firestore.BundleElement.fromObject(bundleElement)
            .toJSON();
        const buffer = Buffer.from(JSON.stringify(message), 'utf-8');
        const lengthBuffer = Buffer.from(buffer.length.toString());
        return Buffer.concat([lengthBuffer, buffer]);
    }
    build() {
        let bundleBuffer = Buffer.alloc(0);
        for (const namedQuery of this.namedQueries.values()) {
            bundleBuffer = Buffer.concat([
                bundleBuffer,
                this.elementToLengthPrefixedBuffer({ namedQuery }),
            ]);
        }
        for (const bundledDocument of this.documents.values()) {
            const documentMetadata = bundledDocument.metadata;
            bundleBuffer = Buffer.concat([
                bundleBuffer,
                this.elementToLengthPrefixedBuffer({ documentMetadata }),
            ]);

            const document = bundledDocument.document;
            if (document) {
                bundleBuffer = Buffer.concat([
                    bundleBuffer,
                    this.elementToLengthPrefixedBuffer({ document }),
                ]);
            }
        }
        const metadata = {
            id: this.bundleId,
            createTime: this.latestReadTime.toProto().timestampValue,
            version: BUNDLE_VERSION,
            totalDocuments: this.documents.size,
            totalBytes: bundleBuffer.length,
        };

        bundleBuffer = Buffer.concat([
            this.elementToLengthPrefixedBuffer({ metadata }),
            bundleBuffer,
        ]);
        return bundleBuffer;
    }
}
exports.BundleBuilder = BundleBuilder;

class BundledDocument {
    constructor(metadata, document) {
        this.metadata = metadata;
        this.document = document;
    }
}

function validateDocumentSnapshot(arg, value) {
    if (!(value instanceof document_1.DocumentSnapshot)) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentSnapshot'));
    }
}

function validateQuerySnapshot(arg, value) {
    if (!(value instanceof query_snapshot_1.QuerySnapshot)) {
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'QuerySnapshot'));
    }
}

