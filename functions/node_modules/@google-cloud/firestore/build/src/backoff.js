"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ExponentialBackoff = exports.delayExecution = exports.MAX_RETRY_ATTEMPTS = exports.DEFAULT_BACKOFF_FACTOR = exports.DEFAULT_BACKOFF_MAX_DELAY_MS = exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = void 0;
exports.setTimeoutHandler = setTimeoutHandler;
const logger_1 = require("./logger");


exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;

exports.DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;

exports.DEFAULT_BACKOFF_FACTOR = 1.5;

const DEFAULT_JITTER_FACTOR = 1.0;

exports.MAX_RETRY_ATTEMPTS = 10;

exports.delayExecution = setTimeout;

function setTimeoutHandler(handler) {
    exports.delayExecution = (f, ms) => {
        handler(f, ms);
        const timeout = {
            hasRef: () => {
                throw new Error('For tests only. Not Implemented');
            },
            ref: () => {
                throw new Error('For tests only. Not Implemented');
            },
            refresh: () => {
                throw new Error('For tests only. Not Implemented');
            },
            unref: () => {
                throw new Error('For tests only. Not Implemented');
            },
            [Symbol.toPrimitive]: () => {
                throw new Error('For tests only. Not Implemented');
            },
        };





        return timeout;
    };
}

class ExponentialBackoff {
    constructor(options = {}) {
        
        this._retryCount = 0;
        
        this.currentBaseMs = 0;
        
        this.awaitingBackoffCompletion = false;
        this.initialDelayMs =
            options.initialDelayMs !== undefined
                ? options.initialDelayMs
                : exports.DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        this.backoffFactor =
            options.backoffFactor !== undefined
                ? options.backoffFactor
                : exports.DEFAULT_BACKOFF_FACTOR;
        this.maxDelayMs =
            options.maxDelayMs !== undefined
                ? options.maxDelayMs
                : exports.DEFAULT_BACKOFF_MAX_DELAY_MS;
        this.jitterFactor =
            options.jitterFactor !== undefined
                ? options.jitterFactor
                : DEFAULT_JITTER_FACTOR;
    }
    
    reset() {
        this._retryCount = 0;
        this.currentBaseMs = 0;
    }
    
    resetToMax() {
        this.currentBaseMs = this.maxDelayMs;
    }
    
    backoffAndWait() {
        if (this.awaitingBackoffCompletion) {
            return Promise.reject(new Error('A backoff operation is already in progress.'));
        }
        if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {
            return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));
        }


        const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();
        if (this.currentBaseMs > 0) {
            (0, logger_1.logger)('ExponentialBackoff.backoffAndWait', null, `Backing off for ${delayWithJitterMs} ms ` +
                `(base delay: ${this.currentBaseMs} ms)`);
        }


        this.currentBaseMs *= this.backoffFactor;
        this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);
        this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);
        this._retryCount += 1;
        return new Promise(resolve => {
            this.awaitingBackoffCompletion = true;
            (0, exports.delayExecution)(() => {
                this.awaitingBackoffCompletion = false;
                resolve();
            }, delayWithJitterMs);
        });
    }

    get retryCount() {
        return this._retryCount;
    }
    
    jitterDelayMs() {
        return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;
    }
}
exports.ExponentialBackoff = ExponentialBackoff;

