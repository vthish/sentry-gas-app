"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteTransform = exports.FieldTransform = exports.FieldValue = exports.VectorValue = void 0;
const deepEqual = require("fast-deep-equal");
const serializer_1 = require("./serializer");
const util_1 = require("./util");
const validate_1 = require("./validate");

class VectorValue {
    
    constructor(values) {

        this._values = (values || []).map(n => n);
    }
    
    toArray() {
        return this._values.map(n => n);
    }
    
    _toProto(serializer) {
        return serializer.encodeVector(this._values);
    }
    
    static _fromProto(valueArray) {
        var _a, _b;
        const values = (_b = (_a = valueArray.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map(v => {
            return v.doubleValue;
        });
        return new VectorValue(values);
    }
    
    isEqual(other) {
        return (0, util_1.isPrimitiveArrayEqual)(this._values, other._values);
    }
}
exports.VectorValue = VectorValue;

class FieldValue {
    
    constructor() { }
    
    static vector(values) {
        return new VectorValue(values);
    }
    
    static delete() {
        return DeleteTransform.DELETE_SENTINEL;
    }
    
    static serverTimestamp() {
        return ServerTimestampTransform.SERVER_TIMESTAMP_SENTINEL;
    }
    
    static increment(n) {

        (0, validate_1.validateMinNumberOfArguments)('FieldValue.increment', arguments, 1);
        return new NumericIncrementTransform(n);
    }
    
    static arrayUnion(...elements) {
        (0, validate_1.validateMinNumberOfArguments)('FieldValue.arrayUnion', elements, 1);
        return new ArrayUnionTransform(elements);
    }
    
    static arrayRemove(...elements) {
        (0, validate_1.validateMinNumberOfArguments)('FieldValue.arrayRemove', elements, 1);
        return new ArrayRemoveTransform(elements);
    }
    
    isEqual(other) {
        return this === other;
    }
}
exports.FieldValue = FieldValue;

class FieldTransform extends FieldValue {
}
exports.FieldTransform = FieldTransform;

class DeleteTransform extends FieldTransform {
    constructor() {
        super();
    }
    
    get includeInDocumentMask() {
        return true;
    }
    
    get includeInDocumentTransform() {
        return false;
    }
    get methodName() {
        return 'FieldValue.delete';
    }
    validate() { }
    toProto() {
        throw new Error('FieldValue.delete() should not be included in a FieldTransform');
    }
}
exports.DeleteTransform = DeleteTransform;

DeleteTransform.DELETE_SENTINEL = new DeleteTransform();

class ServerTimestampTransform extends FieldTransform {
    constructor() {
        super();
    }
    
    get includeInDocumentMask() {
        return false;
    }
    
    get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.serverTimestamp';
    }
    validate() { }
    toProto(serializer, fieldPath) {
        return {
            fieldPath: fieldPath.formattedName,
            setToServerValue: 'REQUEST_TIME',
        };
    }
}

ServerTimestampTransform.SERVER_TIMESTAMP_SENTINEL = new ServerTimestampTransform();

class NumericIncrementTransform extends FieldTransform {
    constructor(operand) {
        super();
        this.operand = operand;
    }
    
    get includeInDocumentMask() {
        return false;
    }
    
    get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.increment';
    }
    validate() {
        (0, validate_1.validateNumber)('FieldValue.increment()', this.operand);
    }
    toProto(serializer, fieldPath) {
        const encodedOperand = serializer.encodeValue(this.operand);
        return { fieldPath: fieldPath.formattedName, increment: encodedOperand };
    }
    isEqual(other) {
        return (this === other ||
            (other instanceof NumericIncrementTransform &&
                this.operand === other.operand));
    }
}

class ArrayUnionTransform extends FieldTransform {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    
    get includeInDocumentMask() {
        return false;
    }
    
    get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.arrayUnion';
    }
    validate(allowUndefined) {
        for (let i = 0; i < this.elements.length; ++i) {
            validateArrayElement(i, this.elements[i], allowUndefined);
        }
    }
    toProto(serializer, fieldPath) {
        const encodedElements = serializer.encodeValue(this.elements).arrayValue;
        return {
            fieldPath: fieldPath.formattedName,
            appendMissingElements: encodedElements,
        };
    }
    isEqual(other) {
        return (this === other ||
            (other instanceof ArrayUnionTransform &&
                deepEqual(this.elements, other.elements)));
    }
}

class ArrayRemoveTransform extends FieldTransform {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    
    get includeInDocumentMask() {
        return false;
    }
    
    get includeInDocumentTransform() {
        return true;
    }
    get methodName() {
        return 'FieldValue.arrayRemove';
    }
    validate(allowUndefined) {
        for (let i = 0; i < this.elements.length; ++i) {
            validateArrayElement(i, this.elements[i], allowUndefined);
        }
    }
    toProto(serializer, fieldPath) {
        const encodedElements = serializer.encodeValue(this.elements).arrayValue;
        return {
            fieldPath: fieldPath.formattedName,
            removeAllFromArray: encodedElements,
        };
    }
    isEqual(other) {
        return (this === other ||
            (other instanceof ArrayRemoveTransform &&
                deepEqual(this.elements, other.elements)));
    }
}

function validateArrayElement(arg, value, allowUndefined) {
    if (Array.isArray(value)) {
        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'array element')} Nested arrays are not supported.`);
    }
    (0, serializer_1.validateUserInput)(arg, value, 'array element', 
     { allowDeletes: 'none', allowTransforms: false, allowUndefined }, 
     undefined, 
     0, 
     true);
}

