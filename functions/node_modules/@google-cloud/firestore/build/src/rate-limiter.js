"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimiter = void 0;

const assert = require("assert");
const logger_1 = require("./logger");

class RateLimiter {
    
    constructor(initialCapacity, multiplier, multiplierMillis, maximumCapacity, startTimeMillis = Date.now()) {
        this.initialCapacity = initialCapacity;
        this.multiplier = multiplier;
        this.multiplierMillis = multiplierMillis;
        this.maximumCapacity = maximumCapacity;
        this.startTimeMillis = startTimeMillis;
        this.availableTokens = initialCapacity;
        this.lastRefillTimeMillis = startTimeMillis;
        this.previousCapacity = initialCapacity;
    }
    
    tryMakeRequest(numOperations, requestTimeMillis = Date.now()) {
        this.refillTokens(requestTimeMillis);
        if (numOperations <= this.availableTokens) {
            this.availableTokens -= numOperations;
            return true;
        }
        return false;
    }
    
    getNextRequestDelayMs(numOperations, requestTimeMillis = Date.now()) {
        this.refillTokens(requestTimeMillis);
        if (numOperations < this.availableTokens) {
            return 0;
        }
        const capacity = this.calculateCapacity(requestTimeMillis);
        if (capacity < numOperations) {
            return -1;
        }
        const requiredTokens = numOperations - this.availableTokens;
        return Math.ceil((requiredTokens * 1000) / capacity);
    }
    
    refillTokens(requestTimeMillis) {
        if (requestTimeMillis >= this.lastRefillTimeMillis) {
            const elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;
            const capacity = this.calculateCapacity(requestTimeMillis);
            const tokensToAdd = Math.floor((elapsedTime * capacity) / 1000);
            if (tokensToAdd > 0) {
                this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);
                this.lastRefillTimeMillis = requestTimeMillis;
            }
        }
        else {
            throw new Error('Request time should not be before the last token refill time.');
        }
    }
    

    calculateCapacity(requestTimeMillis) {
        assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');
        const millisElapsed = requestTimeMillis - this.startTimeMillis;
        const operationsPerSecond = Math.min(Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity), this.maximumCapacity);
        if (operationsPerSecond !== this.previousCapacity) {
            (0, logger_1.logger)('RateLimiter.calculateCapacity', null, `New request capacity: ${operationsPerSecond} operations per second.`);
        }
        this.previousCapacity = operationsPerSecond;
        return operationsPerSecond;
    }
}
exports.RateLimiter = RateLimiter;

