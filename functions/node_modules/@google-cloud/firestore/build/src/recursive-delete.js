"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecursiveDelete = exports.RECURSIVE_DELETE_MIN_PENDING_OPS = exports.RECURSIVE_DELETE_MAX_PENDING_OPS = exports.REFERENCE_NAME_MIN_ID = void 0;
const assert = require("assert");
const _1 = require(".");
const util_1 = require("./util");
const query_options_1 = require("./reference/query-options");

exports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';


exports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;

exports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;

class RecursiveDelete {
    
    constructor(firestore, writer, ref, maxLimit, minLimit) {
        this.firestore = firestore;
        this.writer = writer;
        this.ref = ref;
        this.maxLimit = maxLimit;
        this.minLimit = minLimit;
        
        this.errorCount = 0;
        
        this.documentsPending = true;
        
        this.started = false;
        
        this.completionDeferred = new util_1.Deferred();
        
        this.streamInProgress = false;
        
        this.pendingOpsCount = 0;
        this.errorStack = '';
        this.maxPendingOps = maxLimit;
        this.minPendingOps = minLimit;
    }
    
    run() {
        assert(!this.started, 'RecursiveDelete.run() should only be called once.');

        this.errorStack = Error().stack;
        this.writer._verifyNotClosed();
        this.setupStream();
        return this.completionDeferred.promise;
    }
    
    setupStream() {
        const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference
            ? this.ref
            : this.ref);
        this.streamInProgress = true;
        let streamedDocsCount = 0;
        stream
            .on('error', err => {
            err.code = 14 ;
            err.stack = 'Failed to fetch children documents: ' + err.stack;
            this.lastError = err;
            this.onQueryEnd();
        })
            .on('data', (snap) => {
            streamedDocsCount++;
            this.lastDocumentSnap = snap;
            this.deleteRef(snap.ref);
        })
            .on('end', () => {
            this.streamInProgress = false;


            if (streamedDocsCount < this.minPendingOps) {
                this.onQueryEnd();
            }
            else if (this.pendingOpsCount === 0) {
                this.setupStream();
            }
        });
    }
    
    getAllDescendants(ref) {





        let parentPath = ref._resourcePath;
        if (ref instanceof _1.CollectionReference) {
            parentPath = parentPath.popLast();
        }
        const collectionId = ref instanceof _1.CollectionReference
            ? ref.id
            : ref.parent.id;
        let query = new _1.Query(this.firestore, query_options_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, 
         false));

        query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);
        if (ref instanceof _1.CollectionReference) {





            const nullChar = String.fromCharCode(0);
            const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;
            const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;
            query = query
                .where(_1.FieldPath.documentId(), '>=', startAt)
                .where(_1.FieldPath.documentId(), '<', endAt);
        }
        if (this.lastDocumentSnap) {
            query = query.startAfter(this.lastDocumentSnap);
        }
        return query.stream();
    }
    
    onQueryEnd() {
        this.documentsPending = false;
        if (this.ref instanceof _1.DocumentReference) {
            this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));
        }
        this.writer.flush().then(async () => {
            var _a;
            if (this.lastError === undefined) {
                this.completionDeferred.resolve();
            }
            else {
                let error = new (require('google-gax/build/src/fallback').GoogleError)(`${this.errorCount} ` +
                    `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` +
                    'failed. The last delete failed with: ');
                if (this.lastError.code !== undefined) {
                    error.code = this.lastError.code;
                }
                error = (0, util_1.wrapError)(error, this.errorStack);

                this.completionDeferred.reject(this.lastError.stack
                    ? (0, util_1.wrapError)(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '')
                    : error);
            }
        });
    }
    
    deleteRef(docRef) {
        this.pendingOpsCount++;
        this.writer
            .delete(docRef)
            .catch(err => {
            this.incrementErrorCount(err);
        })
            .then(() => {
            this.pendingOpsCount--;




            if (this.documentsPending &&
                !this.streamInProgress &&
                this.pendingOpsCount < this.minPendingOps) {
                this.setupStream();
            }
        });
    }
    incrementErrorCount(err) {
        this.errorCount++;
        this.lastError = err;
    }
}
exports.RecursiveDelete = RecursiveDelete;

