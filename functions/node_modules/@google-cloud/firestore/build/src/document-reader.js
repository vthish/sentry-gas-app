"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentReader = void 0;
const document_1 = require("./document");
const util_1 = require("./util");
const logger_1 = require("./logger");
const timestamp_1 = require("./timestamp");

class DocumentReader {
    
    constructor(firestore, allDocuments, fieldMask, transactionOrReadTime) {
        this.firestore = firestore;
        this.allDocuments = allDocuments;
        this.fieldMask = fieldMask;
        this.transactionOrReadTime = transactionOrReadTime;
        this.outstandingDocuments = new Set();
        this.retrievedDocuments = new Map();
        for (const docRef of this.allDocuments) {
            this.outstandingDocuments.add(docRef.formattedName);
        }
    }
    
    async get(requestTag) {
        const { result } = await this._get(requestTag);
        return result;
    }
    
    async _get(requestTag) {
        await this.fetchDocuments(requestTag);


        const orderedDocuments = [];
        for (const docRef of this.allDocuments) {
            const document = this.retrievedDocuments.get(docRef.formattedName);
            if (document !== undefined) {


                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);
                finalDoc.fieldsProto = document._fieldsProto;
                finalDoc.readTime = document.readTime;
                finalDoc.createTime = document.createTime;
                finalDoc.updateTime = document.updateTime;
                orderedDocuments.push(finalDoc.build());
            }
            else {
                throw new Error(`Did not receive document for "${docRef.path}".`);
            }
        }
        return {
            result: orderedDocuments,
            transaction: this.retrievedTransactionId,
        };
    }
    async fetchDocuments(requestTag) {
        var _a;
        if (!this.outstandingDocuments.size) {
            return;
        }
        const request = {
            database: this.firestore.formattedName,
            documents: Array.from(this.outstandingDocuments),
        };
        if (this.transactionOrReadTime instanceof Uint8Array) {
            request.transaction = this.transactionOrReadTime;
        }
        else if (this.transactionOrReadTime instanceof timestamp_1.Timestamp) {
            request.readTime = this.transactionOrReadTime.toProto().timestampValue;
        }
        else if (this.transactionOrReadTime) {
            request.newTransaction = this.transactionOrReadTime;
        }
        if (this.fieldMask) {
            const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);
            request.mask = { fieldPaths };
        }
        let resultCount = 0;
        try {
            const stream = await this.firestore.requestStream('batchGetDocuments', 
             false, request, requestTag);
            stream.resume();
            for await (const response of stream) {

                if ((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.length) {
                    this.retrievedTransactionId = response.transaction;
                }
                let snapshot;
                if (response.found) {
                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);
                    snapshot = this.firestore.snapshot_(response.found, response.readTime);
                }
                else if (response.missing) {
                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);
                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);
                }
                if (snapshot) {
                    const path = snapshot.ref.formattedName;
                    this.outstandingDocuments.delete(path);
                    this.retrievedDocuments.set(path, snapshot);
                    ++resultCount;
                }
            }
        }
        catch (error) {
            const shouldRetry = 

            !request.transaction &&
                !request.newTransaction &&

                resultCount > 0 &&

                error.code !== undefined &&
                !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');
            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);
            if (shouldRetry) {
                return this.fetchDocuments(requestTag);
            }
            else {
                throw error;
            }
        }
        finally {
            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);
        }
    }
}
exports.DocumentReader = DocumentReader;

