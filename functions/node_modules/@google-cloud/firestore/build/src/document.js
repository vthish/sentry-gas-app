"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Precondition = exports.DocumentTransform = exports.DocumentMask = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.DocumentSnapshotBuilder = void 0;
const deepEqual = require("fast-deep-equal");
const assert = require("assert");
const field_value_1 = require("./field-value");
const path_1 = require("./path");
const document_reference_1 = require("./reference/document-reference");
const types_1 = require("./types");
const util_1 = require("./util");

class DocumentSnapshotBuilder {



    constructor(ref) {
        this.ref = ref;
    }
    
    build() {
        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');
        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');
        return this.fieldsProto
            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)
            : new DocumentSnapshot(this.ref, undefined, this.readTime);
    }
}
exports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;

class DocumentSnapshot {
    
    constructor(ref, 
    
    _fieldsProto, readTime, createTime, updateTime) {
        this._fieldsProto = _fieldsProto;
        this._ref = ref;
        this._serializer = ref.firestore._serializer;
        this._readTime = readTime;
        this._createTime = createTime;
        this._updateTime = updateTime;
    }
    
    static fromObject(ref, obj) {
        const serializer = ref.firestore._serializer;
        return new DocumentSnapshot(ref, serializer.encodeFields(obj));
    }
    
    static fromUpdateMap(ref, data) {
        const serializer = ref
            .firestore._serializer;
        
        function merge(target, value, path, pos) {
            const key = path[pos];
            const isLast = pos === path.length - 1;
            if (target[key] === undefined) {
                if (isLast) {
                    if (value instanceof field_value_1.FieldTransform) {


                        return !(0, util_1.isEmpty)(target) ? target : null;
                    }

                    const leafNode = serializer.encodeValue(value);
                    if (leafNode) {
                        target[key] = leafNode;
                    }
                    return target;
                }
                else {

                    const childNode = {
                        mapValue: {
                            fields: {},
                        },
                    };
                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);
                    if (nestedValue) {
                        childNode.mapValue.fields = nestedValue;
                        target[key] = childNode;
                        return target;
                    }
                    else {
                        return !(0, util_1.isEmpty)(target) ? target : null;
                    }
                }
            }
            else {
                assert(!isLast, "Can't merge current value into a nested object");
                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);
                return target;
            }
        }
        const res = {};
        for (const [key, value] of data) {
            const path = key.toArray();
            merge(res, value, path, 0);
        }
        return new DocumentSnapshot(ref, res);
    }
    
    get exists() {
        return this._fieldsProto !== undefined;
    }
    
    get ref() {
        return this._ref;
    }
    
    get id() {
        return this._ref.id;
    }
    
    get createTime() {
        return this._createTime;
    }
    
    get updateTime() {
        return this._updateTime;
    }
    
    get readTime() {
        if (this._readTime === undefined) {
            throw new Error("Called 'readTime' on a local document");
        }
        return this._readTime;
    }
    
    data() {
        const fields = this._fieldsProto;
        if (fields === undefined) {
            return undefined;
        }


        if (this.ref._converter !== (0, types_1.defaultConverter)()) {
            const untypedReference = new document_reference_1.DocumentReference(this.ref.firestore, this.ref._path);
            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));
        }
        else {
            const obj = {};
            for (const prop of Object.keys(fields)) {
                obj[prop] = this._serializer.decodeValue(fields[prop]);
            }
            return obj;
        }
    }
    



    get(field) {
        (0, path_1.validateFieldPath)('field', field);
        const protoField = this.protoField(field);
        if (protoField === undefined) {
            return undefined;
        }
        return this._serializer.decodeValue(protoField);
    }
    
    protoField(field) {
        let fields = this._fieldsProto;
        if (fields === undefined) {
            return undefined;
        }
        const components = path_1.FieldPath.fromArgument(field).toArray();
        while (components.length > 1) {
            fields = fields[components.shift()];
            if (!fields || !fields.mapValue) {
                return undefined;
            }
            fields = fields.mapValue.fields;
        }
        return fields[components[0]];
    }
    
    toWriteProto() {
        return {
            update: {
                name: this._ref.formattedName,
                fields: this._fieldsProto,
            },
        };
    }
    
    toDocumentProto() {
        var _a, _b;
        return {
            name: this._ref.formattedName,
            createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,
            updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,
            fields: this._fieldsProto,
        };
    }
    
    isEqual(other) {


        return (this === other ||
            (other instanceof DocumentSnapshot &&
                this._ref.isEqual(other._ref) &&
                deepEqual(this._fieldsProto, other._fieldsProto)));
    }
}
exports.DocumentSnapshot = DocumentSnapshot;

class QueryDocumentSnapshot extends DocumentSnapshot {
    
    get createTime() {
        return super.createTime;
    }
    
    get updateTime() {
        return super.updateTime;
    }
    
    data() {
        const data = super.data();
        if (!data) {
            throw new Error('The data in a QueryDocumentSnapshot should always exist.');
        }
        return data;
    }
}
exports.QueryDocumentSnapshot = QueryDocumentSnapshot;

class DocumentMask {
    
    constructor(fieldPaths) {
        this._sortedPaths = fieldPaths;
        this._sortedPaths.sort((a, b) => a.compareTo(b));
    }
    
    static fromUpdateMap(data) {
        const fieldPaths = [];
        data.forEach((value, key) => {
            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {
                fieldPaths.push(path_1.FieldPath.fromArgument(key));
            }
        });
        return new DocumentMask(fieldPaths);
    }
    
    static fromFieldMask(fieldMask) {
        const fieldPaths = [];
        for (const fieldPath of fieldMask) {
            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));
        }
        return new DocumentMask(fieldPaths);
    }
    
    static fromObject(data) {
        const fieldPaths = [];
        function extractFieldPaths(currentData, currentPath) {
            let isEmpty = true;
            for (const key of Object.keys(currentData)) {
                isEmpty = false;


                const childSegment = new path_1.FieldPath(key);
                const childPath = currentPath
                    ? currentPath.append(childSegment)
                    : childSegment;
                const value = currentData[key];
                if (value instanceof field_value_1.FieldTransform) {
                    if (value.includeInDocumentMask) {
                        fieldPaths.push(childPath);
                    }
                }
                else if ((0, util_1.isPlainObject)(value)) {
                    extractFieldPaths(value, childPath);
                }
                else if (value !== undefined) {




                    fieldPaths.push(childPath);
                }
            }

            if (currentPath && isEmpty) {
                fieldPaths.push(currentPath);
            }
        }
        extractFieldPaths(data);
        return new DocumentMask(fieldPaths);
    }
    
    get isEmpty() {
        return this._sortedPaths.length === 0;
    }
    
    static removeFromSortedArray(input, values) {
        for (let i = 0; i < input.length;) {
            let removed = false;
            for (const fieldPath of values) {
                if (input[i].isEqual(fieldPath)) {
                    input.splice(i, 1);
                    removed = true;
                    break;
                }
            }
            if (!removed) {
                ++i;
            }
        }
    }
    
    removeFields(fieldPaths) {
        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);
    }
    
    contains(fieldPath) {
        for (const sortedPath of this._sortedPaths) {
            const cmp = sortedPath.compareTo(fieldPath);
            if (cmp === 0) {
                return true;
            }
            else if (cmp > 0) {
                return false;
            }
        }
        return false;
    }
    
    applyTo(data) {
        
        const applyDocumentMask = data => {
            const remainingPaths = this._sortedPaths.slice(0);
            const processObject = (currentData, currentPath) => {
                let result = null;
                Object.keys(currentData).forEach(key => {
                    const childPath = currentPath
                        ? currentPath.append(key)
                        : new path_1.FieldPath(key);
                    if (this.contains(childPath)) {
                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);
                        result = result || {};
                        result[key] = currentData[key];
                    }
                    else if ((0, util_1.isObject)(currentData[key])) {
                        const childObject = processObject(currentData[key], childPath);
                        if (childObject) {
                            result = result || {};
                            result[key] = childObject;
                        }
                    }
                });
                return result;
            };

            const filteredData = processObject(data) || {};
            return {
                filteredData,
                remainingPaths,
            };
        };
        const result = applyDocumentMask(data);
        if (result.remainingPaths.length !== 0) {
            throw new Error(`Input data is missing for field "${result.remainingPaths[0]}".`);
        }
        return result.filteredData;
    }
    
    toProto() {
        if (this.isEmpty) {
            return {};
        }
        const encodedPaths = [];
        for (const fieldPath of this._sortedPaths) {
            encodedPaths.push(fieldPath.formattedName);
        }
        return {
            fieldPaths: encodedPaths,
        };
    }
}
exports.DocumentMask = DocumentMask;

class DocumentTransform {
    
    constructor(ref, transforms) {
        this.ref = ref;
        this.transforms = transforms;
    }
    
    static fromObject(ref, obj) {
        const updateMap = new Map();
        for (const prop of Object.keys(obj)) {
            updateMap.set(new path_1.FieldPath(prop), obj[prop]);
        }
        return DocumentTransform.fromUpdateMap(ref, updateMap);
    }
    
    static fromUpdateMap(ref, data) {
        const transforms = new Map();
        function encode_(val, path, allowTransforms) {
            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {
                if (allowTransforms) {
                    transforms.set(path, val);
                }
                else {
                    throw new Error(`${val.methodName}() is not supported inside of array values.`);
                }
            }
            else if (Array.isArray(val)) {
                for (let i = 0; i < val.length; ++i) {

                    encode_(val[i], path.append(String(i)), false);
                }
            }
            else if ((0, util_1.isPlainObject)(val)) {
                for (const prop of Object.keys(val)) {
                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);
                }
            }
        }
        data.forEach((value, key) => {
            encode_(value, path_1.FieldPath.fromArgument(key), true);
        });
        return new DocumentTransform(ref, transforms);
    }
    
    get isEmpty() {
        return this.transforms.size === 0;
    }
    
    get fields() {
        return Array.from(this.transforms.keys());
    }
    
    validate() {
        const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;
        this.transforms.forEach(transform => transform.validate(allowUndefined));
    }
    
    toProto(serializer) {
        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));
    }
}
exports.DocumentTransform = DocumentTransform;

class Precondition {
    
    constructor(options) {
        if (options !== undefined) {
            this._exists = options.exists;
            this._lastUpdateTime = options.lastUpdateTime;
        }
    }
    
    toProto() {
        if (this.isEmpty) {
            return null;
        }
        const proto = {};
        if (this._lastUpdateTime !== undefined) {
            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;
        }
        else {
            proto.exists = this._exists;
        }
        return proto;
    }
    
    get isEmpty() {
        return this._exists === undefined && !this._lastUpdateTime;
    }
}
exports.Precondition = Precondition;

