"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
exports.parseGetAllArguments = parseGetAllArguments;
const backoff_1 = require("./backoff");
const index_1 = require("./index");
const logger_1 = require("./logger");
const path_1 = require("./path");
const aggregate_query_1 = require("./reference/aggregate-query");
const document_reference_1 = require("./reference/document-reference");
const query_1 = require("./reference/query");
const helpers_1 = require("./reference/helpers");
const util_1 = require("./util");
const validate_1 = require("./validate");
const document_reader_1 = require("./document-reader");
const trace_util_1 = require("./telemetry/trace-util");

const READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';
const READ_ONLY_WRITE_ERROR_MSG = 'Firestore read-only transactions cannot execute writes.';

class Transaction {
    
    constructor(firestore, requestTag, transactionOptions) {
        this._maxAttempts = index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;
        this._firestore = firestore;
        this._requestTag = requestTag;
        if (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.readOnly) {

            this._maxAttempts = 1;
            this._readOnlyReadTime = transactionOptions.readTime;
        }
        else {
            this._maxAttempts =
                (transactionOptions === null || transactionOptions === void 0 ? void 0 : transactionOptions.maxAttempts) || index_1.DEFAULT_MAX_TRANSACTION_ATTEMPTS;
            this._writeBatch = firestore.batch();
            this._backoff = new backoff_1.ExponentialBackoff();
        }
    }
    
    get(refOrQuery) {
        if (this._writeBatch && !this._writeBatch.isEmpty) {
            throw new Error(READ_AFTER_WRITE_ERROR_MSG);
        }
        if (refOrQuery instanceof document_reference_1.DocumentReference) {
            return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENT, () => {
                return this.withLazyStartedTransaction(refOrQuery, this.getSingleFn);
            });
        }
        if (refOrQuery instanceof query_1.Query || refOrQuery instanceof aggregate_query_1.AggregateQuery) {
            return this._firestore._traceUtil.startActiveSpan(refOrQuery instanceof query_1.Query
                ? trace_util_1.SPAN_NAME_TRANSACTION_GET_QUERY
                : trace_util_1.SPAN_NAME_TRANSACTION_GET_AGGREGATION_QUERY, () => {
                return this.withLazyStartedTransaction(refOrQuery, this.getQueryFn);
            });
        }
        throw new Error('Value for argument "refOrQuery" must be a DocumentReference, Query, or AggregateQuery.');
    }
    
    getAll(...documentRefsOrReadOptions) {
        if (this._writeBatch && !this._writeBatch.isEmpty) {
            throw new Error(READ_AFTER_WRITE_ERROR_MSG);
        }
        (0, validate_1.validateMinNumberOfArguments)('Transaction.getAll', documentRefsOrReadOptions, 1);
        return this.withLazyStartedTransaction(parseGetAllArguments(documentRefsOrReadOptions), this.getBatchFn);
    }
    
    create(documentRef, data) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        this._writeBatch.create(documentRef, data);
        return this;
    }
    
    set(documentRef, data, options) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        if (options) {
            this._writeBatch.set(documentRef, data, options);
        }
        else {
            this._writeBatch.set(documentRef, data);
        }
        return this;
    }
    
    update(documentRef, dataOrField, ...preconditionOrValues) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }

        (0, validate_1.validateMinNumberOfArguments)('Transaction.update', arguments, 2);
        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);
        return this;
    }
    
    delete(

    documentRef, precondition) {
        if (!this._writeBatch) {
            throw new Error(READ_ONLY_WRITE_ERROR_MSG);
        }
        this._writeBatch.delete(documentRef, precondition);
        return this;
    }
    
    async commit() {
        var _a;
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_COMMIT, async () => {
            if (!this._writeBatch) {
                throw new Error(READ_ONLY_WRITE_ERROR_MSG);
            }


            let transactionId;
            if (this._transactionIdPromise) {
                transactionId = await this._transactionIdPromise;
            }
            else if (this._writeBatch.isEmpty) {


                return;
            }
            await this._writeBatch._commit({
                transactionId,
                requestTag: this._requestTag,
            });
            this._transactionIdPromise = undefined;
            this._prevTransactionId = transactionId;
        }, {
            [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: true,
            [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: (_a = this._writeBatch) === null || _a === void 0 ? void 0 : _a._opCount,
        });
    }
    
    async rollback() {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_ROLLBACK, async () => {


            if (!this._transactionIdPromise || !this._writeBatch) {
                return;
            }
            let transactionId;
            try {
                transactionId = await this._transactionIdPromise;
            }
            catch (_a) {


                this._transactionIdPromise = undefined;
                return;
            }
            const request = {
                database: this._firestore.formattedName,
                transaction: transactionId,
            };
            this._transactionIdPromise = undefined;
            this._prevTransactionId = transactionId;




            this._firestore
                .request('rollback', request, this._requestTag)
                .catch(err => {
                (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Best effort to rollback failed with error:', err);
            });
        });
    }
    
    async runTransaction(updateFunction) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_RUN, async (span) => {

            if (!this._writeBatch) {
                return this.runTransactionOnce(updateFunction);
            }
            let lastError = undefined;
            for (let attempt = 0; attempt < this._maxAttempts; ++attempt) {
                span.setAttributes({
                    [trace_util_1.ATTRIBUTE_KEY_TRANSACTION_TYPE]: this._writeBatch
                        ? 'READ_WRITE'
                        : 'READ_ONLY',
                    [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_ALLOWED]: this._maxAttempts,
                    [trace_util_1.ATTRIBUTE_KEY_ATTEMPTS_REMAINING]: this._maxAttempts - attempt - 1,
                });
                try {
                    if (lastError) {
                        (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);
                        span.addEvent('Initiate transaction retry');
                    }
                    this._writeBatch._reset();
                    await maybeBackoff(this._backoff, lastError);
                    return await this.runTransactionOnce(updateFunction);
                }
                catch (err) {
                    lastError = err;
                    if (!isRetryableTransactionError(err)) {
                        break;
                    }
                }
            }
            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);
            return Promise.reject(lastError);
        });
    }
    
    async runTransactionOnce(updateFunction) {
        try {
            const promise = updateFunction(this);
            if (!(promise instanceof Promise)) {
                throw new Error('You must return a Promise in your transaction()-callback.');
            }
            const result = await promise;
            if (this._writeBatch) {
                await this.commit();
            }
            return result;
        }
        catch (err) {
            (0, logger_1.logger)('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);
            await this.rollback();
            return Promise.reject(err);
        }
    }
    
    withLazyStartedTransaction(param, resultFn) {
        if (this._transactionIdPromise) {



            return this._transactionIdPromise
                .then(opts => resultFn.call(this, param, opts))
                .then(r => r.result);
        }
        else {
            if (this._readOnlyReadTime) {


                return resultFn
                    .call(this, param, this._readOnlyReadTime)
                    .then(r => r.result);
            }
            else {


                const opts = {};
                if (this._writeBatch) {
                    opts.readWrite = this._prevTransactionId
                        ? { retryTransaction: this._prevTransactionId }
                        : {};
                }
                else {
                    opts.readOnly = {};
                }
                const resultPromise = resultFn.call(this, param, opts);


                this._transactionIdPromise = resultPromise.then(r => {
                    if (!r.transaction) {



                        throw new Error('Transaction ID was missing from server response');
                    }
                    return r.transaction;
                });
                return resultPromise.then(r => r.result);
            }
        }
    }
    async getSingleFn(document, opts) {
        const documentReader = new document_reader_1.DocumentReader(this._firestore, [document], undefined, opts);
        const { transaction, result: [result], } = await documentReader._get(this._requestTag);
        return { transaction, result };
    }
    async getBatchFn({ documents, fieldMask, }, opts) {
        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_TRANSACTION_GET_DOCUMENTS, async () => {
            const documentReader = new document_reader_1.DocumentReader(this._firestore, documents, fieldMask, opts);
            return documentReader._get(this._requestTag);
        });
    }
    async getQueryFn(query, opts) {
        return query._get(opts);
    }
}
exports.Transaction = Transaction;

function parseGetAllArguments(documentRefsOrReadOptions) {
    let documents;
    let readOptions = undefined;
    if (Array.isArray(documentRefsOrReadOptions[0])) {
        throw new Error('getAll() no longer accepts an array as its first argument. ' +
            'Please unpack your array and call getAll() with individual arguments.');
    }
    if (documentRefsOrReadOptions.length > 0 &&
        (0, util_1.isPlainObject)(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {
        readOptions = documentRefsOrReadOptions.pop();
        documents = documentRefsOrReadOptions;
    }
    else {
        documents = documentRefsOrReadOptions;
    }
    for (let i = 0; i < documents.length; ++i) {
        (0, helpers_1.validateDocumentReference)(i, documents[i]);
    }
    validateReadOptions('options', readOptions, { optional: true });
    const fieldMask = readOptions && readOptions.fieldMask
        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))
        : undefined;
    return { fieldMask, documents };
}

function validateReadOptions(arg, value, options) {
    if (!(0, validate_1.validateOptional)(value, options)) {
        if (!(0, util_1.isObject)(value)) {
            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} Input is not an object.'`);
        }
        const options = value;
        if (options.fieldMask !== undefined) {
            if (!Array.isArray(options.fieldMask)) {
                throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} "fieldMask" is not an array.`);
            }
            for (let i = 0; i < options.fieldMask.length; ++i) {
                try {
                    (0, path_1.validateFieldPath)(i, options.fieldMask[i]);
                }
                catch (err) {
                    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'read option')} "fieldMask" is not valid: ${err.message}`);
                }
            }
        }
    }
}
function isRetryableTransactionError(error) {
    if (error.code !== undefined) {

        switch (error.code) {
            case 10 :
            case 1 :
            case 2 :
            case 4 :
            case 13 :
            case 14 :
            case 16 :
            case 8 :
                return true;
            case 3 :



                return !!error.message.match(/transaction has expired/);
            default:
                return false;
        }
    }
    return false;
}

async function maybeBackoff(backoff, error) {
    if ((error === null || error === void 0 ? void 0 : error.code) === 8 ) {
        backoff.resetToMax();
    }
    await backoff.backoffAndWait();
}

