"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Firestore = exports.DEFAULT_MAX_IDLE_CHANNELS = exports.DEFAULT_MAX_TRANSACTION_ATTEMPTS = exports.MAX_REQUEST_RETRIES = exports.AggregateField = exports.Aggregate = exports.setLogFunction = exports.QueryPartition = exports.CollectionGroup = exports.GeoPoint = exports.FieldPath = exports.DocumentChange = exports.Timestamp = exports.Transaction = exports.WriteResult = exports.WriteBatch = exports.Filter = exports.VectorValue = exports.FieldValue = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.BulkWriter = exports.Query = exports.QuerySnapshot = exports.DocumentReference = exports.CollectionReference = void 0;
const stream_1 = require("stream");
const url_1 = require("url");
const backoff_1 = require("./backoff");
const bulk_writer_1 = require("./bulk-writer");
const bundle_1 = require("./bundle");
const convert_1 = require("./convert");
const document_reader_1 = require("./document-reader");
const document_1 = require("./document");
const logger_1 = require("./logger");
const path_1 = require("./path");
const pool_1 = require("./pool");
const collection_reference_1 = require("./reference/collection-reference");
const document_reference_1 = require("./reference/document-reference");
const serializer_1 = require("./serializer");
const timestamp_1 = require("./timestamp");
const transaction_1 = require("./transaction");
const util_1 = require("./util");
const validate_1 = require("./validate");
const write_batch_1 = require("./write-batch");
const firestore_client_config_json_1 = require("./v1/firestore_client_config.json");
const serviceConfig = firestore_client_config_json_1.interfaces['google.firestore.v1.Firestore'];
const collection_group_1 = require("./collection-group");
Object.defineProperty(exports, "CollectionGroup", { enumerable: true, get: function () { return collection_group_1.CollectionGroup; } });
const recursive_delete_1 = require("./recursive-delete");
const trace_util_1 = require("./telemetry/trace-util");
const disabled_trace_util_1 = require("./telemetry/disabled-trace-util");
const enabled_trace_util_1 = require("./telemetry/enabled-trace-util");
var collection_reference_2 = require("./reference/collection-reference");
Object.defineProperty(exports, "CollectionReference", { enumerable: true, get: function () { return collection_reference_2.CollectionReference; } });
var document_reference_2 = require("./reference/document-reference");
Object.defineProperty(exports, "DocumentReference", { enumerable: true, get: function () { return document_reference_2.DocumentReference; } });
var query_snapshot_1 = require("./reference/query-snapshot");
Object.defineProperty(exports, "QuerySnapshot", { enumerable: true, get: function () { return query_snapshot_1.QuerySnapshot; } });
var query_1 = require("./reference/query");
Object.defineProperty(exports, "Query", { enumerable: true, get: function () { return query_1.Query; } });
var bulk_writer_2 = require("./bulk-writer");
Object.defineProperty(exports, "BulkWriter", { enumerable: true, get: function () { return bulk_writer_2.BulkWriter; } });
var document_2 = require("./document");
Object.defineProperty(exports, "DocumentSnapshot", { enumerable: true, get: function () { return document_2.DocumentSnapshot; } });
Object.defineProperty(exports, "QueryDocumentSnapshot", { enumerable: true, get: function () { return document_2.QueryDocumentSnapshot; } });
var field_value_1 = require("./field-value");
Object.defineProperty(exports, "FieldValue", { enumerable: true, get: function () { return field_value_1.FieldValue; } });
Object.defineProperty(exports, "VectorValue", { enumerable: true, get: function () { return field_value_1.VectorValue; } });
var filter_1 = require("./filter");
Object.defineProperty(exports, "Filter", { enumerable: true, get: function () { return filter_1.Filter; } });
var write_batch_2 = require("./write-batch");
Object.defineProperty(exports, "WriteBatch", { enumerable: true, get: function () { return write_batch_2.WriteBatch; } });
Object.defineProperty(exports, "WriteResult", { enumerable: true, get: function () { return write_batch_2.WriteResult; } });
var transaction_2 = require("./transaction");
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return transaction_2.Transaction; } });
var timestamp_2 = require("./timestamp");
Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return timestamp_2.Timestamp; } });
var document_change_1 = require("./document-change");
Object.defineProperty(exports, "DocumentChange", { enumerable: true, get: function () { return document_change_1.DocumentChange; } });
var path_2 = require("./path");
Object.defineProperty(exports, "FieldPath", { enumerable: true, get: function () { return path_2.FieldPath; } });
var geo_point_1 = require("./geo-point");
Object.defineProperty(exports, "GeoPoint", { enumerable: true, get: function () { return geo_point_1.GeoPoint; } });
var query_partition_1 = require("./query-partition");
Object.defineProperty(exports, "QueryPartition", { enumerable: true, get: function () { return query_partition_1.QueryPartition; } });
var logger_2 = require("./logger");
Object.defineProperty(exports, "setLogFunction", { enumerable: true, get: function () { return logger_2.setLogFunction; } });
var aggregate_1 = require("./aggregate");
Object.defineProperty(exports, "Aggregate", { enumerable: true, get: function () { return aggregate_1.Aggregate; } });
Object.defineProperty(exports, "AggregateField", { enumerable: true, get: function () { return aggregate_1.AggregateField; } });
const libVersion = require('../../package.json').version;
(0, logger_1.setLibVersion)(libVersion);








const CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';

exports.MAX_REQUEST_RETRIES = 5;

exports.DEFAULT_MAX_TRANSACTION_ATTEMPTS = 5;

exports.DEFAULT_MAX_IDLE_CHANNELS = 1;

const MAX_CONCURRENT_REQUESTS_PER_CLIENT = 100;










class Firestore {
    
    getBulkWriter() {
        if (!this._bulkWriter) {
            this._bulkWriter = this.bulkWriter();
        }
        return this._bulkWriter;
    }
    
    constructor(settings) {
        
        this._settings = {};
        
        this._settingsFrozen = false;
        
        this._serializer = null;
        
        this._projectId = undefined;
        
        this._databaseId = undefined;
        
        this.registeredListenersCount = 0;
        
        this.bulkWritersCount = 0;
        const libraryHeader = {
            libName: 'gccl',
            libVersion,
        };
        if (settings && settings.firebaseVersion) {
            libraryHeader.libVersion += ' fire/' + settings.firebaseVersion;
        }
        if (settings && settings.firebaseAdminVersion) {
            libraryHeader.libVersion +=
                ' fire-admin/' + settings.firebaseAdminVersion;
        }
        this.validateAndApplySettings({ ...settings, ...libraryHeader });
        this._traceUtil = this.newTraceUtilInstance(this._settings);
        const retryConfig = serviceConfig.retry_params.default;
        this._backoffSettings = {
            initialDelayMs: retryConfig.initial_retry_delay_millis,
            maxDelayMs: retryConfig.max_retry_delay_millis,
            backoffFactor: retryConfig.retry_delay_multiplier,
        };
        const maxIdleChannels = this._settings.maxIdleChannels === undefined
            ? exports.DEFAULT_MAX_IDLE_CHANNELS
            : this._settings.maxIdleChannels;
        this._clientPool = new pool_1.ClientPool(MAX_CONCURRENT_REQUESTS_PER_CLIENT, maxIdleChannels, 
         (requiresGrpc) => {
            var _a;
            let client;

            const useFallback = !this._settings.preferRest || requiresGrpc ? false : 'rest';
            let gax;
            if (useFallback) {
                if (!this._gaxFallback) {
                    gax = this._gaxFallback = require('google-gax/build/src/fallback');
                }
                else {
                    gax = this._gaxFallback;
                }
            }
            else {
                if (!this._gax) {
                    gax = this._gax = require('google-gax');
                }
                else {
                    gax = this._gax;
                }
            }
            if (this._settings.ssl === false) {
                const grpcModule = (_a = this._settings.grpc) !== null && _a !== void 0 ? _a : require('google-gax').grpc;
                const sslCreds = grpcModule.credentials.createInsecure();
                const settings = {
                    sslCreds,
                    ...this._settings,
                    fallback: useFallback,
                };


                if (useFallback) {
                    settings.protocol = 'http';
                }
                client = new module.exports.v1(settings, gax);
            }
            else {
                client = new module.exports.v1({
                    ...this._settings,
                    fallback: useFallback,
                }, gax);
            }
            (0, logger_1.logger)('clientFactory', null, 'Initialized Firestore GAPIC Client (useFallback: %s)', useFallback);
            return client;
        }, 
         client => client.close());
        (0, logger_1.logger)('Firestore', null, 'Initialized Firestore');
    }
    
    settings(settings) {
        (0, validate_1.validateObject)('settings', settings);
        (0, validate_1.validateString)('settings.projectId', settings.projectId, { optional: true });
        (0, validate_1.validateString)('settings.databaseId', settings.databaseId, {
            optional: true,
        });
        if (this._settingsFrozen) {
            throw new Error('Firestore has already been initialized. You can only call ' +
                'settings() once, and only before calling any other methods on a ' +
                'Firestore object.');
        }
        const mergedSettings = { ...this._settings, ...settings };
        this.validateAndApplySettings(mergedSettings);
        this._traceUtil = this.newTraceUtilInstance(this._settings);
        this._settingsFrozen = true;
    }
    validateAndApplySettings(settings) {
        var _a;
        if (settings.projectId !== undefined) {
            (0, validate_1.validateString)('settings.projectId', settings.projectId);
            this._projectId = settings.projectId;
        }
        if (settings.databaseId !== undefined) {
            (0, validate_1.validateString)('settings.databaseId', settings.databaseId);
            this._databaseId = settings.databaseId;
        }
        let url = null;


        const preferRestEnvValue = (0, util_1.tryGetPreferRestEnvironmentVariable)();
        if (settings.preferRest === undefined && preferRestEnvValue !== undefined) {
            settings = {
                ...settings,
                preferRest: preferRestEnvValue,
            };
        }


        if (process.env.FIRESTORE_EMULATOR_HOST) {
            (0, validate_1.validateHost)('FIRESTORE_EMULATOR_HOST', process.env.FIRESTORE_EMULATOR_HOST);
            settings = {
                ...settings,
                host: process.env.FIRESTORE_EMULATOR_HOST,
                ssl: false,
            };
            url = new url_1.URL(`http://${settings.host}`);
        }
        else if (settings.host !== undefined) {
            (0, validate_1.validateHost)('settings.host', settings.host);
            url = new url_1.URL(`http://${settings.host}`);
        }

        if (url !== null) {
            if ((settings.servicePath !== undefined &&
                settings.servicePath !== url.hostname) ||
                (settings.apiEndpoint !== undefined &&
                    settings.apiEndpoint !== url.hostname)) {

                console.warn(`The provided host (${url.hostname}) in "settings" does not ` +
                    `match the existing host (${(_a = settings.servicePath) !== null && _a !== void 0 ? _a : settings.apiEndpoint}). Using the provided host.`);
            }
            settings.servicePath = url.hostname;
            if (url.port !== '' && settings.port === undefined) {
                settings.port = Number(url.port);
            }



            delete settings.host;
            delete settings.apiEndpoint;
        }
        if (settings.ssl !== undefined) {
            (0, validate_1.validateBoolean)('settings.ssl', settings.ssl);
        }
        if (settings.maxIdleChannels !== undefined) {
            (0, validate_1.validateInteger)('settings.maxIdleChannels', settings.maxIdleChannels, {
                minValue: 0,
            });
        }
        this._settings = settings;
        this._settings.toJSON = function () {
            const temp = Object.assign({}, this);
            if (temp.credentials) {
                temp.credentials = { private_key: '***', client_email: '***' };
            }
            return temp;
        };
        this._serializer = new serializer_1.Serializer(this);
    }
    newTraceUtilInstance(settings) {
        let createEnabledInstance = true;

        if ('FIRESTORE_ENABLE_TRACING' in process.env) {
            const enableTracingEnvVar = process.env.FIRESTORE_ENABLE_TRACING.toLowerCase();
            if (enableTracingEnvVar === 'on' || enableTracingEnvVar === 'true') {
                createEnabledInstance = true;
            }
            if (enableTracingEnvVar === 'off' || enableTracingEnvVar === 'false') {
                createEnabledInstance = false;
            }
        }
        if (createEnabledInstance) {
            return new enabled_trace_util_1.EnabledTraceUtil(settings);
        }
        else {
            return new disabled_trace_util_1.DisabledTraceUtil();
        }
    }
    
    get projectId() {
        if (this._projectId === undefined) {
            throw new Error('INTERNAL ERROR: Client is not yet ready to issue requests.');
        }
        return this._projectId;
    }
    
    get databaseId() {
        return this._databaseId || path_1.DEFAULT_DATABASE_ID;
    }
    
    get formattedName() {
        return `projects/${this.projectId}/databases/${this.databaseId}`;
    }
    
    doc(documentPath) {
        (0, path_1.validateResourcePath)('documentPath', documentPath);
        const path = path_1.ResourcePath.EMPTY.append(documentPath);
        if (!path.isDocument) {
            throw new Error(`Value for argument "documentPath" must point to a document, but was "${documentPath}". Your path does not contain an even number of components.`);
        }
        return new document_reference_1.DocumentReference(this, path);
    }
    
    collection(collectionPath) {
        (0, path_1.validateResourcePath)('collectionPath', collectionPath);
        const path = path_1.ResourcePath.EMPTY.append(collectionPath);
        if (!path.isCollection) {
            throw new Error(`Value for argument "collectionPath" must point to a collection, but was "${collectionPath}". Your path does not contain an odd number of components.`);
        }
        return new collection_reference_1.CollectionReference(this, path);
    }
    
    collectionGroup(collectionId) {
        if (collectionId.indexOf('/') !== -1) {
            throw new Error(`Invalid collectionId '${collectionId}'. Collection IDs must not contain '/'.`);
        }
        return new collection_group_1.CollectionGroup(this, collectionId,  undefined);
    }
    
    batch() {
        return new write_batch_1.WriteBatch(this);
    }
    
    bulkWriter(options) {
        return new bulk_writer_1.BulkWriter(this, options);
    }
    
    snapshot_(documentOrName, readTime, encoding) {

        let convertTimestamp;
        let convertFields;
        if (encoding === undefined || encoding === 'protobufJS') {
            convertTimestamp = data => data;
            convertFields = data => data;
        }
        else if (encoding === 'json') {


            convertTimestamp = convert_1.timestampFromJson;
            convertFields = convert_1.fieldsFromJson;
        }
        else {
            throw new Error('Unsupported encoding format. Expected "json" or "protobufJS", ' +
                `but was "${encoding}".`);
        }
        let ref;
        let document;
        if (typeof documentOrName === 'string') {
            ref = new document_reference_1.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName));
            document = new document_1.DocumentSnapshotBuilder(ref);
        }
        else {
            ref = new document_reference_1.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName.name));
            document = new document_1.DocumentSnapshotBuilder(ref);
            document.fieldsProto = documentOrName.fields
                ? convertFields(documentOrName.fields)
                : {};
            document.createTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.createTime, 'documentOrName.createTime'));
            document.updateTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime'));
        }
        if (readTime) {
            document.readTime = timestamp_1.Timestamp.fromProto(convertTimestamp(readTime, 'readTime'));
        }
        return document.build();
    }
    
    bundle(name) {
        return new bundle_1.BundleBuilder(name || (0, util_1.autoId)());
    }
    
    
    
    
    runTransaction(updateFunction, transactionOptions) {
        (0, validate_1.validateFunction)('updateFunction', updateFunction);
        const tag = (0, util_1.requestTag)();
        if (transactionOptions) {
            (0, validate_1.validateObject)('transactionOptions', transactionOptions);
            (0, validate_1.validateBoolean)('transactionOptions.readOnly', transactionOptions.readOnly, { optional: true });
            if (transactionOptions.readOnly) {
                (0, validate_1.validateTimestamp)('transactionOptions.readTime', transactionOptions.readTime, { optional: true });
            }
            else {
                (0, validate_1.validateInteger)('transactionOptions.maxAttempts', transactionOptions.maxAttempts, { optional: true, minValue: 1 });
            }
        }
        const transaction = new transaction_1.Transaction(this, tag, transactionOptions);
        return this.initializeIfNeeded(tag).then(() => transaction.runTransaction(updateFunction));
    }
    
    listCollections() {
        const rootDocument = new document_reference_1.DocumentReference(this, path_1.ResourcePath.EMPTY);
        return rootDocument.listCollections();
    }
    
    getAll(...documentRefsOrReadOptions) {
        return this._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_BATCH_GET_DOCUMENTS, () => {
            (0, validate_1.validateMinNumberOfArguments)('Firestore.getAll', documentRefsOrReadOptions, 1);
            const { documents, fieldMask } = (0, transaction_1.parseGetAllArguments)(documentRefsOrReadOptions);
            this._traceUtil.currentSpan().setAttributes({
                [trace_util_1.ATTRIBUTE_KEY_IS_TRANSACTIONAL]: false,
                [trace_util_1.ATTRIBUTE_KEY_DOC_COUNT]: documents.length,
            });
            const tag = (0, util_1.requestTag)();

            const stack = Error().stack;
            return this.initializeIfNeeded(tag)
                .then(() => {
                const reader = new document_reader_1.DocumentReader(this, documents, fieldMask);
                return reader.get(tag);
            })
                .catch(err => {
                throw (0, util_1.wrapError)(err, stack);
            });
        });
    }
    
    registerListener() {
        this.registeredListenersCount += 1;
    }
    
    unregisterListener() {
        this.registeredListenersCount -= 1;
    }
    
    _incrementBulkWritersCount() {
        this.bulkWritersCount += 1;
    }
    
    _decrementBulkWritersCount() {
        this.bulkWritersCount -= 1;
    }
    
    recursiveDelete(ref, bulkWriter) {
        return this._recursiveDelete(ref, recursive_delete_1.RECURSIVE_DELETE_MAX_PENDING_OPS, recursive_delete_1.RECURSIVE_DELETE_MIN_PENDING_OPS, bulkWriter);
    }
    

    _recursiveDelete(ref, maxPendingOps, minPendingOps, bulkWriter) {
        const writer = bulkWriter !== null && bulkWriter !== void 0 ? bulkWriter : this.getBulkWriter();
        const deleter = new recursive_delete_1.RecursiveDelete(this, writer, ref, maxPendingOps, minPendingOps);
        return deleter.run();
    }
    
    async terminate() {
        if (this._bulkWriter) {
            await this._bulkWriter.close();
            this._bulkWriter = undefined;
        }
        if (this.registeredListenersCount > 0 || this.bulkWritersCount > 0) {
            return Promise.reject('All onSnapshot() listeners must be unsubscribed, and all BulkWriter ' +
                'instances must be closed before terminating the client. ' +
                `There are ${this.registeredListenersCount} active listeners and ` +
                `${this.bulkWritersCount} open BulkWriter instances.`);
        }
        return this._clientPool.terminate();
    }
    
    toJSON() {
        return { projectId: this._projectId };
    }
    
    async initializeIfNeeded(requestTag) {
        this._settingsFrozen = true;
        if (this._settings.ssl === false) {







            this._settings.customHeaders = {
                Authorization: 'Bearer owner',
                ...this._settings.customHeaders,
            };
        }
        if (this._projectId === undefined) {
            try {
                this._projectId = await this._clientPool.run(requestTag, 
                 false, gapicClient => gapicClient.getProjectId());
                (0, logger_1.logger)('Firestore.initializeIfNeeded', null, 'Detected project ID: %s', this._projectId);


                this._traceUtil.recordProjectId(this.projectId);
            }
            catch (err) {
                (0, logger_1.logger)('Firestore.initializeIfNeeded', null, 'Failed to detect project ID: %s', err);
                return Promise.reject(err);
            }
        }
    }
    
    createCallOptions(methodName, retryCodes) {
        var _a;
        const callOptions = {
            otherArgs: {
                headers: {
                    [CLOUD_RESOURCE_HEADER]: this.formattedName,
                    ...this._settings.customHeaders,
                    ...(_a = this._settings[methodName]) === null || _a === void 0 ? void 0 : _a.customHeaders,
                },
            },
        };
        if (retryCodes) {
            const retryParams = (0, util_1.getRetryParams)(methodName);
            callOptions.retry =
                new (require('google-gax/build/src/fallback').RetryOptions)(retryCodes, retryParams);
        }
        return callOptions;
    }
    
    
    async _retry(methodName, requestTag, func) {
        const backoff = new backoff_1.ExponentialBackoff();
        let lastError = undefined;
        for (let attempt = 0; attempt < exports.MAX_REQUEST_RETRIES; ++attempt) {
            if (lastError) {
                (0, logger_1.logger)('Firestore._retry', requestTag, 'Retrying request that failed with error:', lastError);
            }
            try {
                await backoff.backoffAndWait();
                return await func();
            }
            catch (err) {
                lastError = err;
                if ((0, util_1.isPermanentRpcError)(err, methodName)) {
                    break;
                }
            }
        }
        (0, logger_1.logger)('Firestore._retry', requestTag, 'Request failed with error:', lastError);
        return Promise.reject(lastError);
    }
    
    _initializeStream(backendStream, lifetime, requestTag, request) {
        const resultStream = new stream_1.PassThrough({ objectMode: true });
        resultStream.pause();
        
        let streamInitialized = false;
        return new Promise((resolve, reject) => {
            function streamReady() {
                if (!streamInitialized) {
                    streamInitialized = true;
                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Stream ready');
                    resolve(resultStream);
                }
            }
            function streamEnded() {
                (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received stream end');
                resultStream.unpipe(backendStream);
                resolve(resultStream);
                lifetime.resolve();
            }
            function streamFailed(err) {
                if (!streamInitialized) {


                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received initial error:', err);
                    reject(err);
                }
                else {
                    (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Received stream error:', err);




                    setImmediate(() => {
                        resultStream.emit('error', err);
                    });
                }
            }
            backendStream.on('data', () => streamReady());
            backendStream.on('error', err => streamFailed(err));
            backendStream.on('end', () => streamEnded());
            backendStream.on('close', () => streamEnded());
            backendStream.on('finish', () => streamEnded());
            backendStream.pipe(resultStream);
            if (request) {
                (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Sending request: %j', request);
                backendStream.write(request, 'utf-8', err => {
                    if (err) {
                        streamFailed(err);
                    }
                    else {
                        (0, logger_1.logger)('Firestore._initializeStream', requestTag, 'Marking stream as healthy');
                        streamReady();
                    }
                });
            }
        });
    }
    
    request(methodName, request, requestTag, retryCodes) {
        const callOptions = this.createCallOptions(methodName, retryCodes);
        return this._clientPool.run(requestTag, 
         false, async (gapicClient) => {
            try {
                (0, logger_1.logger)('Firestore.request', requestTag, 'Sending request: %j', request);
                const [result] = await gapicClient[methodName](request, callOptions);
                (0, logger_1.logger)('Firestore.request', requestTag, 'Received response: %j', result);
                return result;
            }
            catch (err) {
                (0, logger_1.logger)('Firestore.request', requestTag, 'Received error:', err);
                return Promise.reject(err);
            }
        });
    }
    
    requestStream(methodName, bidrectional, request, requestTag) {
        const callOptions = this.createCallOptions(methodName);
        const bidirectional = methodName === 'listen';
        let numResponses = 0;
        const NUM_RESPONSES_PER_TRACE_EVENT = 100;
        return this._retry(methodName, requestTag, () => {
            const result = new util_1.Deferred();
            this._clientPool.run(requestTag, bidrectional, async (gapicClient) => {
                (0, logger_1.logger)('Firestore.requestStream', requestTag, 'Sending request: %j', request);
                this._traceUtil
                    .currentSpan()
                    .addEvent(`Firestore.${methodName}: Start`);
                try {
                    const stream = bidirectional
                        ? gapicClient[methodName](callOptions)
                        : gapicClient[methodName](request, callOptions);
                    const logStream = new stream_1.Transform({
                        objectMode: true,
                        transform: (chunk, encoding, callback) => {
                            (0, logger_1.logger)('Firestore.requestStream', requestTag, 'Received response: %j', chunk);
                            numResponses++;
                            if (numResponses === 1) {
                                this._traceUtil
                                    .currentSpan()
                                    .addEvent(`Firestore.${methodName}: First response received`);
                            }
                            else if (numResponses % NUM_RESPONSES_PER_TRACE_EVENT === 0) {
                                this._traceUtil
                                    .currentSpan()
                                    .addEvent(`Firestore.${methodName}: Received ${numResponses} responses`);
                            }
                            callback();
                        },
                    });
                    stream.pipe(logStream);
                    const lifetime = new util_1.Deferred();
                    const resultStream = await this._initializeStream(stream, lifetime, requestTag, bidirectional ? request : undefined);
                    resultStream.on('end', () => {
                        stream.end();
                        this._traceUtil
                            .currentSpan()
                            .addEvent(`Firestore.${methodName}: Completed`, {
                            [trace_util_1.ATTRIBUTE_KEY_NUM_RESPONSES]: numResponses,
                        });
                    });
                    result.resolve(resultStream);



                    return lifetime.promise;
                }
                catch (e) {
                    result.reject(e);
                }
            });
            return result.promise;
        });
    }
}
exports.Firestore = Firestore;




exports.default = Firestore;



const existingExports = module.exports;
module.exports = Firestore;
module.exports = Object.assign(module.exports, existingExports);

Object.defineProperty(module.exports, 'v1beta1', {


    get: () => require('./v1beta1'),
});

Object.defineProperty(module.exports, 'v1', {


    get: () => require('./v1'),
});

Object.defineProperty(module.exports, 'GrpcStatus', {


    get: () => require('google-gax').Status,
});

