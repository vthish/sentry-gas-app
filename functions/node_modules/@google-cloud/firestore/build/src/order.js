"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.primitiveComparator = primitiveComparator;
exports.compareArrays = compareArrays;
exports.compareUtf8Strings = compareUtf8Strings;
exports.compare = compare;
const convert_1 = require("./convert");
const path_1 = require("./path");

var TypeOrder;
(function (TypeOrder) {
    TypeOrder[TypeOrder["NULL"] = 0] = "NULL";
    TypeOrder[TypeOrder["BOOLEAN"] = 1] = "BOOLEAN";
    TypeOrder[TypeOrder["NUMBER"] = 2] = "NUMBER";
    TypeOrder[TypeOrder["TIMESTAMP"] = 3] = "TIMESTAMP";
    TypeOrder[TypeOrder["STRING"] = 4] = "STRING";
    TypeOrder[TypeOrder["BLOB"] = 5] = "BLOB";
    TypeOrder[TypeOrder["REF"] = 6] = "REF";
    TypeOrder[TypeOrder["GEO_POINT"] = 7] = "GEO_POINT";
    TypeOrder[TypeOrder["ARRAY"] = 8] = "ARRAY";
    TypeOrder[TypeOrder["VECTOR"] = 9] = "VECTOR";
    TypeOrder[TypeOrder["OBJECT"] = 10] = "OBJECT";
})(TypeOrder || (TypeOrder = {}));

function typeOrder(val) {
    const valueType = (0, convert_1.detectValueType)(val);
    switch (valueType) {
        case 'nullValue':
            return TypeOrder.NULL;
        case 'integerValue':
            return TypeOrder.NUMBER;
        case 'doubleValue':
            return TypeOrder.NUMBER;
        case 'stringValue':
            return TypeOrder.STRING;
        case 'booleanValue':
            return TypeOrder.BOOLEAN;
        case 'arrayValue':
            return TypeOrder.ARRAY;
        case 'timestampValue':
            return TypeOrder.TIMESTAMP;
        case 'geoPointValue':
            return TypeOrder.GEO_POINT;
        case 'bytesValue':
            return TypeOrder.BLOB;
        case 'referenceValue':
            return TypeOrder.REF;
        case 'mapValue':
            return TypeOrder.OBJECT;
        case 'vectorValue':
            return TypeOrder.VECTOR;
        default:
            throw new Error('Unexpected value type: ' + valueType);
    }
}

function primitiveComparator(left, right) {
    if (left < right) {
        return -1;
    }
    if (left > right) {
        return 1;
    }
    return 0;
}

function compareNumbers(left, right) {
    if (left < right) {
        return -1;
    }
    if (left > right) {
        return 1;
    }
    if (left === right) {
        return 0;
    }

    if (isNaN(left)) {
        return isNaN(right) ? 0 : -1;
    }
    return 1;
}

function compareNumberProtos(left, right) {
    let leftValue, rightValue;
    if (left.integerValue !== undefined) {
        leftValue = Number(left.integerValue);
    }
    else {
        leftValue = Number(left.doubleValue);
    }
    if (right.integerValue !== undefined) {
        rightValue = Number(right.integerValue);
    }
    else {
        rightValue = Number(right.doubleValue);
    }
    return compareNumbers(leftValue, rightValue);
}

function compareTimestamps(left, right) {
    const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);
    if (seconds !== 0) {
        return seconds;
    }
    return primitiveComparator(left.nanos || 0, right.nanos || 0);
}

function compareBlobs(left, right) {
    if (!(left instanceof Buffer) || !(right instanceof Buffer)) {
        throw new Error('Blobs can only be compared if they are Buffers.');
    }
    return Buffer.compare(left, right);
}

function compareReferenceProtos(left, right) {
    const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);
    const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);
    return leftPath.compareTo(rightPath);
}

function compareGeoPoints(left, right) {
    return (primitiveComparator(left.latitude || 0, right.latitude || 0) ||
        primitiveComparator(left.longitude || 0, right.longitude || 0));
}

function compareArrays(left, right) {
    for (let i = 0; i < left.length && i < right.length; i++) {
        const valueComparison = compare(left[i], right[i]);
        if (valueComparison !== 0) {
            return valueComparison;
        }
    }

    return primitiveComparator(left.length, right.length);
}

function compareObjects(left, right) {


    const leftKeys = Object.keys(left);
    const rightKeys = Object.keys(right);
    leftKeys.sort();
    rightKeys.sort();
    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
        const keyComparison = compareUtf8Strings(leftKeys[i], rightKeys[i]);
        if (keyComparison !== 0) {
            return keyComparison;
        }
        const key = leftKeys[i];
        const valueComparison = compare(left[key], right[key]);
        if (valueComparison !== 0) {
            return valueComparison;
        }
    }

    return primitiveComparator(leftKeys.length, rightKeys.length);
}

function compareVectors(left, right) {
    var _a, _b, _c, _d, _e, _f;

    const leftArray = (_c = (_b = (_a = left === null || left === void 0 ? void 0 : left['value']) === null || _a === void 0 ? void 0 : _a.arrayValue) === null || _b === void 0 ? void 0 : _b.values) !== null && _c !== void 0 ? _c : [];
    const rightArray = (_f = (_e = (_d = right === null || right === void 0 ? void 0 : right['value']) === null || _d === void 0 ? void 0 : _d.arrayValue) === null || _e === void 0 ? void 0 : _e.values) !== null && _f !== void 0 ? _f : [];
    const lengthCompare = primitiveComparator(leftArray.length, rightArray.length);
    if (lengthCompare !== 0) {
        return lengthCompare;
    }
    return compareArrays(leftArray, rightArray);
}

function compareUtf8Strings(left, right) {



































    const length = Math.min(left.length, right.length);
    for (let i = 0; i < length; i++) {
        const leftChar = left.charAt(i);
        const rightChar = right.charAt(i);
        if (leftChar !== rightChar) {
            return isSurrogate(leftChar) === isSurrogate(rightChar)
                ? primitiveComparator(leftChar, rightChar)
                : isSurrogate(leftChar)
                    ? 1
                    : -1;
        }
    }


    return primitiveComparator(left.length, right.length);
}
const MIN_SURROGATE = 0xd800;
const MAX_SURROGATE = 0xdfff;
function isSurrogate(s) {
    const c = s.charCodeAt(0);
    return c >= MIN_SURROGATE && c <= MAX_SURROGATE;
}

function compare(left, right) {

    const leftType = typeOrder(left);
    const rightType = typeOrder(right);
    const typeComparison = primitiveComparator(leftType, rightType);
    if (typeComparison !== 0) {
        return typeComparison;
    }

    switch (leftType) {
        case TypeOrder.NULL:

            return 0;
        case TypeOrder.BOOLEAN:
            return primitiveComparator(left.booleanValue, right.booleanValue);
        case TypeOrder.STRING:
            return compareUtf8Strings(left.stringValue, right.stringValue);
        case TypeOrder.NUMBER:
            return compareNumberProtos(left, right);
        case TypeOrder.TIMESTAMP:
            return compareTimestamps(left.timestampValue, right.timestampValue);
        case TypeOrder.BLOB:
            return compareBlobs(left.bytesValue, right.bytesValue);
        case TypeOrder.REF:
            return compareReferenceProtos(left, right);
        case TypeOrder.GEO_POINT:
            return compareGeoPoints(left.geoPointValue, right.geoPointValue);
        case TypeOrder.ARRAY:
            return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);
        case TypeOrder.OBJECT:
            return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});
        case TypeOrder.VECTOR:
            return compareVectors(left.mapValue.fields || {}, right.mapValue.fields || {});
        default:
            throw new Error(`Encountered unknown type order: ${leftType}`);
    }
}

