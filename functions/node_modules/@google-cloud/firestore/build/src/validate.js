"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.customObjectMessage = customObjectMessage;
exports.validateFunction = validateFunction;
exports.validateObject = validateObject;
exports.validateString = validateString;
exports.validateHost = validateHost;
exports.validateBoolean = validateBoolean;
exports.validateNumber = validateNumber;
exports.validateInteger = validateInteger;
exports.validateTimestamp = validateTimestamp;
exports.invalidArgumentMessage = invalidArgumentMessage;
exports.validateOptional = validateOptional;
exports.validateMinNumberOfArguments = validateMinNumberOfArguments;
exports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;
exports.validateEnumValue = validateEnumValue;
const url_1 = require("url");
const util_1 = require("./util");
const timestamp_1 = require("./timestamp");

function customObjectMessage(arg, value, path) {
    const fieldPathMessage = path ? ` (found in field "${path}")` : '';
    if ((0, util_1.isObject)(value)) {



        const typeName = value.constructor.name;
        switch (typeName) {
            case 'DocumentReference':
            case 'FieldPath':
            case 'FieldValue':
            case 'GeoPoint':
            case 'Timestamp':
                return (`${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type "${typeName}" that doesn't match the ` +
                    `expected instance${fieldPathMessage}. Please ensure that the ` +
                    'Firestore types you are using are from the same NPM package.)');
            case 'Object':
                return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type "${typeof value}" as a Firestore argument${fieldPathMessage}.`;
            default:
                return (`${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type "${typeName}"${fieldPathMessage}. Firestore doesn't support JavaScript ` +
                    'objects with custom prototypes (i.e. objects that were created ' +
                    'via the "new" operator).');
        }
    }
    else {
        return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;
    }
}

function validateFunction(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (!(0, util_1.isFunction)(value)) {
            throw new Error(invalidArgumentMessage(arg, 'function'));
        }
    }
}

function validateObject(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (!(0, util_1.isObject)(value)) {
            throw new Error(invalidArgumentMessage(arg, 'object'));
        }
    }
}

function validateString(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (typeof value !== 'string') {
            throw new Error(invalidArgumentMessage(arg, 'string'));
        }
    }
}

function validateHost(arg, value, options) {
    if (!validateOptional(value, options)) {
        validateString(arg, value);
        const urlString = `http://${value}/`;
        let parsed;
        try {
            parsed = new url_1.URL(urlString);
        }
        catch (e) {
            throw new Error(invalidArgumentMessage(arg, 'host'));
        }
        if (parsed.search !== '' ||
            parsed.pathname !== '/' ||
            parsed.username !== '') {
            throw new Error(invalidArgumentMessage(arg, 'host'));
        }
    }
}

function validateBoolean(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (typeof value !== 'boolean') {
            throw new Error(invalidArgumentMessage(arg, 'boolean'));
        }
    }
}

function validateNumber(arg, value, options) {
    const min = options !== undefined && options.minValue !== undefined
        ? options.minValue
        : -Infinity;
    const max = options !== undefined && options.maxValue !== undefined
        ? options.maxValue
        : Infinity;
    if (!validateOptional(value, options)) {
        if (typeof value !== 'number' || isNaN(value)) {
            throw new Error(invalidArgumentMessage(arg, 'number'));
        }
        else if (value < min || value > max) {
            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);
        }
    }
}

function validateInteger(arg, value, options) {
    const min = options !== undefined && options.minValue !== undefined
        ? options.minValue
        : -Infinity;
    const max = options !== undefined && options.maxValue !== undefined
        ? options.maxValue
        : Infinity;
    if (!validateOptional(value, options)) {
        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {
            throw new Error(invalidArgumentMessage(arg, 'integer'));
        }
        else if (value < min || value > max) {
            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);
        }
    }
}

function validateTimestamp(arg, value, options) {
    if (!validateOptional(value, options)) {
        if (!(value instanceof timestamp_1.Timestamp)) {
            throw new Error(invalidArgumentMessage(arg, 'Timestamp'));
        }
    }
}

function invalidArgumentMessage(arg, expectedType) {
    return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;
}

function validateOptional(value, options) {
    return (value === undefined && options !== undefined && options.optional === true);
}

function formatPlural(num, str) {
    return `${num} ${str}` + (num === 1 ? '' : 's');
}

function formatArgumentName(arg) {
    return typeof arg === 'string'
        ? `Value for argument "${arg}"`
        : `Element at index ${arg}`;
}

function validateMinNumberOfArguments(funcName, args, minSize) {
    if (args.length < minSize) {
        throw new Error(`Function "${funcName}()" requires at least ` +
            `${formatPlural(minSize, 'argument')}.`);
    }
}

function validateMaxNumberOfArguments(funcName, args, maxSize) {
    if (args.length > maxSize) {
        throw new Error(`Function "${funcName}()" accepts at most ` +
            `${formatPlural(maxSize, 'argument')}.`);
    }
}

function validateEnumValue(arg, value, allowedValues, options) {
    if (!validateOptional(value, options)) {
        const expectedDescription = [];
        for (const allowed of allowedValues) {
            if (allowed === value) {
                return;
            }
            expectedDescription.push(allowed);
        }
        throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);
    }
}

