
var forge = require('./forge');
require('./tls');


forge.tls.wrapSocket = function(options) {

  var socket = options.socket;


  var tlsSocket = {
    id: socket.id,

    connected: socket.connected || function(e) {},
    closed: socket.closed || function(e) {},
    data: socket.data || function(e) {},
    error: socket.error || function(e) {}
  };


  var c = forge.tls.createConnection({
    server: false,
    sessionId: options.sessionId || null,
    caStore: options.caStore || [],
    sessionCache: options.sessionCache || null,
    cipherSuites: options.cipherSuites || null,
    virtualHost: options.virtualHost,
    verify: options.verify,
    getCertificate: options.getCertificate,
    getPrivateKey: options.getPrivateKey,
    getSignature: options.getSignature,
    deflate: options.deflate,
    inflate: options.inflate,
    connected: function(c) {

      if(c.handshakes === 1) {
        tlsSocket.connected({
          id: socket.id,
          type: 'connect',
          bytesAvailable: c.data.length()
        });
      }
    },
    tlsDataReady: function(c) {

      return socket.send(c.tlsData.getBytes());
    },
    dataReady: function(c) {

      tlsSocket.data({
        id: socket.id,
        type: 'socketData',
        bytesAvailable: c.data.length()
      });
    },
    closed: function(c) {

      socket.close();
    },
    error: function(c, e) {

      tlsSocket.error({
        id: socket.id,
        type: 'tlsError',
        message: e.message,
        bytesAvailable: 0,
        error: e
      });
      socket.close();
    }
  });


  socket.connected = function(e) {
    c.handshake(options.sessionId);
  };


  socket.closed = function(e) {
    if(c.open && c.handshaking) {

      tlsSocket.error({
        id: socket.id,
        type: 'ioError',
        message: 'Connection closed during handshake.',
        bytesAvailable: 0
      });
    }
    c.close();


    tlsSocket.closed({
      id: socket.id,
      type: 'close',
      bytesAvailable: 0
    });
  };


  socket.error = function(e) {

    tlsSocket.error({
      id: socket.id,
      type: e.type,
      message: e.message,
      bytesAvailable: 0
    });
    c.close();
  };


  var _requiredBytes = 0;
  socket.data = function(e) {

    if(!c.open) {
      socket.receive(e.bytesAvailable);
    } else {


      if(e.bytesAvailable >= _requiredBytes) {
        var count = Math.max(e.bytesAvailable, _requiredBytes);
        var data = socket.receive(count);
        if(data !== null) {
          _requiredBytes = c.process(data);
        }
      }
    }
  };

  
  tlsSocket.destroy = function() {
    socket.destroy();
  };

  
  tlsSocket.setSessionCache = function(cache) {
    c.sessionCache = tls.createSessionCache(cache);
  };

  
  tlsSocket.connect = function(options) {
    socket.connect(options);
  };

  
  tlsSocket.close = function() {
    c.close();
  };

  
  tlsSocket.isConnected = function() {
    return c.isConnected && socket.isConnected();
  };

  
  tlsSocket.send = function(bytes) {
    return c.prepare(bytes);
  };

  
  tlsSocket.receive = function(count) {
    return c.data.getBytes(count);
  };

  
  tlsSocket.bytesAvailable = function() {
    return c.data.length();
  };

  return tlsSocket;
};

