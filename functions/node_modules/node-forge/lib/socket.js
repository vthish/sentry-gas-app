
var forge = require('./forge');
require('./util');


var net = module.exports = forge.net = forge.net || {};


net.socketPools = {};


net.createSocketPool = function(options) {

  options.msie = options.msie || false;


  var spId = options.flashId;
  var api = document.getElementById(spId);
  api.init({marshallExceptions: !options.msie});


  var sp = {

    id: spId,

    flashApi: api,

    sockets: {},

    policyPort: options.policyPort || 0,

    policyUrl: options.policyUrl || null
  };
  net.socketPools[spId] = sp;


  if(options.msie === true) {
    sp.handler = function(e) {
      if(e.id in sp.sockets) {

        var f;
        switch(e.type) {
        case 'connect':
          f = 'connected';
          break;
        case 'close':
          f = 'closed';
          break;
        case 'socketData':
          f = 'data';
          break;
        default:
          f = 'error';
          break;
        }
        
        setTimeout(function() {sp.sockets[e.id][f](e);}, 0);
      }
    };
  } else {
    sp.handler = function(e) {
      if(e.id in sp.sockets) {

        var f;
        switch(e.type) {
        case 'connect':
          f = 'connected';
          break;
        case 'close':
          f = 'closed';
          break;
        case 'socketData':
          f = 'data';
          break;
        default:
          f = 'error';
          break;
        }
        sp.sockets[e.id][f](e);
      }
    };
  }
  var handler = 'forge.net.socketPools[\'' + spId + '\'].handler';
  api.subscribe('connect', handler);
  api.subscribe('close', handler);
  api.subscribe('socketData', handler);
  api.subscribe('ioError', handler);
  api.subscribe('securityError', handler);

  
  sp.destroy = function() {
    delete net.socketPools[options.flashId];
    for(var id in sp.sockets) {
      sp.sockets[id].destroy();
    }
    sp.sockets = {};
    api.cleanup();
  };

  
   sp.createSocket = function(options) {

     options = options || {};


     var id = api.create();


     var socket = {
       id: id,

       connected: options.connected || function(e) {},
       closed: options.closed || function(e) {},
       data: options.data || function(e) {},
       error: options.error || function(e) {}
     };

     
     socket.destroy = function() {
       api.destroy(id);
       delete sp.sockets[id];
     };

     
     socket.connect = function(options) {



       var policyUrl = options.policyUrl || null;
       var policyPort = 0;
       if(policyUrl === null && options.policyPort !== 0) {
         policyPort = options.policyPort || sp.policyPort;
       }
       api.connect(id, options.host, options.port, policyPort, policyUrl);
     };

     
     socket.close = function() {
       api.close(id);
       socket.closed({
         id: socket.id,
         type: 'close',
         bytesAvailable: 0
       });
     };

     
     socket.isConnected = function() {
       return api.isConnected(id);
     };

     
     socket.send = function(bytes) {
       return api.send(id, forge.util.encode64(bytes));
     };

     
     socket.receive = function(count) {
       var rval = api.receive(id, count).rval;
       return (rval === null) ? null : forge.util.decode64(rval);
     };

     
     socket.bytesAvailable = function() {
       return api.getBytesAvailable(id);
     };


     sp.sockets[id] = socket;
     return socket;
  };

  return sp;
};


net.destroySocketPool = function(options) {
  if(options.flashId in net.socketPools) {
    var sp = net.socketPools[options.flashId];
    sp.destroy();
  }
};


net.createSocket = function(options) {
  var socket = null;
  if(options.flashId in net.socketPools) {

    var sp = net.socketPools[options.flashId];
    socket = sp.createSocket(options);
  }
  return socket;
};

