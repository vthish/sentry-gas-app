'use strict'



const { EventEmitter } = require('node:events')
const { inherits } = require('node:util')

function SBMH (needle) {
  if (typeof needle === 'string') {
    needle = Buffer.from(needle)
  }

  if (!Buffer.isBuffer(needle)) {
    throw new TypeError('The needle has to be a String or a Buffer.')
  }

  const needleLength = needle.length
  const needleLastCharIndex = needleLength - 1

  if (needleLength === 0) {
    throw new Error('The needle cannot be an empty String/Buffer.')
  }

  if (needleLength > 256) {
    throw new Error('The needle cannot have a length bigger than 256.')
  }

  this.maxMatches = Infinity
  this.matches = 0

  this._occ = new Uint8Array(256)
    .fill(needleLength) // Initialize occurrence table.
  this._lookbehind_size = 0
  this._needle = needle
  this._bufpos = 0

  this._lookbehind = Buffer.alloc(needleLastCharIndex)



  for (var i = 0; i < needleLastCharIndex; ++i) { // eslint-disable-line no-var
    this._occ[needle[i]] = needleLastCharIndex - i
  }
}
inherits(SBMH, EventEmitter)

SBMH.prototype.reset = function () {
  this._lookbehind_size = 0
  this.matches = 0
  this._bufpos = 0
}

SBMH.prototype.push = function (chunk, pos) {
  if (!Buffer.isBuffer(chunk)) {
    chunk = Buffer.from(chunk, 'binary')
  }
  const chlen = chunk.length
  this._bufpos = pos || 0
  let r
  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk) }
  return r
}

SBMH.prototype._sbmh_feed = function (data) {
  const len = data.length
  const needle = this._needle
  const needleLength = needle.length
  const needleLastCharIndex = needleLength - 1
  const needleLastChar = needle[needleLastCharIndex]





  let pos = -this._lookbehind_size
  let ch

  if (pos < 0) {












    while (pos < 0 && pos <= len - needleLength) {
      ch = data[pos + needleLastCharIndex]

      if (
        ch === needleLastChar &&
        this._sbmh_memcmp(data, pos, needleLastCharIndex)
      ) {
        this._lookbehind_size = 0
        ++this.matches
        this.emit('info', true)
        return (this._bufpos = pos + needleLength)
      }

      pos += this._occ[ch]
    }



    while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {








      ++pos
    }

    if (pos >= 0) {

      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size)
      this._lookbehind_size = 0
    } else {



      const bytesToCutOff = this._lookbehind_size + pos
      if (bytesToCutOff > 0) {

        this.emit('info', false, this._lookbehind, 0, bytesToCutOff)
      }

      this._lookbehind_size -= bytesToCutOff
      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size)

      data.copy(this._lookbehind, this._lookbehind_size)
      this._lookbehind_size += len

      this._bufpos = len
      return len
    }
  }



  pos = data.indexOf(needle, pos + this._bufpos)

  if (pos !== -1) {
    ++this.matches
    if (pos === 0) { this.emit('info', true) } else { this.emit('info', true, data, this._bufpos, pos) }
    return (this._bufpos = pos + needleLength)
  }

  pos = len - needleLastCharIndex
  if (pos < 0) {
    pos = 0
  }







  while (
    pos !== len &&
    (
      data[pos] !== needle[0] ||
      Buffer.compare(
        data.subarray(pos + 1, len),
        needle.subarray(1, len - pos)
      ) !== 0
    )
  ) {
    ++pos
  }

  if (pos !== len) {
    data.copy(this._lookbehind, 0, pos, len)
    this._lookbehind_size = len - pos
  }


  if (pos !== 0) { this.emit('info', false, data, this._bufpos, pos) }

  this._bufpos = len
  return len
}

SBMH.prototype._sbmh_lookup_char = function (data, pos) {
  return pos < 0
    ? this._lookbehind[this._lookbehind_size + pos]
    : data[pos]
}

SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }
  }
  return true
}

module.exports = SBMH

