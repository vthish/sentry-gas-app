import StringSource from './inputSource/StringSource.js';
import BufferSource from './inputSource/BufferSource.js';
import {readTagExp,readClosingTagName} from './XmlPartReader.js';
import {readComment, readCdata,readDocType,readPiTag} from './XmlSpecialTagsReader.js';
import TagPath from './TagPath.js';
import TagPathMatcher from './TagPathMatcher.js';
import EntitiesParser from './EntitiesParser.js';



class TagDetail{
  constructor(name){
    this.name = name;
    this.position = 0;

  }
}

export default class Xml2JsParser {
    constructor(options) {
      this.options = options;
      
      this.currentTagDetail = null;
      this.tagTextData = "";
      this.tagsStack = [];
      this.entityParser = new EntitiesParser(options.htmlEntities);
      this.stopNodes = [];
      for (let i = 0; i < this.options.stopNodes.length; i++) {
        this.stopNodes.push(new TagPath(this.options.stopNodes[i]));
      }
    }

    parse(strData) {
        this.source = new StringSource(strData);
        this.parseXml();
        return this.outputBuilder.getOutput();
    }
    parseBytesArr(data) {
        this.source = new BufferSource(data );
        this.parseXml();
        return this.outputBuilder.getOutput();
    }
  
    parseXml() {



      this.outputBuilder = this.options.OutputBuilder.getInstance(this.options);
      this.root = { root: true};
      this.currentTagDetail = this.root;

      while(this.source.canRead()){
        let ch = this.source.readCh();
        if (ch === "") break;
        
        if(ch === "<"){//tagStart
          let nextChar = this.source.readChAt(0);
          if (nextChar === "" ) throw new Error("Unexpected end of source");
          
        
          if(nextChar === "!" || nextChar === "?"){
            this.source.updateBufferBoundary();

            this.addTextNode(); 
            
            this.readSpecialTag(nextChar);// Read DOCTYPE, comment, CDATA, PI tag
          }else if(nextChar === "/"){
            this.source.updateBufferBoundary();
            this.readClosingTag();


          }else{//opening tag
            this.readOpeningTag();
          }
        }else{
          this.tagTextData += ch;
        }
      }//End While loop
      if(this.tagsStack.length > 0 || ( this.tagTextData !== "undefined" && this.tagTextData.trimEnd().length > 0) ) throw new Error("Unexpected data in the end of document");
    }
  
    
    readClosingTag(){
      const tagName = this.processTagName(readClosingTagName(this.source));

      this.validateClosingTag(tagName);

      if(!this.currentTagDetail.root) this.addTextNode();
      this.outputBuilder.closeTag();

      this.currentTagDetail = this.tagsStack.pop(); 
    }

    validateClosingTag(tagName){

      if(this.isUnpaired(tagName) || this.isStopNode(tagName)) throw new Error(`Unexpected closing tag '${tagName}'`);

      else if(tagName !== this.currentTagDetail.name) 
        throw new Error(`Unexpected closing tag '${tagName}' expecting '${this.currentTagDetail.name}'`)
    }

    
    readOpeningTag(){

      this.addTextNode();


      let tagExp = readTagExp(this, ">" );
      

      const tagDetail = new TagDetail(tagExp.tagName);
      if(this.isUnpaired(tagExp.tagName)) {

        this.outputBuilder.addTag(tagDetail);
        this.outputBuilder.closeTag();
      } else if(tagExp.selfClosing){
        this.outputBuilder.addTag(tagDetail);
        this.outputBuilder.closeTag();
      } else if(this.isStopNode(this.currentTagDetail)){


        const content = source.readUptoCloseTag(`</${tagExp.tagName}`);
        this.outputBuilder.addTag(tagDetail);
        this.outputBuilder.addValue(content);
        this.outputBuilder.closeTag();
      }else{//paired tag

        this.tagsStack.push(this.currentTagDetail);
        this.outputBuilder.addTag(tagDetail);
        this.currentTagDetail = tagDetail;
      }



    }

    readSpecialTag(startCh){
      if(startCh == "!"){
        let nextChar = this.source.readCh();
        if (nextChar === null || nextChar === undefined) throw new Error("Unexpected ending of the source");
        
        if(nextChar === "-"){//comment
          readComment(this);
        }else if(nextChar === "["){//CDATA
          readCdata(this);
        }else if(nextChar === "D"){//DOCTYPE
          readDocType(this);
        }
      }else if(startCh === "?"){
        readPiTag(this);
      }else{
        throw new Error(`Invalid tag '<${startCh}' at ${this.source.line}:${this.source.col}`)
      }
    }
    addTextNode = function() {



        if (this.tagTextData !== undefined && this.tagTextData !== "") { //store previously collected data as textNode
          if(this.tagTextData.trim().length > 0){


            this.outputBuilder.addValue(this.replaceEntities(this.tagTextData));
          }
          this.tagTextData = "";
        }

    }

    processAttrName(name){
      if(name === "__proto__") name  = "#__proto__";
      name = resolveNameSpace(name, this.removeNSPrefix);
      return name;
    }
    
    processTagName(name){
      if(name === "__proto__") name  = "#__proto__";
      name = resolveNameSpace(name, this.removeNSPrefix);
      return name;
    }

    
    tagsPath(tagName){

      return "";
    }

    isUnpaired(tagName){
      return this.options.tags.unpaired.indexOf(tagName) !== -1;
    }

    
    isStopNode(node){
      for (let i = 0; i < this.stopNodes.length; i++) {
        const givenPath = this.stopNodes[i];
        if(givenPath.match(this.tagsStack, node)) return true;
      }
      return false 
    }

    replaceEntities(text){

      return this.entityParser.parse(text)
    }
}

function resolveNameSpace(name, removeNSPrefix) {
  if (removeNSPrefix) {
    const parts = name.split(':');
    if(parts.length === 2){
      if (parts[0] === 'xmlns') return '';
      else return parts[1];
    }else reportError(`Multiple namespaces ${name}`)
  }
  return name;
}

