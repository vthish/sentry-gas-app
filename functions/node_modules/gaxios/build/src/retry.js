"use strict";












Object.defineProperty(exports, "__esModule", { value: true });
exports.getRetryConfig = getRetryConfig;
async function getRetryConfig(err) {
    let config = getConfig(err);
    if (!err || !err.config || (!config && !err.config.retry)) {
        return { shouldRetry: false };
    }
    config = config || {};
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    config.retry =
        config.retry === undefined || config.retry === null ? 3 : config.retry;
    config.httpMethodsToRetry = config.httpMethodsToRetry || [
        'GET',
        'HEAD',
        'PUT',
        'OPTIONS',
        'DELETE',
    ];
    config.noResponseRetries =
        config.noResponseRetries === undefined || config.noResponseRetries === null
            ? 2
            : config.noResponseRetries;
    config.retryDelayMultiplier = config.retryDelayMultiplier
        ? config.retryDelayMultiplier
        : 2;
    config.timeOfFirstRequest = config.timeOfFirstRequest
        ? config.timeOfFirstRequest
        : Date.now();
    config.totalTimeout = config.totalTimeout
        ? config.totalTimeout
        : Number.MAX_SAFE_INTEGER;
    config.maxRetryDelay = config.maxRetryDelay
        ? config.maxRetryDelay
        : Number.MAX_SAFE_INTEGER;


    const retryRanges = [








        [100, 199],
        [408, 408],
        [429, 429],
        [500, 599],
    ];
    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;

    err.config.retryConfig = config;

    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;
    if (!(await shouldRetryFn(err))) {
        return { shouldRetry: false, config: err.config };
    }
    const delay = getNextRetryDelay(config);

    err.config.retryConfig.currentRetryAttempt += 1;

    const backoff = config.retryBackoff
        ? config.retryBackoff(err, delay)
        : new Promise(resolve => {
            setTimeout(resolve, delay);
        });

    if (config.onRetryAttempt) {
        config.onRetryAttempt(err);
    }

    await backoff;
    return { shouldRetry: true, config: err.config };
}

function shouldRetryRequest(err) {
    var _a;
    const config = getConfig(err);


    if (err.name === 'AbortError' || ((_a = err.error) === null || _a === void 0 ? void 0 : _a.name) === 'AbortError') {
        return false;
    }

    if (!config || config.retry === 0) {
        return false;
    }

    if (!err.response &&
        (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
        return false;
    }

    if (!err.config.method ||
        config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
        return false;
    }


    if (err.response && err.response.status) {
        let isInRange = false;
        for (const [min, max] of config.statusCodesToRetry) {
            const status = err.response.status;
            if (status >= min && status <= max) {
                isInRange = true;
                break;
            }
        }
        if (!isInRange) {
            return false;
        }
    }

    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    if (config.currentRetryAttempt >= config.retry) {
        return false;
    }
    return true;
}

function getConfig(err) {
    if (err && err.config && err.config.retryConfig) {
        return err.config.retryConfig;
    }
    return;
}

function getNextRetryDelay(config) {
    var _a;


    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100;

    const calculatedDelay = retryDelay +
        ((Math.pow(config.retryDelayMultiplier, config.currentRetryAttempt) - 1) /
            2) *
            1000;
    const maxAllowableDelay = config.totalTimeout - (Date.now() - config.timeOfFirstRequest);
    return Math.min(calculatedDelay, maxAllowableDelay, config.maxRetryDelay);
}

