const require_logger_index = require('../logger/index.js');


var Expression = class {
	
	value() {
		if (process.env.FUNCTIONS_CONTROL_API === "true") {
			require_logger_index.warn(`${this.toString()}.value() invoked during function deployment, instead of during runtime.`);
			require_logger_index.warn(`This is usually a mistake. In configs, use Params directly without calling .value().`);
			require_logger_index.warn(`example: { memory: memoryParam } not { memory: memoryParam.value() }`);
		}
		return this.runtimeValue();
	}
	
	runtimeValue() {
		throw new Error("Not implemented");
	}
	
	toCEL() {
		return `{{ ${this.toString()} }}`;
	}
	
	toJSON() {
		return this.toString();
	}
};
function valueOf(arg) {
	return arg instanceof Expression ? arg.runtimeValue() : arg;
}

function refOf(arg) {
	if (arg instanceof Expression) {
		return arg.toString();
	} else if (typeof arg === "string") {
		return `"${arg}"`;
	} else if (Array.isArray(arg)) {
		return JSON.stringify(arg);
	} else {
		return arg.toString();
	}
}

var TernaryExpression = class extends Expression {
	constructor(test, ifTrue, ifFalse) {
		super();
		this.test = test;
		this.ifTrue = ifTrue;
		this.ifFalse = ifFalse;
		this.ifTrue = ifTrue;
		this.ifFalse = ifFalse;
	}
	
	runtimeValue() {
		return this.test.runtimeValue() ? valueOf(this.ifTrue) : valueOf(this.ifFalse);
	}
	toString() {
		return `${this.test} ? ${refOf(this.ifTrue)} : ${refOf(this.ifFalse)}`;
	}
};

var CompareExpression = class extends Expression {
	constructor(cmp, lhs, rhs) {
		super();
		this.cmp = cmp;
		this.lhs = lhs;
		this.rhs = rhs;
	}
	
	runtimeValue() {
		const left = this.lhs.runtimeValue();
		const right = valueOf(this.rhs);
		switch (this.cmp) {
			case "==": return Array.isArray(left) ? this.arrayEquals(left, right) : left === right;
			case "!=": return Array.isArray(left) ? !this.arrayEquals(left, right) : left !== right;
			case ">": return left > right;
			case ">=": return left >= right;
			case "<": return left < right;
			case "<=": return left <= right;
			default: throw new Error(`Unknown comparator ${this.cmp}`);
		}
	}
	
	arrayEquals(a, b) {
		return a.every((item) => b.includes(item)) && b.every((item) => a.includes(item));
	}
	toString() {
		const rhsStr = refOf(this.rhs);
		return `${this.lhs} ${this.cmp} ${rhsStr}`;
	}
	
	thenElse(ifTrue, ifFalse) {
		return new TernaryExpression(this, ifTrue, ifFalse);
	}
};

function select(options) {
	let wireOpts;
	if (Array.isArray(options)) {
		wireOpts = options.map((opt) => ({ value: opt }));
	} else {
		wireOpts = Object.entries(options).map(([label, value]) => ({
			label,
			value
		}));
	}
	return { select: { options: wireOpts } };
}

function multiSelect(options) {
	let wireOpts;
	if (Array.isArray(options)) {
		wireOpts = options.map((opt) => ({ value: opt }));
	} else {
		wireOpts = Object.entries(options).map(([label, value]) => ({
			label,
			value
		}));
	}
	return { multiSelect: { options: wireOpts } };
}

const BUCKET_PICKER = { resource: { type: "storage.googleapis.com/Bucket" } };

var Param = class extends Expression {
	static {
		this.type = "string";
	}
	constructor(name, options = {}) {
		super();
		this.name = name;
		this.options = options;
	}
	
	runtimeValue() {
		throw new Error("Not implemented");
	}
	
	cmp(cmp, rhs) {
		return new CompareExpression(cmp, this, rhs);
	}
	
	equals(rhs) {
		return this.cmp("==", rhs);
	}
	
	notEquals(rhs) {
		return this.cmp("!=", rhs);
	}
	
	greaterThan(rhs) {
		return this.cmp(">", rhs);
	}
	
	greaterThanOrEqualTo(rhs) {
		return this.cmp(">=", rhs);
	}
	
	lessThan(rhs) {
		return this.cmp("<", rhs);
	}
	
	lessThanOrEqualTo(rhs) {
		return this.cmp("<=", rhs);
	}
	
	lessThanorEqualTo(rhs) {
		return this.lessThanOrEqualTo(rhs);
	}
	toString() {
		return `params.${this.name}`;
	}
	
	toSpec() {
		const { default: paramDefault,...otherOptions } = this.options;
		const out = {
			name: this.name,
			...otherOptions,
			type: this.constructor.type
		};
		if (paramDefault instanceof Expression) {
			out.default = paramDefault.toCEL();
		} else if (paramDefault !== undefined) {
			out.default = paramDefault;
		}
		if (out.input && "text" in out.input && out.input.text.validationRegex instanceof RegExp) {
			out.input.text.validationRegex = out.input.text.validationRegex.source;
		}
		return out;
	}
};

var SecretParam = class {
	static {
		this.type = "secret";
	}
	constructor(name) {
		this.name = name;
	}
	
	runtimeValue() {
		const val = process.env[this.name];
		if (val === undefined) {
			require_logger_index.warn(`No value found for secret parameter "${this.name}". A function can only access a secret if you include the secret in the function's dependency array.`);
		}
		return val || "";
	}
	
	toSpec() {
		return {
			type: "secret",
			name: this.name
		};
	}
	
	value() {
		if (process.env.FUNCTIONS_CONTROL_API === "true") {
			throw new Error(`Cannot access the value of secret "${this.name}" during function deployment. Secret values are only available at runtime.`);
		}
		return this.runtimeValue();
	}
};

var JsonSecretParam = class {
	static {
		this.type = "secret";
	}
	constructor(name) {
		this.name = name;
	}
	
	runtimeValue() {
		const val = process.env[this.name];
		if (val === undefined) {
			throw new Error(`No value found for secret parameter "${this.name}". A function can only access a secret if you include the secret in the function's dependency array.`);
		}
		try {
			return JSON.parse(val);
		} catch (error) {
			throw new Error(`"${this.name}" could not be parsed as JSON. Please verify its value in Secret Manager. Details: ${error}`);
		}
	}
	
	toSpec() {
		return {
			type: "secret",
			name: this.name,
			format: "json"
		};
	}
	
	value() {
		if (process.env.FUNCTIONS_CONTROL_API === "true") {
			throw new Error(`Cannot access the value of secret "${this.name}" during function deployment. Secret values are only available at runtime.`);
		}
		return this.runtimeValue();
	}
};

var StringParam = class extends Param {
	
	runtimeValue() {
		return process.env[this.name] || "";
	}
};

var InternalExpression = class extends Param {
	constructor(name, getter) {
		super(name);
		this.getter = getter;
	}
	
	runtimeValue() {
		return this.getter(process.env) || "";
	}
	toSpec() {
		throw new Error("An InternalExpression should never be marshalled for wire transmission.");
	}
};

var IntParam = class extends Param {
	static {
		this.type = "int";
	}
	
	runtimeValue() {
		return parseInt(process.env[this.name] || "0", 10) || 0;
	}
};

var FloatParam = class extends Param {
	static {
		this.type = "float";
	}
	
	runtimeValue() {
		return parseFloat(process.env[this.name] || "0") || 0;
	}
};

var BooleanParam = class extends Param {
	static {
		this.type = "boolean";
	}
	
	runtimeValue() {
		return !!process.env[this.name] && process.env[this.name] === "true";
	}
	
	then(ifTrue, ifFalse) {
		return this.thenElse(ifTrue, ifFalse);
	}
	thenElse(ifTrue, ifFalse) {
		return new TernaryExpression(this, ifTrue, ifFalse);
	}
};

var ListParam = class extends Param {
	static {
		this.type = "list";
	}
	
	runtimeValue() {
		const val = JSON.parse(process.env[this.name]);
		if (!Array.isArray(val) || !val.every((v) => typeof v === "string")) {
			return [];
		}
		return val;
	}
	
	greaterThan(rhs) {
		throw new Error(">/< comparison operators not supported on params of type List");
	}
	
	greaterThanOrEqualTo(rhs) {
		throw new Error(">/< comparison operators not supported on params of type List");
	}
	
	lessThan(rhs) {
		throw new Error(">/< comparison operators not supported on params of type List");
	}
	
	lessThanorEqualTo(rhs) {
		throw new Error(">/< comparison operators not supported on params of type List");
	}
};


exports.BUCKET_PICKER = BUCKET_PICKER;
exports.BooleanParam = BooleanParam;
exports.CompareExpression = CompareExpression;
exports.Expression = Expression;
exports.FloatParam = FloatParam;
exports.IntParam = IntParam;
exports.InternalExpression = InternalExpression;
exports.JsonSecretParam = JsonSecretParam;
exports.ListParam = ListParam;
exports.Param = Param;
exports.SecretParam = SecretParam;
exports.StringParam = StringParam;
exports.TernaryExpression = TernaryExpression;
exports.multiSelect = multiSelect;
exports.select = select;
