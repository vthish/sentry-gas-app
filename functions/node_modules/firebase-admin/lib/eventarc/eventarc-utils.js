
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseEventarcError = void 0;
exports.toCloudEventProtoFormat = toCloudEventProtoFormat;
const error_1 = require("../utils/error");
const uuid_1 = require("uuid");
const validator = require("../utils/validator");


const TOP_LEVEL_CE_ATTRS = ['id', 'type', 'specversion', 'source', 'data', 'time', 'datacontenttype', 'subject'];

class FirebaseEventarcError extends error_1.PrefixedFirebaseError {
    constructor(code, message) {
        super('eventarc', code, message);
    }
}
exports.FirebaseEventarcError = FirebaseEventarcError;
function toCloudEventProtoFormat(ce) {
    const source = ce.source ?? process.env.EVENTARC_CLOUD_EVENT_SOURCE;
    if (typeof source === 'undefined' || !validator.isNonEmptyString(source)) {
        throw new FirebaseEventarcError('invalid-argument', "CloudEvent 'source' is required.");
    }
    if (!validator.isNonEmptyString(ce.type)) {
        throw new FirebaseEventarcError('invalid-argument', "CloudEvent 'type' is required.");
    }
    const out = {
        '@type': 'type.googleapis.com/io.cloudevents.v1.CloudEvent',
        'id': ce.id ?? (0, uuid_1.v4)(),
        'type': ce.type,
        'specVersion': ce.specversion ?? '1.0',
        'source': source
    };
    if (typeof ce.time !== 'undefined') {
        if (!validator.isISODateString(ce.time)) {
            throw new FirebaseEventarcError('invalid-argument', "CloudEvent 'tyme' must be in ISO date format.");
        }
        setAttribute(out, 'time', {
            'ceTimestamp': ce.time
        });
    }
    else {
        setAttribute(out, 'time', {
            'ceTimestamp': new Date().toISOString()
        });
    }
    if (typeof ce.datacontenttype !== 'undefined') {
        if (!validator.isNonEmptyString(ce.datacontenttype)) {
            throw new FirebaseEventarcError('invalid-argument', "CloudEvent 'datacontenttype' if specified must be non-empty string.");
        }
        setAttribute(out, 'datacontenttype', {
            'ceString': ce.datacontenttype
        });
    }
    if (ce.subject) {
        if (!validator.isNonEmptyString(ce.subject)) {
            throw new FirebaseEventarcError('invalid-argument', "CloudEvent 'subject' if specified must be non-empty string.");
        }
        setAttribute(out, 'subject', {
            'ceString': ce.subject
        });
    }
    if (typeof ce.data === 'undefined') {
        throw new FirebaseEventarcError('invalid-argument', "CloudEvent 'data' is required.");
    }
    if (validator.isObject(ce.data)) {
        out['textData'] = JSON.stringify(ce.data);
        if (!ce.datacontenttype) {
            setAttribute(out, 'datacontenttype', {
                'ceString': 'application/json'
            });
        }
    }
    else if (validator.isNonEmptyString(ce.data)) {
        out['textData'] = ce.data;
        if (!ce.datacontenttype) {
            setAttribute(out, 'datacontenttype', {
                'ceString': 'text/plain'
            });
        }
    }
    else {
        throw new FirebaseEventarcError('invalid-argument', `CloudEvent 'data' must be string or an object (which are converted to JSON), got '${typeof ce.data}'.`);
    }
    for (const attr in ce) {
        if (TOP_LEVEL_CE_ATTRS.includes(attr)) {
            continue;
        }
        if (!validator.isNonEmptyString(ce[attr])) {
            throw new FirebaseEventarcError('invalid-argument', `CloudEvent extension attributes ('${attr}') must be string.`);
        }
        setAttribute(out, attr, {
            'ceString': ce[attr]
        });
    }
    return out;
}
function setAttribute(event, attr, value) {
    if (!Object.prototype.hasOwnProperty.call(event, 'attributes')) {
        event.attributes = {};
    }
    event['attributes'][attr] = value;
}

