
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = exports.MachineLearning = void 0;
const index_1 = require("../storage/index");
const error_1 = require("../utils/error");
const validator = require("../utils/validator");
const deep_copy_1 = require("../utils/deep-copy");
const utils = require("../utils");
const machine_learning_api_client_1 = require("./machine-learning-api-client");
const machine_learning_utils_1 = require("./machine-learning-utils");

class MachineLearning {
    
    constructor(app) {
        if (!validator.isNonNullObject(app) || !('options' in app)) {
            throw new error_1.FirebaseError({
                code: 'machine-learning/invalid-argument',
                message: 'First argument passed to admin.machineLearning() must be a ' +
                    'valid Firebase app instance.',
            });
        }
        this.appInternal = app;
        this.client = new machine_learning_api_client_1.MachineLearningApiClient(app);
    }
    
    get app() {
        return this.appInternal;
    }
    
    createModel(model) {
        return this.signUrlIfPresent(model)
            .then((modelContent) => this.client.createModel(modelContent))
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client));
    }
    
    updateModel(modelId, model) {
        const updateMask = utils.generateUpdateMask(model);
        return this.signUrlIfPresent(model)
            .then((modelContent) => this.client.updateModel(modelId, modelContent, updateMask))
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client));
    }
    
    publishModel(modelId) {
        return this.setPublishStatus(modelId, true);
    }
    
    unpublishModel(modelId) {
        return this.setPublishStatus(modelId, false);
    }
    
    getModel(modelId) {
        return this.client.getModel(modelId)
            .then((modelResponse) => new Model(modelResponse, this.client));
    }
    
    listModels(options = {}) {
        return this.client.listModels(options)
            .then((resp) => {
            if (!validator.isNonNullObject(resp)) {
                throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', `Invalid ListModels response: ${JSON.stringify(resp)}`);
            }
            let models = [];
            if (resp.models) {
                models = resp.models.map((rs) => new Model(rs, this.client));
            }
            const result = { models };
            if (resp.nextPageToken) {
                result.pageToken = resp.nextPageToken;
            }
            return result;
        });
    }
    
    deleteModel(modelId) {
        return this.client.deleteModel(modelId);
    }
    setPublishStatus(modelId, publish) {
        const updateMask = ['state.published'];
        const options = { state: { published: publish } };
        return this.client.updateModel(modelId, options, updateMask)
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client));
    }
    signUrlIfPresent(options) {
        const modelOptions = (0, deep_copy_1.deepCopy)(options);
        if ((0, machine_learning_api_client_1.isGcsTfliteModelOptions)(modelOptions)) {
            return this.signUrl(modelOptions.tfliteModel.gcsTfliteUri)
                .then((uri) => {
                modelOptions.tfliteModel.gcsTfliteUri = uri;
                return modelOptions;
            })
                .catch((err) => {
                throw new machine_learning_utils_1.FirebaseMachineLearningError('internal-error', `Error during signing upload url: ${err.message}`);
            });
        }
        return Promise.resolve(modelOptions);
    }
    signUrl(unsignedUrl) {
        const MINUTES_IN_MILLIS = 60 * 1000;
        const URL_VALID_DURATION = 10 * MINUTES_IN_MILLIS;
        const gcsRegex = /^gs:\/\/([a-z0-9_.-]{3,63})\/(.+)$/;
        const matches = gcsRegex.exec(unsignedUrl);
        if (!matches) {
            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', `Invalid unsigned url: ${unsignedUrl}`);
        }
        const bucketName = matches[1];
        const blobName = matches[2];
        const bucket = (0, index_1.getStorage)(this.app).bucket(bucketName);
        const blob = bucket.file(blobName);
        return blob.getSignedUrl({
            action: 'read',
            expires: Date.now() + URL_VALID_DURATION,
        }).then((signUrl) => signUrl[0]);
    }
}
exports.MachineLearning = MachineLearning;

class Model {
    
    constructor(model, client) {
        this.model = Model.validateAndClone(model);
        this.client = client;
    }
    
    get modelId() {
        return extractModelId(this.model.name);
    }
    
    get displayName() {
        return this.model.displayName;
    }
    
    get tags() {
        return this.model.tags || [];
    }
    
    get createTime() {
        return new Date(this.model.createTime).toUTCString();
    }
    
    get updateTime() {
        return new Date(this.model.updateTime).toUTCString();
    }
    
    get validationError() {
        return this.model.state?.validationError?.message;
    }
    
    get published() {
        return this.model.state?.published || false;
    }
    
    get etag() {
        return this.model.etag;
    }
    
    get modelHash() {
        return this.model.modelHash;
    }
    
    get tfliteModel() {

        return (0, deep_copy_1.deepCopy)(this.model.tfliteModel);
    }
    
    get locked() {
        return (this.model.activeOperations?.length ?? 0) > 0;
    }
    
    toJSON() {


        const jsonModel = {
            modelId: this.modelId,
            displayName: this.displayName,
            tags: this.tags,
            createTime: this.createTime,
            updateTime: this.updateTime,
            published: this.published,
            etag: this.etag,
            locked: this.locked,
        };

        if (this.validationError) {
            jsonModel['validationError'] = this.validationError;
        }
        if (this.modelHash) {
            jsonModel['modelHash'] = this.modelHash;
        }
        if (this.tfliteModel) {
            jsonModel['tfliteModel'] = this.tfliteModel;
        }
        return jsonModel;
    }
    
    waitForUnlocked(maxTimeMillis) {
        if ((this.model.activeOperations?.length ?? 0) > 0) {



            return this.client.handleOperation(this.model.activeOperations[0], { wait: true, maxTimeMillis })
                .then((modelResponse) => {
                this.model = Model.validateAndClone(modelResponse);
            });
        }
        return Promise.resolve();
    }
    static validateAndClone(model) {
        if (!validator.isNonNullObject(model) ||
            !validator.isNonEmptyString(model.name) ||
            !validator.isNonEmptyString(model.createTime) ||
            !validator.isNonEmptyString(model.updateTime) ||
            !validator.isNonEmptyString(model.displayName) ||
            !validator.isNonEmptyString(model.etag)) {
            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', `Invalid Model response: ${JSON.stringify(model)}`);
        }
        const tmpModel = (0, deep_copy_1.deepCopy)(model);

        if (model.tfliteModel &&
            !validator.isNonEmptyString(model.tfliteModel.gcsTfliteUri)) {

            delete tmpModel.tfliteModel;
        }

        if (tmpModel['@type']) {
            delete tmpModel['@type'];
        }
        return tmpModel;
    }
}
exports.Model = Model;
function extractModelId(resourceName) {
    return resourceName.split('/').pop();
}

