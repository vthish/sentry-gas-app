
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseRemoteConfigError = exports.RemoteConfigApiClient = void 0;
const api_request_1 = require("../utils/api-request");
const error_1 = require("../utils/error");
const utils = require("../utils/index");
const validator = require("../utils/validator");
const deep_copy_1 = require("../utils/deep-copy");


const FIREBASE_REMOTE_CONFIG_URL_BASE = process.env.FIREBASE_REMOTE_CONFIG_URL_BASE || 'https://firebaseremoteconfig.googleapis.com';
const FIREBASE_REMOTE_CONFIG_HEADERS = {
    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`,




    'Accept-Encoding': 'gzip',
};

class RemoteConfigApiClient {
    constructor(app) {
        this.app = app;
        if (!validator.isNonNullObject(app) || !('options' in app)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');
        }
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
    }
    getTemplate() {
        return this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/remoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    getTemplateAtVersion(versionNumber) {
        const data = { versionNumber: this.validateVersionNumber(versionNumber) };
        return this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/remoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    validateTemplate(template) {
        template = this.validateInputRemoteConfigTemplate(template);
        return this.sendPutRequest(template, template.etag, true)
            .then((resp) => {



            this.validateEtag(resp.headers['etag']);
            return this.toRemoteConfigTemplate(resp, template.etag);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    publishTemplate(template, options) {
        template = this.validateInputRemoteConfigTemplate(template);
        let ifMatch = template.etag;
        if (options && options.force === true) {


            ifMatch = '*';
        }
        return this.sendPutRequest(template, ifMatch)
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    rollback(versionNumber) {
        const data = { versionNumber: this.validateVersionNumber(versionNumber) };
        return this.getUrl()
            .then((url) => {
            const request = {
                method: 'POST',
                url: `${url}/remoteConfig:rollback`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    listVersions(options) {
        if (typeof options !== 'undefined') {
            options = this.validateListVersionsOptions(options);
        }
        return this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/remoteConfig:listVersions`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data: options
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return resp.data;
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    getServerTemplate() {
        return this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/namespaces/firebase-server/serverRemoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigServerTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        });
    }
    sendPutRequest(template, etag, validateOnly) {
        let path = 'remoteConfig';
        if (validateOnly) {
            path += '?validate_only=true';
        }
        return this.getUrl()
            .then((url) => {
            const request = {
                method: 'PUT',
                url: `${url}/${path}`,
                headers: { ...FIREBASE_REMOTE_CONFIG_HEADERS, 'If-Match': etag },
                data: {
                    conditions: template.conditions,
                    parameters: template.parameters,
                    parameterGroups: template.parameterGroups,
                    version: template.version,
                }
            };
            return this.httpClient.send(request);
        });
    }
    getUrl() {
        return this.getProjectIdPrefix()
            .then((projectIdPrefix) => {
            return `${FIREBASE_REMOTE_CONFIG_URL_BASE}/v1/${projectIdPrefix}`;
        });
    }
    getProjectIdPrefix() {
        if (this.projectIdPrefix) {
            return Promise.resolve(this.projectIdPrefix);
        }
        return utils.findProjectId(this.app)
            .then((projectId) => {
            if (!validator.isNonEmptyString(projectId)) {
                throw new FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
                    + 'environment variable.');
            }
            this.projectIdPrefix = `projects/${projectId}`;
            return this.projectIdPrefix;
        });
    }
    toFirebaseError(err) {
        if (err instanceof error_1.PrefixedFirebaseError) {
            return err;
        }
        const response = err.response;
        if (!response.isJson()) {
            return new FirebaseRemoteConfigError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);
        }
        const error = response.data.error || {};
        let code = 'unknown-error';
        if (error.status && error.status in ERROR_CODE_MAPPING) {
            code = ERROR_CODE_MAPPING[error.status];
        }
        const message = error.message || `Unknown server error: ${response.text}`;
        return new FirebaseRemoteConfigError(code, message);
    }
    
    toRemoteConfigTemplate(resp, customEtag) {
        const etag = (typeof customEtag === 'undefined') ? resp.headers['etag'] : customEtag;
        this.validateEtag(etag);
        return {
            conditions: resp.data.conditions,
            parameters: resp.data.parameters,
            parameterGroups: resp.data.parameterGroups,
            etag,
            version: resp.data.version,
        };
    }
    
    toRemoteConfigServerTemplate(resp, customEtag) {
        const etag = (typeof customEtag === 'undefined') ? resp.headers['etag'] : customEtag;
        this.validateEtag(etag);
        return {
            conditions: resp.data.conditions,
            parameters: resp.data.parameters,
            etag,
            version: resp.data.version,
        };
    }
    
    validateInputRemoteConfigTemplate(template) {
        const templateCopy = (0, deep_copy_1.deepCopy)(template);
        if (!validator.isNonNullObject(templateCopy)) {
            throw new FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(templateCopy)}`);
        }
        if (!validator.isNonEmptyString(templateCopy.etag)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');
        }
        if (!validator.isNonNullObject(templateCopy.parameters)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
        }
        if (!validator.isNonNullObject(templateCopy.parameterGroups)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');
        }
        if (!validator.isArray(templateCopy.conditions)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
        }
        if (typeof templateCopy.version !== 'undefined') {

            templateCopy.version = { description: templateCopy.version.description };
        }
        return templateCopy;
    }
    
    validateVersionNumber(versionNumber, propertyName = 'versionNumber') {
        if (!validator.isNonEmptyString(versionNumber) &&
            !validator.isNumber(versionNumber)) {
            throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be a non-empty string in int64 format or a number`);
        }
        if (!Number.isInteger(Number(versionNumber))) {
            throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be an integer or a string in int64 format`);
        }
        return versionNumber.toString();
    }
    validateEtag(etag) {
        if (!validator.isNonEmptyString(etag)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');
        }
    }
    
    validateListVersionsOptions(options) {
        const optionsCopy = (0, deep_copy_1.deepCopy)(options);
        if (!validator.isNonNullObject(optionsCopy)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');
        }
        if (typeof optionsCopy.pageSize !== 'undefined') {
            if (!validator.isNumber(optionsCopy.pageSize)) {
                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');
            }
            if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) {
                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');
            }
        }
        if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) {
            throw new FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');
        }
        if (typeof optionsCopy.endVersionNumber !== 'undefined') {
            optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');
        }
        if (typeof optionsCopy.startTime !== 'undefined') {
            if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) {
                throw new FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');
            }

            if (optionsCopy.startTime instanceof Date) {
                optionsCopy.startTime = optionsCopy.startTime.toISOString();
            }
            else {
                optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();
            }
        }
        if (typeof optionsCopy.endTime !== 'undefined') {
            if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) {
                throw new FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');
            }

            if (optionsCopy.endTime instanceof Date) {
                optionsCopy.endTime = optionsCopy.endTime.toISOString();
            }
            else {
                optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();
            }
        }

        Object.keys(optionsCopy).forEach(key => (typeof optionsCopy[key] === 'undefined') && delete optionsCopy[key]);
        return optionsCopy;
    }
}
exports.RemoteConfigApiClient = RemoteConfigApiClient;
const ERROR_CODE_MAPPING = {
    ABORTED: 'aborted',
    ALREADY_EXISTS: 'already-exists',
    INVALID_ARGUMENT: 'invalid-argument',
    INTERNAL: 'internal-error',
    FAILED_PRECONDITION: 'failed-precondition',
    NOT_FOUND: 'not-found',
    OUT_OF_RANGE: 'out-of-range',
    PERMISSION_DENIED: 'permission-denied',
    RESOURCE_EXHAUSTED: 'resource-exhausted',
    UNAUTHENTICATED: 'unauthenticated',
    UNKNOWN: 'unknown-error',
};

class FirebaseRemoteConfigError extends error_1.PrefixedFirebaseError {
    constructor(code, message) {
        super('remote-config', code, message);
    }
}
exports.FirebaseRemoteConfigError = FirebaseRemoteConfigError;

