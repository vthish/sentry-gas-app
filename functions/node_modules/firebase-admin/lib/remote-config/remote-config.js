
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteConfigFetchResponse = exports.RemoteConfig = void 0;
const utils = require("../utils/index");
const validator = require("../utils/validator");
const remote_config_api_client_internal_1 = require("./remote-config-api-client-internal");
const condition_evaluator_internal_1 = require("./condition-evaluator-internal");
const value_impl_1 = require("./internal/value-impl");

class RemoteConfig {
    
    constructor(app) {
        this.app = app;
        this.client = new remote_config_api_client_internal_1.RemoteConfigApiClient(app);
    }
    
    getTemplate() {
        return this.client.getTemplate()
            .then((templateResponse) => {
            return new RemoteConfigTemplateImpl(templateResponse);
        });
    }
    
    getTemplateAtVersion(versionNumber) {
        return this.client.getTemplateAtVersion(versionNumber)
            .then((templateResponse) => {
            return new RemoteConfigTemplateImpl(templateResponse);
        });
    }
    
    validateTemplate(template) {
        return this.client.validateTemplate(template)
            .then((templateResponse) => {
            return new RemoteConfigTemplateImpl(templateResponse);
        });
    }
    
    publishTemplate(template, options) {
        return this.client.publishTemplate(template, options)
            .then((templateResponse) => {
            return new RemoteConfigTemplateImpl(templateResponse);
        });
    }
    
    rollback(versionNumber) {
        return this.client.rollback(versionNumber)
            .then((templateResponse) => {
            return new RemoteConfigTemplateImpl(templateResponse);
        });
    }
    
    listVersions(options) {
        return this.client.listVersions(options)
            .then((listVersionsResponse) => {
            return {
                versions: listVersionsResponse.versions?.map(version => new VersionImpl(version)) ?? [],
                nextPageToken: listVersionsResponse.nextPageToken,
            };
        });
    }
    
    createTemplateFromJSON(json) {
        if (!validator.isNonEmptyString(json)) {
            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'JSON string must be a valid non-empty string');
        }
        let template;
        try {
            template = JSON.parse(json);
        }
        catch (e) {
            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Failed to parse the JSON string: ${json}. ` + e);
        }
        return new RemoteConfigTemplateImpl(template);
    }
    
    async getServerTemplate(options) {
        const template = this.initServerTemplate(options);
        await template.load();
        return template;
    }
    
    initServerTemplate(options) {
        const template = new ServerTemplateImpl(this.client, new condition_evaluator_internal_1.ConditionEvaluator(), options?.defaultConfig);
        if (options?.template) {
            template.set(options?.template);
        }
        return template;
    }
}
exports.RemoteConfig = RemoteConfig;

class RemoteConfigTemplateImpl {
    constructor(config) {
        if (!validator.isNonNullObject(config) ||
            !validator.isNonEmptyString(config.etag)) {
            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(config)}`);
        }
        this.etagInternal = config.etag;
        if (typeof config.parameters !== 'undefined') {
            if (!validator.isNonNullObject(config.parameters)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
            }
            this.parameters = config.parameters;
        }
        else {
            this.parameters = {};
        }
        if (typeof config.parameterGroups !== 'undefined') {
            if (!validator.isNonNullObject(config.parameterGroups)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');
            }
            this.parameterGroups = config.parameterGroups;
        }
        else {
            this.parameterGroups = {};
        }
        if (typeof config.conditions !== 'undefined') {
            if (!validator.isArray(config.conditions)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
            }
            this.conditions = config.conditions;
        }
        else {
            this.conditions = [];
        }
        if (typeof config.version !== 'undefined') {
            this.version = new VersionImpl(config.version);
        }
    }
    
    get etag() {
        return this.etagInternal;
    }
    
    toJSON() {
        return {
            conditions: this.conditions,
            parameters: this.parameters,
            parameterGroups: this.parameterGroups,
            etag: this.etag,
            version: this.version,
        };
    }
}

class ServerTemplateImpl {
    constructor(apiClient, conditionEvaluator, defaultConfig = {}) {
        this.apiClient = apiClient;
        this.conditionEvaluator = conditionEvaluator;
        this.defaultConfig = defaultConfig;
        this.stringifiedDefaultConfig = {};



        for (const key in defaultConfig) {
            this.stringifiedDefaultConfig[key] = String(defaultConfig[key]);
        }
    }
    
    load() {
        return this.apiClient.getServerTemplate()
            .then((template) => {
            this.cache = new ServerTemplateDataImpl(template);
        });
    }
    
    set(template) {
        let parsed;
        if (validator.isString(template)) {
            try {
                parsed = JSON.parse(template);
            }
            catch (e) {

                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Failed to parse the JSON string: ${template}. ` + e);
            }
        }
        else {
            parsed = template;
        }

        this.cache = new ServerTemplateDataImpl(parsed);
    }
    
    evaluate(context = {}) {
        if (!this.cache) {



            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('failed-precondition', 'No Remote Config Server template in cache. Call load() before calling evaluate().');
        }
        const evaluatedConditions = this.conditionEvaluator.evaluateConditions(this.cache.conditions, context);
        const configValues = {};

        for (const key in this.stringifiedDefaultConfig) {
            configValues[key] = new value_impl_1.ValueImpl('default', this.stringifiedDefaultConfig[key]);
        }

        for (const [key, parameter] of Object.entries(this.cache.parameters)) {
            const { conditionalValues, defaultValue } = parameter;

            const normalizedConditionalValues = conditionalValues || {};
            let parameterValueWrapper = undefined;


            for (const [conditionName, conditionEvaluation] of evaluatedConditions) {
                if (normalizedConditionalValues[conditionName] && conditionEvaluation) {
                    parameterValueWrapper = normalizedConditionalValues[conditionName];
                    break;
                }
            }
            if (parameterValueWrapper && parameterValueWrapper.useInAppDefault) {

                continue;
            }
            if (parameterValueWrapper) {
                const parameterValue = parameterValueWrapper.value;
                configValues[key] = new value_impl_1.ValueImpl('remote', parameterValue);
                continue;
            }
            if (!defaultValue) {

                continue;
            }
            if (defaultValue.useInAppDefault) {

                continue;
            }
            const parameterDefaultValue = defaultValue.value;
            configValues[key] = new value_impl_1.ValueImpl('remote', parameterDefaultValue);
        }
        return new ServerConfigImpl(configValues);
    }
    
    toJSON() {
        return this.cache;
    }
}
class ServerConfigImpl {
    constructor(configValues) {
        this.configValues = configValues;
    }
    getBoolean(key) {
        return this.getValue(key).asBoolean();
    }
    getNumber(key) {
        return this.getValue(key).asNumber();
    }
    getString(key) {
        return this.getValue(key).asString();
    }
    getValue(key) {
        return this.configValues[key] || new value_impl_1.ValueImpl('static');
    }
    getAll() {
        return { ...this.configValues };
    }
}

class ServerTemplateDataImpl {
    constructor(template) {
        if (!validator.isNonNullObject(template) ||
            !validator.isNonEmptyString(template.etag)) {
            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(template)}`);
        }
        this.etag = template.etag;
        if (typeof template.parameters !== 'undefined') {
            if (!validator.isNonNullObject(template.parameters)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
            }
            this.parameters = template.parameters;
        }
        else {
            this.parameters = {};
        }
        if (typeof template.conditions !== 'undefined') {
            if (!validator.isArray(template.conditions)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
            }
            this.conditions = template.conditions;
        }
        else {
            this.conditions = [];
        }
        if (typeof template.version !== 'undefined') {
            this.version = new VersionImpl(template.version);
        }
    }
}

class VersionImpl {
    constructor(version) {
        if (!validator.isNonNullObject(version)) {
            throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config version instance: ${JSON.stringify(version)}`);
        }
        if (typeof version.versionNumber !== 'undefined') {
            if (!validator.isNonEmptyString(version.versionNumber) &&
                !validator.isNumber(version.versionNumber)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be a non-empty string in int64 format or a number');
            }
            if (!Number.isInteger(Number(version.versionNumber))) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be an integer or a string in int64 format');
            }
            this.versionNumber = version.versionNumber;
        }
        if (typeof version.updateOrigin !== 'undefined') {
            if (!validator.isNonEmptyString(version.updateOrigin)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update origin must be a non-empty string');
            }
            this.updateOrigin = version.updateOrigin;
        }
        if (typeof version.updateType !== 'undefined') {
            if (!validator.isNonEmptyString(version.updateType)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update type must be a non-empty string');
            }
            this.updateType = version.updateType;
        }
        if (typeof version.updateUser !== 'undefined') {
            if (!validator.isNonNullObject(version.updateUser)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update user must be a non-null object');
            }
            this.updateUser = version.updateUser;
        }
        if (typeof version.description !== 'undefined') {
            if (!validator.isNonEmptyString(version.description)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version description must be a non-empty string');
            }
            this.description = version.description;
        }
        if (typeof version.rollbackSource !== 'undefined') {
            if (!validator.isNonEmptyString(version.rollbackSource)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version rollback source must be a non-empty string');
            }
            this.rollbackSource = version.rollbackSource;
        }
        if (typeof version.isLegacy !== 'undefined') {
            if (!validator.isBoolean(version.isLegacy)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version.isLegacy must be a boolean');
            }
            this.isLegacy = version.isLegacy;
        }



        if (typeof version.updateTime !== 'undefined') {
            if (!this.isValidTimestamp(version.updateTime)) {
                throw new remote_config_api_client_internal_1.FirebaseRemoteConfigError('invalid-argument', 'Version update time must be a valid date string');
            }
            this.updateTime = new Date(version.updateTime).toUTCString();
        }
    }
    
    toJSON() {
        return {
            versionNumber: this.versionNumber,
            updateOrigin: this.updateOrigin,
            updateType: this.updateType,
            updateUser: this.updateUser,
            description: this.description,
            rollbackSource: this.rollbackSource,
            isLegacy: this.isLegacy,
            updateTime: this.updateTime,
        };
    }
    isValidTimestamp(timestamp) {


        return validator.isNonEmptyString(timestamp) && (new Date(timestamp)).getTime() > 0;
    }
}
const HTTP_NOT_MODIFIED = 304;
const HTTP_OK = 200;

class RemoteConfigFetchResponse {
    
    constructor(app, serverConfig, requestEtag) {
        const config = {};
        for (const [param, value] of Object.entries(serverConfig.getAll())) {
            config[param] = value.asString();
        }
        const currentEtag = this.processEtag(config, app);
        if (currentEtag === requestEtag) {
            this.response = {
                status: HTTP_NOT_MODIFIED,
                eTag: currentEtag,
            };
        }
        else {
            this.response = {
                status: HTTP_OK,
                eTag: currentEtag,
                config,
            };
        }
    }
    
    toJSON() {
        return this.response;
    }
    processEtag(config, app) {
        const configJson = JSON.stringify(config);
        let hash = 0;

        for (let i = 0; i < configJson.length; i++) {
            const char = configJson.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0;
        }
        const projectId = utils.getExplicitProjectId(app);
        const parts = ['etag', projectId, 'firebase-server', 'fetch', hash];
        return parts.filter(a => !!a).join('-');
    }
}
exports.RemoteConfigFetchResponse = RemoteConfigFetchResponse;

