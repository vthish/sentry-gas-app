
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.IAMSigner = exports.ServiceAccountSigner = void 0;
exports.cryptoSignerFromApp = cryptoSignerFromApp;
const credential_internal_1 = require("../app/credential-internal");
const api_request_1 = require("./api-request");
const utils = require("../utils/index");
const validator = require("../utils/validator");
const ALGORITHM_RS256 = 'RS256';

class ServiceAccountSigner {
    
    constructor(credential) {
        this.credential = credential;
        this.algorithm = ALGORITHM_RS256;
        if (!credential) {
            throw new CryptoSignerError({
                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
                message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.',
            });
        }
    }
    
    sign(buffer) {
        const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires
        const sign = crypto.createSign('RSA-SHA256');
        sign.update(buffer);
        return Promise.resolve(sign.sign(this.credential.privateKey));
    }
    
    getAccountId() {
        return Promise.resolve(this.credential.clientEmail);
    }
}
exports.ServiceAccountSigner = ServiceAccountSigner;

class IAMSigner {
    constructor(httpClient, app) {
        this.algorithm = ALGORITHM_RS256;
        if (!httpClient) {
            throw new CryptoSignerError({
                code: CryptoSignerErrorCode.INVALID_ARGUMENT,
                message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.',
            });
        }
        if (app && (typeof app !== 'object' || app === null || !('options' in app))) {
            throw new CryptoSignerError({
                code: CryptoSignerErrorCode.INVALID_ARGUMENT,
                message: 'INTERNAL ASSERT: Must provide a valid Firebase app instance.',
            });
        }
        this.httpClient = httpClient;
        this.app = app;
    }
    
    sign(buffer) {
        return this.getAccountId().then((serviceAccount) => {
            const request = {
                method: 'POST',
                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,
                data: { payload: buffer.toString('base64') },
            };
            return this.httpClient.send(request);
        }).then((response) => {

            return Buffer.from(response.data.signedBlob, 'base64');
        }).catch((err) => {
            if (err instanceof api_request_1.RequestResponseError) {
                throw new CryptoSignerError({
                    code: CryptoSignerErrorCode.SERVER_ERROR,
                    message: err.message,
                    cause: err
                });
            }
            throw err;
        });
    }
    
    async getAccountId() {
        if (validator.isNonEmptyString(this.serviceAccountId)) {
            return this.serviceAccountId;
        }
        if (this.app) {
            const accountId = await utils.findServiceAccountEmail(this.app);
            if (accountId) {
                this.serviceAccountId = accountId;
                return accountId;
            }
        }
        const request = {
            method: 'GET',
            url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',
            headers: {
                'Metadata-Flavor': 'Google',
            },
        };
        const client = new api_request_1.HttpClient();
        return client.send(request).then((response) => {
            if (!response.text) {
                throw new CryptoSignerError({
                    code: CryptoSignerErrorCode.INTERNAL_ERROR,
                    message: 'HTTP Response missing payload',
                });
            }
            this.serviceAccountId = response.text;
            return response.text;
        }).catch((err) => {
            throw new CryptoSignerError({
                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
                message: 'Failed to determine service account. Make sure to initialize ' +
                    'the SDK with a service account credential. Alternatively specify a service ' +
                    `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`,
            });
        });
    }
}
exports.IAMSigner = IAMSigner;

function cryptoSignerFromApp(app) {
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return new ServiceAccountSigner(credential);
    }
    return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app);
}

class CryptoSignerError extends Error {
    constructor(errorInfo) {
        super(errorInfo.message);
        this.errorInfo = errorInfo;
        


        
        this.__proto__ = CryptoSignerError.prototype;
    }
    
    get code() {
        return this.errorInfo.code;
    }
    
    get message() {
        return this.errorInfo.message;
    }
    
    get cause() {
        return this.errorInfo.cause;
    }
}
exports.CryptoSignerError = CryptoSignerError;

class CryptoSignerErrorCode {
}
exports.CryptoSignerErrorCode = CryptoSignerErrorCode;
CryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';
CryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';
CryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';
CryptoSignerErrorCode.SERVER_ERROR = 'server-error';

