
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getSdkVersion = getSdkVersion;
exports.getMetricsHeader = getMetricsHeader;
exports.renameProperties = renameProperties;
exports.addReadonlyGetter = addReadonlyGetter;
exports.getExplicitProjectId = getExplicitProjectId;
exports.findProjectId = findProjectId;
exports.getExplicitServiceAccountEmail = getExplicitServiceAccountEmail;
exports.findServiceAccountEmail = findServiceAccountEmail;
exports.toWebSafeBase64 = toWebSafeBase64;
exports.formatString = formatString;
exports.generateUpdateMask = generateUpdateMask;
exports.transformMillisecondsToSecondsString = transformMillisecondsToSecondsString;
exports.parseResourceName = parseResourceName;
const credential_internal_1 = require("../app/credential-internal");
const validator = require("./validator");
let sdkVersion;

function getSdkVersion() {
    if (!sdkVersion) {
        const { version } = require('../../package.json'); // eslint-disable-line @typescript-eslint/no-var-requires
        sdkVersion = version;
    }
    return sdkVersion;
}
function getMetricsHeader() {
    return `gl-node/${process.versions.node} fire-admin/${getSdkVersion()}`;
}

function renameProperties(obj, keyMap) {
    Object.keys(keyMap).forEach((oldKey) => {
        if (oldKey in obj) {
            const newKey = keyMap[oldKey];

            obj[newKey] = obj[oldKey];
            delete obj[oldKey];
        }
    });
}

function addReadonlyGetter(obj, prop, value) {
    Object.defineProperty(obj, prop, {
        value,

        writable: false,

        enumerable: true,
    });
}

function getExplicitProjectId(app) {
    const options = app.options;
    if (validator.isNonEmptyString(options.projectId)) {
        return options.projectId;
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.projectId;
    }
    const projectId = process.env.GOOGLE_CLOUD_PROJECT || process.env.GCLOUD_PROJECT;
    if (validator.isNonEmptyString(projectId)) {
        return projectId;
    }
    return null;
}

function findProjectId(app) {
    const projectId = getExplicitProjectId(app);
    if (projectId) {
        return Promise.resolve(projectId);
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ApplicationDefaultCredential) {
        return credential.getProjectId();
    }
    return Promise.resolve(null);
}

function getExplicitServiceAccountEmail(app) {
    const options = app.options;
    if (validator.isNonEmptyString(options.serviceAccountId)) {
        return options.serviceAccountId;
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.clientEmail;
    }
    return null;
}

function findServiceAccountEmail(app) {
    const accountId = getExplicitServiceAccountEmail(app);
    if (accountId) {
        return Promise.resolve(accountId);
    }
    const credential = app.options.credential;
    if (credential instanceof credential_internal_1.ApplicationDefaultCredential) {
        return credential.getServiceAccountEmail();
    }
    return Promise.resolve(null);
}

function toWebSafeBase64(data) {
    return data.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
}

function formatString(str, params) {
    let formatted = str;
    Object.keys(params || {}).forEach((key) => {
        formatted = formatted.replace(new RegExp('{' + key + '}', 'g'), params[key]);
    });
    return formatted;
}

function generateUpdateMask(obj, terminalPaths = [], root = '') {
    const updateMask = [];
    if (!validator.isNonNullObject(obj)) {
        return updateMask;
    }
    for (const key in obj) {
        if (typeof obj[key] !== 'undefined') {
            const nextPath = root ? `${root}.${key}` : key;


            if (terminalPaths.indexOf(nextPath) !== -1) {

                updateMask.push(key);
            }
            else {
                const maskList = generateUpdateMask(obj[key], terminalPaths, nextPath);
                if (maskList.length > 0) {
                    maskList.forEach((mask) => {
                        updateMask.push(`${key}.${mask}`);
                    });
                }
                else {
                    updateMask.push(key);
                }
            }
        }
    }
    return updateMask;
}

function transformMillisecondsToSecondsString(milliseconds) {
    let duration;
    const seconds = Math.floor(milliseconds / 1000);
    const nanos = Math.floor((milliseconds - seconds * 1000) * 1000000);
    if (nanos > 0) {
        let nanoString = nanos.toString();
        while (nanoString.length < 9) {
            nanoString = '0' + nanoString;
        }
        duration = `${seconds}.${nanoString}s`;
    }
    else {
        duration = `${seconds}s`;
    }
    return duration;
}

function parseResourceName(resourceName, resourceIdKey) {
    if (!resourceName.includes('/')) {
        return { resourceId: resourceName };
    }
    const CHANNEL_NAME_REGEX = new RegExp(`^(projects/([^/]+)/)?locations/([^/]+)/${resourceIdKey}/([^/]+)$`);
    const match = CHANNEL_NAME_REGEX.exec(resourceName);
    if (match === null) {
        throw new Error('Invalid resource name format.');
    }
    const projectId = match[2];
    const locationId = match[3];
    const resourceId = match[4];
    return { projectId, locationId, resourceId };
}

