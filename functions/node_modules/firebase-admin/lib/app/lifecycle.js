
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FIREBASE_CONFIG_VAR = exports.defaultAppStore = exports.AppStore = void 0;
exports.initializeApp = initializeApp;
exports.getApp = getApp;
exports.getApps = getApps;
exports.deleteApp = deleteApp;
const fs = require("fs");
const validator = require("../utils/validator");
const error_1 = require("../utils/error");
const credential_internal_1 = require("./credential-internal");
const firebase_app_1 = require("./firebase-app");
const fastDeepEqual = require('fast-deep-equal');
const DEFAULT_APP_NAME = '[DEFAULT]';
class AppStore {
    constructor() {
        this.appStore = new Map();
    }
    initializeApp(options, appName = DEFAULT_APP_NAME) {
        validateAppNameFormat(appName);
        let autoInit = false;
        if (typeof options === 'undefined') {
            autoInit = true;
            options = loadOptionsFromEnvVar();
            options.credential = (0, credential_internal_1.getApplicationDefault)();
        }


        if (!this.appStore.has(appName)) {
            const app = new firebase_app_1.FirebaseApp(options, appName, autoInit, this);
            this.appStore.set(app.name, app);
            return app;
        }
        const currentApp = this.appStore.get(appName);

        if (currentApp.autoInit() !== autoInit) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `A Firebase app named "${appName}" already exists with a different configuration.`);
        }
        if (autoInit) {


            return currentApp;
        }

        validateAppOptionsSupportDeepEquals(options, currentApp);



        const currentAppOptions = { ...currentApp.options };
        delete currentAppOptions.credential;
        if (!fastDeepEqual(options, currentAppOptions)) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `A Firebase app named "${appName}" already exists with a different configuration.`);
        }
        return currentApp;
    }
    getApp(appName = DEFAULT_APP_NAME) {
        validateAppNameFormat(appName);
        if (!this.appStore.has(appName)) {
            let errorMessage = (appName === DEFAULT_APP_NAME)
                ? 'The default Firebase app does not exist. ' : `Firebase app named "${appName}" does not exist. `;
            errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);
        }
        return this.appStore.get(appName);
    }
    getApps() {

        return Array.from(this.appStore.values());
    }
    deleteApp(app) {
        if (typeof app !== 'object' || app === null || !('options' in app)) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');
        }

        const existingApp = getApp(app.name);


        return existingApp.delete();
    }
    clearAllApps() {
        const promises = [];
        this.getApps().forEach((app) => {
            promises.push(this.deleteApp(app));
        });
        return Promise.all(promises).then();
    }
    
    removeApp(appName) {
        this.appStore.delete(appName);
    }
}
exports.AppStore = AppStore;

function validateAppOptionsSupportDeepEquals(requestedOptions, existingApp) {

    if (typeof requestedOptions.httpAgent !== 'undefined') {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Firebase app named "${existingApp.name}" already exists and initializeApp was` +
            ' invoked with an optional http.Agent. The SDK cannot confirm the equality' +
            ' of http.Agent objects with the existing app. Please use getApp or getApps to reuse' +
            ' the existing app instead.');
    }
    else if (typeof existingApp.options.httpAgent !== 'undefined') {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `An existing app named "${existingApp.name}" already exists with a different` +
            ' options configuration: httpAgent.');
    }

    if (typeof requestedOptions.credential !== 'undefined') {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Firebase app named "${existingApp.name}" already exists and initializeApp was` +
            ' invoked with an optional Credential. The SDK cannot confirm the equality' +
            ' of Credential objects with the existing app. Please use getApp or getApps' +
            ' to reuse the existing app instead.');
    }
    if (existingApp.customCredential()) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `An existing app named "${existingApp.name}" already exists with a different` +
            ' options configuration: Credential.');
    }
}

function validateAppNameFormat(appName) {
    if (!validator.isNonEmptyString(appName)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
    }
}
exports.defaultAppStore = new AppStore();

function initializeApp(options, appName = DEFAULT_APP_NAME) {
    return exports.defaultAppStore.initializeApp(options, appName);
}

function getApp(appName = DEFAULT_APP_NAME) {
    return exports.defaultAppStore.getApp(appName);
}

function getApps() {
    return exports.defaultAppStore.getApps();
}

function deleteApp(app) {
    return exports.defaultAppStore.deleteApp(app);
}

exports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';

function loadOptionsFromEnvVar() {
    const config = process.env[exports.FIREBASE_CONFIG_VAR];
    if (!validator.isNonEmptyString(config)) {
        return {};
    }
    try {
        const contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');
        return JSON.parse(contents);
    }
    catch (error) {

        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);
    }
}

