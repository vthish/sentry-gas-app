
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createFirebaseError = createFirebaseError;
exports.getErrorCode = getErrorCode;
const error_1 = require("../utils/error");
const validator = require("../utils/validator");

function createFirebaseError(err) {
    if (err.response.isJson()) {

        const json = err.response.data;
        const errorCode = getErrorCode(json);
        const errorMessage = getErrorMessage(json);
        return error_1.FirebaseMessagingError.fromServerError(errorCode, errorMessage, json);
    }

    let error;
    switch (err.response.status) {
        case 400:
            error = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;
            break;
        case 401:
        case 403:
            error = error_1.MessagingClientErrorCode.AUTHENTICATION_ERROR;
            break;
        case 500:
            error = error_1.MessagingClientErrorCode.INTERNAL_ERROR;
            break;
        case 503:
            error = error_1.MessagingClientErrorCode.SERVER_UNAVAILABLE;
            break;
        default:

            error = error_1.MessagingClientErrorCode.UNKNOWN_ERROR;
    }
    return new error_1.FirebaseMessagingError({
        code: error.code,
        message: `${error.message} Raw server response: "${err.response.text}". Status code: ` +
            `${err.response.status}.`,
    });
}

function getErrorCode(response) {
    if (validator.isNonNullObject(response) && 'error' in response) {
        const error = response.error;
        if (validator.isString(error)) {
            return error;
        }
        if (validator.isArray(error.details)) {
            const fcmErrorType = 'type.googleapis.com/google.firebase.fcm.v1.FcmError';
            for (const element of error.details) {
                if (element['@type'] === fcmErrorType) {
                    return element.errorCode;
                }
            }
        }
        if ('status' in error) {
            return error.status;
        }
        else {
            return error.message;
        }
    }
    return null;
}

function getErrorMessage(response) {
    if (validator.isNonNullObject(response) &&
        'error' in response &&
        validator.isNonEmptyString(response.error.message)) {
        return response.error.message;
    }
    return null;
}

